<script>
/**
 * ===================================================================
 * PERFORMANCE OPTIMIZER - Phase 11 (Real Phase 4 Roadmap)
 * ===================================================================
 *
 * Syst√®me centralis√© d'optimisation performance :
 * 1. Debounce updateCharts (32 appels ‚Üí debounced)
 * 2. Cache DOM refs (1184 acc√®s ‚Üí cached)
 * 3. Batch DOM operations (documentFragment)
 *
 * Gain attendu : 6.0/10 ‚Üí 7.5/10 performance
 * ===================================================================
 */

// ===================================================================
// 1. DEBOUNCE UTILITY (Universal)
// ===================================================================

/**
 * Cr√©e une fonction debounced qui retarde l'ex√©cution jusqu'√† ce que
 * le d√©lai soit √©coul√© sans nouveaux appels
 * @param {Function} func - Fonction √† debouncer
 * @param {number} wait - D√©lai en ms (d√©faut: 150ms)
 * @param {boolean} immediate - Ex√©cuter imm√©diatement au premier appel
 * @returns {Function} Fonction debounc√©e
 */
function debounce(func, wait = 150, immediate = false) {
  let timeout;
  let callCount = 0;

  const debounced = function(...args) {
    const context = this;
    callCount++;

    const later = function() {
      timeout = null;
      if (!immediate) {
        const count = callCount;
        callCount = 0;
        console.log(`‚ö° Debounce: Ex√©cution apr√®s ${count} appels group√©s`);
        func.apply(context, args);
      }
    };

    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };

  // M√©thode pour forcer l'ex√©cution imm√©diate
  debounced.flush = function() {
    if (timeout) {
      clearTimeout(timeout);
      const context = this;
      const count = callCount;
      callCount = 0;
      console.log(`‚ö° Debounce: Flush forc√© apr√®s ${count} appels`);
      func.apply(context);
    }
  };

  // M√©thode pour annuler
  debounced.cancel = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
      callCount = 0;
    }
  };

  return debounced;
}

/**
 * Throttle: limite l'ex√©cution √† une fois par p√©riode
 * @param {Function} func - Fonction √† throttler
 * @param {number} limit - P√©riode minimale entre ex√©cutions (ms)
 * @returns {Function} Fonction throttled
 */
function throttle(func, limit = 100) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// ===================================================================
// 2. DOM CACHE SYSTEM
// ===================================================================

/**
 * Cache centralis√© pour r√©f√©rences DOM
 * R√©duit 1184+ acc√®s DOM r√©p√©t√©s
 */
class DOMCache {
  constructor() {
    this.cache = new Map();
    this.stats = {
      hits: 0,
      misses: 0,
      invalidations: 0
    };
  }

  /**
   * R√©cup√®re un √©l√©ment du cache ou du DOM
   * @param {string} selector - S√©lecteur CSS ou ID
   * @param {boolean} forceRefresh - Forcer le refresh
   * @returns {Element|null}
   */
  get(selector, forceRefresh = false) {
    if (!forceRefresh && this.cache.has(selector)) {
      const element = this.cache.get(selector);
      // V√©rifier que l'√©l√©ment existe toujours dans le DOM
      if (element && element.isConnected) {
        this.stats.hits++;
        return element;
      }
      // L'√©l√©ment a √©t√© supprim√©, invalider le cache
      this.cache.delete(selector);
    }

    this.stats.misses++;
    const element = document.querySelector(selector);
    if (element) {
      this.cache.set(selector, element);
    }
    return element;
  }

  /**
   * R√©cup√®re tous les √©l√©ments matchant le s√©lecteur
   * @param {string} selector - S√©lecteur CSS
   * @param {boolean} forceRefresh - Forcer le refresh
   * @returns {NodeList}
   */
  getAll(selector, forceRefresh = false) {
    const cacheKey = `all:${selector}`;

    if (!forceRefresh && this.cache.has(cacheKey)) {
      const elements = this.cache.get(cacheKey);
      // V√©rifier que les √©l√©ments existent toujours
      if (elements && elements.length > 0 && elements[0].isConnected) {
        this.stats.hits++;
        return elements;
      }
      this.cache.delete(cacheKey);
    }

    this.stats.misses++;
    const elements = document.querySelectorAll(selector);
    this.cache.set(cacheKey, elements);
    return elements;
  }

  /**
   * Invalide le cache pour un s√©lecteur ou tout le cache
   * @param {string} selector - S√©lecteur √† invalider (optionnel)
   */
  invalidate(selector = null) {
    if (selector) {
      this.cache.delete(selector);
      this.cache.delete(`all:${selector}`);
    } else {
      this.cache.clear();
    }
    this.stats.invalidations++;
  }

  /**
   * Pr√©-charge des √©l√©ments fr√©quemment utilis√©s
   * @param {Array<string>} selectors - Liste de s√©lecteurs
   */
  preload(selectors) {
    console.log(`üéØ DOMCache: Pr√©-chargement de ${selectors.length} s√©lecteurs`);
    selectors.forEach(selector => this.get(selector));
  }

  /**
   * Affiche les statistiques du cache
   */
  getStats() {
    const total = this.stats.hits + this.stats.misses;
    const hitRate = total > 0 ? (this.stats.hits / total * 100).toFixed(1) : 0;
    return {
      ...this.stats,
      total,
      hitRate: `${hitRate}%`,
      cacheSize: this.cache.size
    };
  }

  /**
   * Log les stats dans la console
   */
  logStats() {
    const stats = this.getStats();
    console.log('üìä DOMCache Stats:', stats);
  }
}

// Instance globale du cache DOM
window.DOM = window.DOM || new DOMCache();

// ===================================================================
// 3. BATCH DOM OPERATIONS
// ===================================================================

/**
 * Gestionnaire de batch DOM operations avec documentFragment
 */
class DOMBatcher {
  constructor() {
    this.pendingOperations = [];
    this.batchTimeout = null;
    this.stats = {
      batches: 0,
      operations: 0,
      avgBatchSize: 0
    };
  }

  /**
   * Ajoute une op√©ration au batch
   * @param {Function} operation - Op√©ration √† ex√©cuter
   * @param {number} delay - D√©lai avant ex√©cution (ms)
   */
  queue(operation, delay = 16) {
    this.pendingOperations.push(operation);

    // Programmer l'ex√©cution du batch
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
    }

    this.batchTimeout = setTimeout(() => {
      this.flush();
    }, delay);
  }

  /**
   * Ex√©cute toutes les op√©rations en attente
   */
  flush() {
    if (this.pendingOperations.length === 0) return;

    const batchSize = this.pendingOperations.length;
    console.log(`‚ö° DOMBatcher: Ex√©cution de ${batchSize} op√©rations group√©es`);

    // Utiliser requestAnimationFrame pour synchroniser avec le repaint
    requestAnimationFrame(() => {
      // Cr√©er un fragment pour minimiser les reflows
      const fragment = document.createDocumentFragment();

      // Ex√©cuter toutes les op√©rations
      this.pendingOperations.forEach(op => {
        try {
          op(fragment);
        } catch (error) {
          console.error('‚ùå Erreur dans batch operation:', error);
        }
      });

      // Mettre √† jour les stats
      this.stats.batches++;
      this.stats.operations += batchSize;
      this.stats.avgBatchSize = this.stats.operations / this.stats.batches;

      // Vider la queue
      this.pendingOperations = [];
      this.batchTimeout = null;
    });
  }

  /**
   * Cr√©e et retourne un documentFragment optimis√©
   * @param {Array<Element>} elements - √âl√©ments √† ajouter
   * @returns {DocumentFragment}
   */
  createFragment(elements) {
    const fragment = document.createDocumentFragment();
    elements.forEach(el => fragment.appendChild(el));
    return fragment;
  }

  /**
   * Remplace le contenu d'un √©l√©ment avec batch
   * @param {Element} container - Conteneur cible
   * @param {Array<Element>} newElements - Nouveaux √©l√©ments
   */
  replaceContent(container, newElements) {
    this.queue(() => {
      // Vider le conteneur
      container.innerHTML = '';
      // Ajouter tous les √©l√©ments via fragment
      const fragment = this.createFragment(newElements);
      container.appendChild(fragment);
    });
  }

  /**
   * Ajoute plusieurs √©l√©ments avec batch
   * @param {Element} container - Conteneur cible
   * @param {Array<Element>} elements - √âl√©ments √† ajouter
   */
  appendMany(container, elements) {
    this.queue(() => {
      const fragment = this.createFragment(elements);
      container.appendChild(fragment);
    });
  }

  /**
   * Affiche les statistiques
   */
  logStats() {
    console.log('üìä DOMBatcher Stats:', this.stats);
  }
}

// Instance globale du batcher
window.DOMBatcher = window.DOMBatcher || new DOMBatcher();

// ===================================================================
// 4. DEBOUNCED updateCharts (CRITIQUE)
// ===================================================================

/**
 * Wrapper debounced pour updateCharts
 * R√©duit 32 appels multiples en appels group√©s
 */
(function initUpdateChartsOptimization() {
  // Sauvegarder la fonction originale
  const originalUpdateCharts = window.updateCharts;

  if (!originalUpdateCharts) {
    console.warn('‚ö†Ô∏è updateCharts non trouv√©e, optimisation skipp√©e');
    return;
  }

  // Cr√©er une version debounc√©e (150ms = bon √©quilibre r√©activit√©/perf)
  const debouncedUpdateCharts = debounce(originalUpdateCharts, 150, false);

  // Compteur d'appels pour stats
  let callCount = 0;
  let lastLogTime = Date.now();

  // Wrapper avec stats
  window.updateCharts = function(...args) {
    callCount++;

    // Log stats toutes les 5 secondes
    const now = Date.now();
    if (now - lastLogTime > 5000) {
      console.log(`‚ö° updateCharts: ${callCount} appels dans les 5 derni√®res secondes`);
      callCount = 0;
      lastLogTime = now;
    }

    // Appeler la version debounc√©e
    return debouncedUpdateCharts.apply(this, args);
  };

  // Exposer la version non-debounc√©e pour les cas d'urgence
  window.updateCharts.immediate = originalUpdateCharts;
  window.updateCharts.flush = debouncedUpdateCharts.flush;
  window.updateCharts.cancel = debouncedUpdateCharts.cancel;

  console.log('‚úÖ updateCharts optimis√©e avec debounce (150ms)');
})();

// ===================================================================
// 5. PR√â-CHARGEMENT DES √âL√âMENTS DOM CRITIQUES
// ===================================================================

/**
 * Pr√©-charge les √©l√©ments DOM les plus fr√©quemment utilis√©s
 */
function preloadCriticalDOMElements() {
  const criticalSelectors = [
    // Graphiques
    '#chartCommunication',
    '#chartDistribution',
    '#chartLV2',
    '#chartOptions',

    // Containers
    '.class-columns-container',
    '#globalStats',
    '#statsPanel',

    // Colonnes de classes
    '.class-column',

    // Zones de drag & drop
    '.dropzone',

    // Modales communes
    '#configModal',
    '#helpModal',

    // Boutons d'action
    '#optimizeButton',
    '#saveButton',
    '#loadButton'
  ];

  console.log('üéØ Pr√©-chargement des √©l√©ments DOM critiques...');
  window.DOM.preload(criticalSelectors);

  // Log stats apr√®s pr√©-chargement
  setTimeout(() => {
    window.DOM.logStats();
  }, 100);
}

// Pr√©-charger au d√©marrage
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', preloadCriticalDOMElements);
} else {
  preloadCriticalDOMElements();
}

// ===================================================================
// 6. MONITORING ET DEBUG
// ===================================================================

/**
 * Active le mode debug pour surveiller les performances
 */
window.PerformanceDebug = {
  enabled: false,

  toggle() {
    this.enabled = !this.enabled;
    console.log(`üîç Performance Debug: ${this.enabled ? 'ACTIV√â' : 'D√âSACTIV√â'}`);
  },

  logAllStats() {
    console.group('üìä Performance Optimizer Stats');
    window.DOM.logStats();
    window.DOMBatcher.logStats();
    console.groupEnd();
  },

  resetStats() {
    window.DOM.stats = { hits: 0, misses: 0, invalidations: 0 };
    window.DOMBatcher.stats = { batches: 0, operations: 0, avgBatchSize: 0 };
    console.log('‚úÖ Stats r√©initialis√©es');
  }
};

// Exposer les outils globalement pour debug
window.debounce = debounce;
window.throttle = throttle;

console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  ‚ö° PERFORMANCE OPTIMIZER - Phase 11 Initialis√©           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  ‚úÖ Debounce updateCharts (150ms)                         ‚ïë
‚ïë  ‚úÖ DOMCache syst√®me activ√©                               ‚ïë
‚ïë  ‚úÖ DOMBatcher pour batch operations                      ‚ïë
‚ïë  ‚úÖ Pr√©-chargement √©l√©ments critiques                     ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üìä Debug: PerformanceDebug.toggle()                      ‚ïë
‚ïë  üìä Stats:  PerformanceDebug.logAllStats()                ‚ïë
‚ïë  üîÑ Reset:  PerformanceDebug.resetStats()                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

// ===================================================================
// 7. HELPERS POUR MIGRATION PROGRESSIVE
// ===================================================================

/**
 * Helpers pour faciliter la migration du code existant
 */
window.PerformanceHelpers = {
  /**
   * Remplace document.querySelector avec cache
   */
  $(selector) {
    return window.DOM.get(selector);
  },

  /**
   * Remplace document.querySelectorAll avec cache
   */
  $$(selector) {
    return window.DOM.getAll(selector);
  },

  /**
   * Invalide le cache apr√®s modifications DOM
   */
  invalidateCache(selector = null) {
    window.DOM.invalidate(selector);
  },

  /**
   * Cr√©e un batch d'op√©rations DOM
   */
  batchDOM(operations, delay = 16) {
    operations.forEach(op => window.DOMBatcher.queue(op, delay));
  }
};

// Exposer $ et $$ globalement (optionnel, pour compatibilit√© jQuery-like)
if (!window.$) {
  window.$ = window.PerformanceHelpers.$;
  window.$$ = window.PerformanceHelpers.$$;
  console.log('‚úÖ Helpers $ et $$ expos√©s globalement');
}

</script>
