<script>
// ğŸ”„ Cache Buster: 2025-01-09 14:35:00 UTC - Force Google Apps Script reload
/**
 * GROUPS ALGORITHM V4 - ALGORITHME COMPLET
 *
 * RÃ©partition intelligente avec :
 * - Normalisation statistique (z-scores)
 * - Indice pondÃ©rÃ© par scÃ©nario
 * - Distribution serpentin/tranches
 * - Ã‰quilibrage automatique de paritÃ© (F/M)
 * - Statistiques complÃ¨tes (COM, TRA, PART, ABS, Scores F/M)
 *
 * DonnÃ©es sources (colonnes Excel) :
 * - E: SEXE (F/M)
 * - H: COM (comportement)
 * - I: TRA (travail)
 * - J: PART (participation)
 * - K: ABS (absences)
 * - U: SCORE F (FranÃ§ais, 1-4)
 * - V: SCORE M (Maths, 1-4)
 */

const GroupsAlgorithmV4 = (function() {
  'use strict';

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CONFIGURATION DES COEFFICIENTS PAR SCÃ‰NARIO
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const SCENARIO_WEIGHTS = {
    besoins: {
      // Groupes de besoins : prioritÃ© aux scores acadÃ©miques
      scoreF: 3.0,
      scoreM: 3.0,
      com: 1.5,
      tra: 1.5,
      part: 1.0,
      abs: -2.0 // PÃ©nalitÃ© pour absences
    },
    lv2: {
      // Groupes LV2 : prioritÃ© Ã  la participation
      scoreF: 1.0,
      scoreM: 1.0,
      com: 1.5,
      tra: 1.5,
      part: 4.0, // PRIORITAIRE
      abs: -2.5
    },
    options: {
      // Groupes options : Ã©quilibrÃ©
      scoreF: 2.0,
      scoreM: 2.0,
      com: 2.0,
      tra: 2.0,
      part: 2.0,
      abs: -1.5
    }
  };

  const PARITY_TOLERANCE = 0.15; // TolÃ©rance d'Ã©cart F/M : 15%

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VALIDATION DES COEFFICIENTS DE PONDÃ‰RATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Valide et sÃ©curise les coefficients de pondÃ©ration
   * CONTRÃ”LE MÃ‰TIER : Les coefficients doivent rester dans [-5, +5]
   * pour Ã©viter des indices pondÃ©rÃ©s instables
   *
   * @param {Object} weights - Objet contenant les coefficients
   * @param {string} context - Contexte pour le logging (ex: 'besoins')
   * @returns {Object} Coefficients validÃ©s et clampÃ©s
   */
  function validateWeights(weights, context = 'unknown') {
    const MIN_WEIGHT = -5;
    const MAX_WEIGHT = 5;
    const validatedWeights = {};
    let hasWarning = false;

    // CritÃ¨res obligatoires
    const requiredFields = ['scoreF', 'scoreM', 'com', 'tra', 'part', 'abs'];

    requiredFields.forEach(field => {
      const value = parseFloat(weights[field]);

      // Validation 1 : Valeur numÃ©rique valide
      if (isNaN(value) || !isFinite(value)) {
        console.error(`âŒ [validateWeights:${context}] Coefficient "${field}" invalide (${weights[field]}) â†’ fallback 0`);
        validatedWeights[field] = 0;
        hasWarning = true;
        return;
      }

      // Validation 2 : Bornes mÃ©tiers [-5, +5]
      const originalValue = value;
      const clampedValue = Math.max(MIN_WEIGHT, Math.min(MAX_WEIGHT, value));

      if (originalValue !== clampedValue) {
        console.warn(`âš ï¸ [validateWeights:${context}] Coefficient "${field}" hors bornes [${MIN_WEIGHT}, ${MAX_WEIGHT}] â†’ ${originalValue.toFixed(2)} clampÃ© Ã  ${clampedValue.toFixed(2)}`);
        hasWarning = true;
      }

      // Validation 3 : Valeurs extrÃªmes (avertissement si > 80% du max)
      if (Math.abs(clampedValue) > MAX_WEIGHT * 0.8) {
        console.warn(`âš ï¸ [validateWeights:${context}] Coefficient "${field}" trÃ¨s Ã©levÃ© (${clampedValue.toFixed(2)}) â†’ risque de domination sur l'indice pondÃ©rÃ©`);
      }

      validatedWeights[field] = clampedValue;
    });

    // Validation 4 : Somme des coefficients (avertissement si dÃ©sÃ©quilibre massif)
    const sumPositive = Object.values(validatedWeights).filter(v => v > 0).reduce((sum, v) => sum + v, 0);
    const sumNegative = Math.abs(Object.values(validatedWeights).filter(v => v < 0).reduce((sum, v) => sum + v, 0));

    if (sumPositive === 0) {
      console.error(`âŒ [validateWeights:${context}] Tous les coefficients positifs sont nuls â†’ algorithme ne peut pas fonctionner correctement`);
    }

    if (sumPositive > 0 && sumNegative / sumPositive > 1.5) {
      console.warn(`âš ï¸ [validateWeights:${context}] DÃ©sÃ©quilibre coefficients : pÃ©nalitÃ©s (${sumNegative.toFixed(1)}) > 150% des bonus (${sumPositive.toFixed(1)})`);
    }

    if (hasWarning) {
      console.warn(`âš ï¸ [validateWeights:${context}] Coefficients validÃ©s avec avertissements:`, validatedWeights);
    } else {
      console.log(`âœ… [validateWeights:${context}] Coefficients validÃ©s:`, validatedWeights);
    }

    return validatedWeights;
  }

  // Valider les coefficients au chargement
  Object.keys(SCENARIO_WEIGHTS).forEach(scenario => {
    SCENARIO_WEIGHTS[scenario] = validateWeights(SCENARIO_WEIGHTS[scenario], scenario);
  });

  function resolveCriteriaWeights(scenario, overrides = null, source = 'scenario-default') {
    const baseWeights = { ...(SCENARIO_WEIGHTS[scenario] || SCENARIO_WEIGHTS.besoins) };
    let appliedSource = source || 'custom-overrides';
    let overridesApplied = false;

    if (!overrides || appliedSource === 'scenario-default') {
      console.log('ğŸšï¸ PondÃ©rations rÃ©solues', {
        scenario,
        source: 'scenario-default',
        overridesApplied: false,
        weights: baseWeights
      });
      return {
        weights: baseWeights,
        source: 'scenario-default',
        overridesApplied: false
      };
    }

    if (typeof overrides === 'object') {
      const sanitizedOverrides = {};
      ['com', 'tra', 'part', 'abs'].forEach(key => {
        if (overrides[key] === undefined || overrides[key] === null || overrides[key] === '') {
          return;
        }
        const value = parseFloat(overrides[key]);
        if (!isNaN(value) && isFinite(value)) {
          if (key === 'abs') {
            sanitizedOverrides[key] = value >= 0 ? -Math.abs(value) : value;
          } else {
            sanitizedOverrides[key] = value;
          }
        }
      });

      if (Object.keys(sanitizedOverrides).length > 0) {
        Object.assign(baseWeights, sanitizedOverrides);
        overridesApplied = true;
      }
    }

    const validated = validateWeights(baseWeights, `${scenario}-${appliedSource}`);
    if (!overridesApplied) {
      appliedSource = 'scenario-default';
    }

    console.log('ğŸšï¸ PondÃ©rations rÃ©solues', {
      scenario,
      source: appliedSource,
      overridesApplied,
      weights: validated
    });

    return {
      weights: validated,
      source: appliedSource,
      overridesApplied
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ã‰TAPE 1 : CONSOLIDATION DES DONNÃ‰ES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function consolidateStudents(students) {
    return students.map(student => {
      // Extraire et valider tous les champs
      const scoreF = parseFloat(student.scoreF || student.scores?.F || 0);
      const scoreM = parseFloat(student.scoreM || student.scores?.M || 0);
      const com = parseFloat(student.com || student.COM || 0);
      const tra = parseFloat(student.tra || student.TRA || 0);
      const part = parseFloat(student.part || student.PART || 0);
      const abs = parseFloat(student.abs || student.ABS || 0);
      const sexe = (student.sexe || student.gender || 'M').toUpperCase();

      return {
        ...student,
        scoreF: isNaN(scoreF) ? 0 : scoreF,
        scoreM: isNaN(scoreM) ? 0 : scoreM,
        com: isNaN(com) ? 0 : com,
        tra: isNaN(tra) ? 0 : tra,
        part: isNaN(part) ? 0 : part,
        abs: isNaN(abs) ? 0 : abs,
        sexe: sexe === 'F' || sexe === 'M' ? sexe : 'M',
        originalClass: student.class || student.classe || ''
      };
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ã‰TAPE 2 : NORMALISATION STATISTIQUE (Z-SCORES)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Calcule la moyenne d'un tableau de valeurs
   */
  function mean(values) {
    if (!values || values.length === 0) return 0;
    return values.reduce((sum, val) => sum + val, 0) / values.length;
  }

  /**
   * Calcule l'Ã©cart-type d'un tableau de valeurs
   */
  function stdDev(values, avg) {
    if (!values || values.length === 0) return 1;
    const variance = values.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / values.length;
    return Math.sqrt(variance) || 1; // Ã‰viter division par zÃ©ro
  }

  /**
   * Calcule le z-score (Ã©cart normalisÃ©)
   */
  function zScore(value, avg, std) {
    if (std === 0) return 0;
    return (value - avg) / std;
  }

  /**
   * Normalise tous les indicateurs en z-scores
   */
  function normalizeWithZScores(students) {
    const fields = ['scoreF', 'scoreM', 'com', 'tra', 'part', 'abs'];
    const stats = {};

    // Calculer moyenne et Ã©cart-type pour chaque champ
    fields.forEach(field => {
      const values = students.map(s => s[field]).filter(v => v !== null && v !== undefined);
      const avg = mean(values);
      const std = stdDev(values, avg);
      stats[field] = { avg, std };
    });

    // Appliquer les z-scores Ã  chaque Ã©lÃ¨ve
    return students.map(student => {
      const normalized = { ...student };

      fields.forEach(field => {
        const { avg, std } = stats[field];
        normalized[`${field}_z`] = zScore(student[field], avg, std);
      });

      return normalized;
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ã‰TAPE 3 : CALCUL DE L'INDICE PONDÃ‰RÃ‰ PAR SCÃ‰NARIO
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function calculateWeightedIndex(student, weights) {
    const resolved = weights || SCENARIO_WEIGHTS.besoins;

    // Indice = somme des (z-score Ã— coefficient)
    const index =
      (student.scoreF_z || 0) * resolved.scoreF +
      (student.scoreM_z || 0) * resolved.scoreM +
      (student.com_z || 0) * resolved.com +
      (student.tra_z || 0) * resolved.tra +
      (student.part_z || 0) * resolved.part +
      (student.abs_z || 0) * resolved.abs; // NÃ©gatif pour pÃ©naliser

    return index;
  }

  function addWeightedIndices(students, weights) {
    return students.map(student => ({
      ...student,
      weightedIndex: calculateWeightedIndex(student, weights)
    }));
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ã‰TAPE 4 : DISTRIBUTION INITIALE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /**
   * Distribution hÃ©tÃ©rogÃ¨ne : mÃ©lange les niveaux (serpentin)
   */
  function distributeHeterogeneous(students, numGroups) {
    // Trier par indice dÃ©croissant
    const sorted = [...students].sort((a, b) => (b.weightedIndex || 0) - (a.weightedIndex || 0));

    // Initialiser les groupes
    const groups = Array.from({ length: numGroups }, (_, i) => ({
      id: i + 1,
      name: `Groupe ${i + 1}`,
      students: []
    }));

    // Distribution en serpentin
    let groupIndex = 0;
    let direction = 1; // 1 = vers la droite, -1 = vers la gauche

    sorted.forEach(student => {
      groups[groupIndex].students.push(student);
      groupIndex += direction;

      // Inverser aux extrÃ©mitÃ©s
      if (groupIndex >= numGroups) {
        groupIndex = numGroups - 1;
        direction = -1;
      } else if (groupIndex < 0) {
        groupIndex = 0;
        direction = 1;
      }
    });

    return groups;
  }

  /**
   * Distribution homogÃ¨ne : groupes de niveaux similaires (tranches)
   */
  function distributeHomogeneous(students, numGroups) {
    // Trier par indice dÃ©croissant
    const sorted = [...students].sort((a, b) => (b.weightedIndex || 0) - (a.weightedIndex || 0));

    // Initialiser les groupes
    const groups = Array.from({ length: numGroups }, (_, i) => ({
      id: i + 1,
      name: `Groupe ${i + 1}`,
      students: []
    }));

    // Distribution par tranches (round-robin)
    sorted.forEach((student, index) => {
      const groupIndex = index % numGroups;
      groups[groupIndex].students.push(student);
    });

    return groups;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ã‰TAPE 5 : Ã‰QUILIBRAGE AUTOMATIQUE DE PARITÃ‰ (F/M)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function calculateParityRatio(group) {
    const total = group.students.length;
    if (total === 0) return { girls: 0, boys: 0, ratio: 0, total: 0 };

    const girls = group.students.filter(s => s.sexe === 'F').length;
    const boys = group.students.filter(s => s.sexe === 'M').length;
    const ratio = girls / total;

    return { girls, boys, ratio, total };
  }

  function balanceGender(groups) {
    const maxIterations = 100; // Ã‰viter boucles infinies
    let iteration = 0;
    let swapsMade = false;

    do {
      swapsMade = false;
      iteration++;

      // Calculer les ratios pour chaque groupe
      const parityData = groups.map((group, index) => ({
        index,
        ...calculateParityRatio(group)
      }));

      // Trouver les groupes dÃ©sÃ©quilibrÃ©s
      const targetRatio = mean(parityData.map(p => p.ratio));

      for (let i = 0; i < groups.length; i++) {
        const groupA = groups[i];
        const dataA = parityData[i];

        // Si le groupe est trop dÃ©sÃ©quilibrÃ©
        if (Math.abs(dataA.ratio - targetRatio) > PARITY_TOLERANCE) {
          // Chercher un groupe avec qui Ã©changer
          for (let j = i + 1; j < groups.length; j++) {
            const groupB = groups[j];
            const dataB = parityData[j];

            // Essayer d'Ã©changer une fille contre un garÃ§on (ou vice-versa)
            if (dataA.ratio > targetRatio && dataB.ratio < targetRatio) {
              // Groupe A a trop de filles, groupe B pas assez
              const girlFromA = groupA.students.find(s => s.sexe === 'F');
              const boyFromB = groupB.students.find(s => s.sexe === 'M');

              if (girlFromA && boyFromB) {
                // Swap
                groupA.students = groupA.students.filter(s => s.id !== girlFromA.id);
                groupA.students.push(boyFromB);
                groupB.students = groupB.students.filter(s => s.id !== boyFromB.id);
                groupB.students.push(girlFromA);
                swapsMade = true;
              }
            } else if (dataA.ratio < targetRatio && dataB.ratio > targetRatio) {
              // Groupe A a trop de garÃ§ons, groupe B trop de filles
              const boyFromA = groupA.students.find(s => s.sexe === 'M');
              const girlFromB = groupB.students.find(s => s.sexe === 'F');

              if (boyFromA && girlFromB) {
                // Swap
                groupA.students = groupA.students.filter(s => s.id !== boyFromA.id);
                groupA.students.push(girlFromB);
                groupB.students = groupB.students.filter(s => s.id !== girlFromB.id);
                groupB.students.push(boyFromA);
                swapsMade = true;
              }
            }
          }
        }
      }
    } while (swapsMade && iteration < maxIterations);

    console.log(`âœ… Ã‰quilibrage de paritÃ© terminÃ© aprÃ¨s ${iteration} itÃ©ration(s)`);
    return groups;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ã‰TAPE 6 : CALCUL DES STATISTIQUES COMPLÃˆTES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function calculateGroupStats(groups) {
    return groups.map(group => {
      const students = group.students;
      const total = students.length;

      if (total === 0) {
        return {
          groupId: group.id,
          name: group.name,
          totalStudents: 0,
          girls: 0,
          boys: 0,
          parityRatio: 0,
          avgScoreF: 0,
          avgScoreM: 0,
          avgCOM: 0,
          avgTRA: 0,
          avgPART: 0,
          avgABS: 0
        };
      }

      const girls = students.filter(s => s.sexe === 'F').length;
      const boys = students.filter(s => s.sexe === 'M').length;

      return {
        groupId: group.id,
        name: group.name,
        totalStudents: total,
        girls,
        boys,
        parityRatio: (girls / total * 100).toFixed(1) + '%',
        avgScoreF: mean(students.map(s => s.scoreF)).toFixed(2),
        avgScoreM: mean(students.map(s => s.scoreM)).toFixed(2),
        avgCOM: mean(students.map(s => s.com)).toFixed(2),
        avgTRA: mean(students.map(s => s.tra)).toFixed(2),
        avgPART: mean(students.map(s => s.part)).toFixed(2),
        avgABS: mean(students.map(s => s.abs)).toFixed(2)
      };
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Ã‰TAPE 7 : VALIDATION FINALE ET ALERTES
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function validateAndAlert(groups, stats) {
    const warnings = [];
    const alerts = [];

    // VÃ©rifier la paritÃ©
    const parityRatios = stats.map(s => parseFloat(s.parityRatio));
    const maxParity = Math.max(...parityRatios);
    const minParity = Math.min(...parityRatios);
    const parityGap = maxParity - minParity;

    if (parityGap > PARITY_TOLERANCE * 100) {
      warnings.push(`âš ï¸ Ã‰cart de paritÃ© F/M de ${parityGap.toFixed(1)}% entre groupes`);
    }

    // VÃ©rifier les effectifs
    const sizes = stats.map(s => s.totalStudents);
    const maxSize = Math.max(...sizes);
    const minSize = Math.min(...sizes);
    const sizeGap = maxSize - minSize;

    if (sizeGap > 2) {
      warnings.push(`âš ï¸ Ã‰cart d'effectifs de ${sizeGap} Ã©lÃ¨ves entre groupes`);
    }

    // VÃ©rifier les moyennes de scores
    const avgScoresF = stats.map(s => parseFloat(s.avgScoreF));
    const scoreGapF = Math.max(...avgScoresF) - Math.min(...avgScoresF);

    if (scoreGapF > 1.0) {
      alerts.push(`ğŸ“Š Ã‰cart de moyennes en FranÃ§ais : ${scoreGapF.toFixed(2)} points`);
    }

    return { warnings, alerts };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // POINT D'ENTRÃ‰E PRINCIPAL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  function distribute(config) {
    const {
      students = [],
      mode = 'heterogeneous', // 'heterogeneous' | 'homogeneous'
      numGroups = 3,
      scenario = 'besoins', // 'besoins' | 'lv2' | 'options'
      criteriaWeights = null,
      criteriaWeightsSource = 'scenario-default'
    } = config;

    console.log(`ğŸš€ Algorithme V4 : Distribution ${mode} pour ${students.length} Ã©lÃ¨ves en ${numGroups} groupes (scÃ©nario: ${scenario})`);

    // âœ¨ NOUVEAU : DÃ©terminer les pondÃ©rations Ã  utiliser
    let activeWeights;
    if (criteriaWeights) {
      // âœ¨ STRATÃ‰GIE DE MERGE : Partir du scÃ©nario puis appliquer les criteriaWeights
      // Cela permet au joystick de ne gÃ©rer que COM/TRA/PART/ABS
      // tout en conservant scoreF/scoreM du scÃ©nario
      const baseWeights = SCENARIO_WEIGHTS[scenario] || SCENARIO_WEIGHTS.besoins;
      const mergedWeights = { ...baseWeights, ...criteriaWeights };

      console.log('ğŸ›ï¸ Merge des pondÃ©rations personnalisÃ©es avec le scÃ©nario:', scenario);
      console.log('   Base (scÃ©nario):', baseWeights);
      console.log('   Custom (joystick):', criteriaWeights);
      console.log('   RÃ©sultat (merged):', mergedWeights);

      activeWeights = validateWeights(mergedWeights, 'custom');
    } else {
      // Utiliser les pondÃ©rations par dÃ©faut du scÃ©nario
      activeWeights = SCENARIO_WEIGHTS[scenario] || SCENARIO_WEIGHTS.besoins;
      console.log('ğŸ“Š Utilisation des pondÃ©rations du scÃ©nario:', scenario, activeWeights);
    }

    // Validation
    if (!students || students.length === 0) {
      throw new Error('Aucun Ã©lÃ¨ve fourni pour la rÃ©partition');
    }

    if (numGroups < 2) {
      throw new Error('Le nombre de groupes doit Ãªtre au minimum 2');
    }

    // Helper pour Ã©mettre progression
    const emitProgress = (step) => {
      const event = new CustomEvent('algorithm:progress', { detail: { step } });
      document.dispatchEvent(event);
    };

    // Ã‰TAPE 1 : Consolidation
    emitProgress(0);
    console.log('ğŸ“‹ Ã‰tape 1/7 : Consolidation des donnÃ©es...');
    const consolidated = consolidateStudents(students);

    // Ã‰TAPE 2 : Normalisation (z-scores)
    emitProgress(1);
    console.log('ğŸ“Š Ã‰tape 2/7 : Normalisation statistique (z-scores)...');
    const normalized = normalizeWithZScores(consolidated);

    // Ã‰TAPE 3 : Indice pondÃ©rÃ©
    emitProgress(2);
    console.log('âš–ï¸ Ã‰tape 3/7 : Calcul des indices pondÃ©rÃ©s...');
    const resolvedWeights = resolveCriteriaWeights(scenario, criteriaWeights, criteriaWeightsSource);
    console.log('âš–ï¸ PondÃ©rations appliquÃ©es Ã  l\'indice pondÃ©rÃ©:', resolvedWeights);
    const weighted = addWeightedIndices(normalized, resolvedWeights.weights);

    // Ã‰TAPE 4 : Distribution initiale
    emitProgress(3);
    console.log(`ğŸ”€ Ã‰tape 4/7 : Distribution ${mode}...`);
    const groups = mode === 'homogeneous'
      ? distributeHomogeneous(weighted, numGroups)
      : distributeHeterogeneous(weighted, numGroups);

    // Ã‰TAPE 5 : Ã‰quilibrage de paritÃ©
    emitProgress(4);
    console.log('ğŸ‘¥ Ã‰tape 5/7 : Ã‰quilibrage de la paritÃ© F/M...');
    const balanced = balanceGender(groups);

    // Ã‰TAPE 6 : Statistiques
    emitProgress(5);
    console.log('ğŸ“ˆ Ã‰tape 6/7 : Calcul des statistiques...');
    const stats = calculateGroupStats(balanced);

    // Ã‰TAPE 7 : Validation
    emitProgress(6);
    console.log('âœ… Ã‰tape 7/7 : Validation finale...');
    const { warnings, alerts } = validateAndAlert(balanced, stats);

    // RÃ©sultat final
    const result = {
      groups: balanced,
      stats,
      warnings,
      alerts,
      metadata: {
        mode,
        scenario,
        numGroups,
        totalStudents: students.length,
        timestamp: new Date().toISOString(),
        algorithm: 'V4-Complete',
        scenarioApplied: scenario,
        criteriaWeights: resolvedWeights.weights,
        criteriaWeightsSource: resolvedWeights.source,
        criteriaWeightsOverridesApplied: resolvedWeights.overridesApplied
      }
    };

    console.log(`âœ¨ Distribution terminÃ©e : ${balanced.length} groupes crÃ©Ã©s`);
    console.log(`ğŸ›ï¸ PondÃ©rations utilisÃ©es:`, activeWeights);
    return result;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // API PUBLIQUE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  return {
    distribute,
    // Exposer les sous-fonctions pour tests
    consolidateStudents,
    normalizeWithZScores,
    calculateWeightedIndex,
    distributeHeterogeneous,
    distributeHomogeneous,
    balanceGender,
    calculateGroupStats,
    validateAndAlert
  };
})();

// Export global
if (typeof window !== 'undefined') {
  window.GroupsAlgorithmV4 = GroupsAlgorithmV4;
  console.log('âœ… GroupsAlgorithmV4 (Version ComplÃ¨te) chargÃ©');
}
</script>
