<script>
  (function () {
    'use strict';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ›¡ï¸ DOM ENVIRONMENT GUARD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Protection contre l'exÃ©cution de code DOM cÃ´tÃ© serveur Apps Script
    // Si typeof document === 'undefined', on est cÃ´tÃ© serveur â†’ sortir
    if (typeof document === 'undefined') {
      console.warn('[CoreScript] Skipping client-side code in server context');
      return;
    }
    // Ã€ partir d'ici, le code s'exÃ©cute uniquement cÃ´tÃ© client (navigateur)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Scripts principaux extraits de InterfaceV2.html pour amÃ©liorer la lisibilitÃ©.
    // =======================================================
    // FONCTIONS UTILITAIRES GLOBALES (accessibles partout)
    // =======================================================

    /**
     * Ã‰chappe les caractÃ¨res HTML dangereux dans une chaÃ®ne.
     * Ã€ utiliser systÃ©matiquement avant toute insertion de donnÃ©es
     * utilisateur (noms, options, classes) via innerHTML.
     * @param {*} str - Valeur Ã  Ã©chapper
     * @returns {string} ChaÃ®ne HTML-safe
     */
    window.escapeHtml = function (str) {
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    };

    // ğŸ”§ PROTECTION REALTIME FEEDBACK
    window.RealTimeFeedback = window.RealTimeFeedback || null;


    // ========== GESTION DES NOTIFICATIONS ET CHARGEMENT ==========
    // Mapping global pour compatibilitÃ©
    window.toast = function (message, type, duration) {
      if (typeof UIComponents !== 'undefined' && UIComponents.Toast) {
        if (type === 'success') return UIComponents.Toast.success(message, duration);
        if (type === 'error') return UIComponents.Toast.error(message, duration);
        if (type === 'warning') return UIComponents.Toast.warning(message, duration);
        return UIComponents.Toast.info(message, duration);
      }
      console.log(`[TOAST] ${type}: ${message}`);
    };

    // Fonction de sauvegarde avec barre de progression via UIComponents
    async function saveWithProgressINT() {
      if (typeof UIComponents === 'undefined' || !UIComponents.LoadingOverlay) {
        console.warn("UIComponents non trouvÃ©, exÃ©cution de la sauvegarde sans overlay...");
        return _saveInternal(); // fallback basique
      }

      const steps = [
        { label: 'PrÃ©paration des donnÃ©es...', icon: 'âš™ï¸' },
        { label: 'Validation LV2 obligatoire...', icon: 'âœ…' },
        { label: 'CrÃ©ation onglets FIN...', icon: 'ğŸ“‘' },
        { label: 'Formatage automatique...', icon: 'âœ¨' },
        { label: 'Finalisation...', icon: 'ğŸ‰' }
      ];

      UIComponents.LoadingOverlay.show('CrÃ©ation des onglets FIN...', steps);

      try {
        // Ã‰tape 1 : PrÃ©paration
        UIComponents.LoadingOverlay.setStep(0);
        await new Promise(resolve => setTimeout(resolve, 500));

        const disposition = exportDisposition();
        if (Object.keys(disposition).length === 0) {
          throw new Error('Aucune classe Ã  sauvegarder');
        }

        // Ã‰tape 2 : Validation LV2
        UIComponents.LoadingOverlay.setStep(1);
        await new Promise(resolve => setTimeout(resolve, 300));

        // Ã‰tape 3 : CrÃ©ation des onglets FIN
        UIComponents.LoadingOverlay.setStep(2);

        // Sauvegarder depuis le mode actuellement actif (sources/test/def/CACHE)
        const result = await gsRun('saveElevesSnapshot', disposition, STATE.currentMode);
        if (!result?.success) {
          throw new Error(result?.error || 'Erreur serveur');
        }

        // Ã‰tape 4 : Formatage automatique
        UIComponents.LoadingOverlay.setStep(3);
        await new Promise(resolve => setTimeout(resolve, 300));

        // Ã‰tape 5 : Finalisation
        UIComponents.LoadingOverlay.setStep(4);
        await new Promise(resolve => setTimeout(resolve, 300));

        UIComponents.LoadingOverlay.hide();
        toast(`Onglets INT crÃ©Ã©s et formatÃ©s avec succÃ¨s pour ${Object.keys(disposition).length} classes`, 'success');

      } catch (error) {
        console.error('Erreur crÃ©ation onglets FIN:', error);
        UIComponents.LoadingOverlay.hide();
        toast('Erreur: ' + error.message, 'error');
      }
    }

    async function _saveInternal() {
      try {
        const disposition = exportDisposition();
        if (Object.keys(disposition).length === 0) throw new Error('Aucune classe Ã  sauvegarder');
        const result = await gsRun('saveElevesSnapshot', disposition, STATE.currentMode);
        if (!result?.success) throw new Error(result?.error || 'Erreur serveur');
        toast(`Onglets INT crÃ©Ã©s avec succÃ¨s`, 'success');
      } catch (error) {
        console.error(error);
        toast('Erreur: ' + error.message, 'error');
      }
    }

    // ========== ANCIENNES FONCTIONS MIGRÃ‰ES VERS App.* ==========
    // Les fonctions suivantes ont Ã©tÃ© dÃ©placÃ©es vers l'architecture modulaire :
    // - toast() -> App.UI.toast()
    // - adjustSimpleNamesFontSize() -> App.UI.adjustSimpleNamesFontSize()
    // - isRealClass() -> App.Utils.isRealClass()
    // - updateColumnStats() -> App.UI.updateColumnStats()
    // - updateAllColumnStats() -> App.UI.updateAllColumnStats()
    // - updateAdvancedStats() -> App.Stats.updateAdvancedStats()
    // - exportDisposition() -> App.Data.exportDisposition()
    // - saveImmediateCache() -> App.Data.saveImmediateCache()
    // - updateUndoRedoButtons() -> App.History.updateUndoRedoButtons()
    //
    // Des wrappers globaux sont disponibles pour compatibilitÃ© (voir section WRAPPERS ci-dessous)
    // undo() et redo() migrÃ©s vers App.History

    // ========== APPELS GOOGLE APPS SCRIPT ==========
    function gsRun(fnName, ...args) {
      return new Promise((resolve, reject) => {
        console.log(`ğŸ“¡ Appel fonction: ${fnName}`);

        try {
          // VÃ©rifier si on est dans l'environnement Google Apps Script
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            const api = google.script.run;

            if (typeof api[fnName] === 'function') {
              // Appel correct : d'abord les handlers, puis la fonction
              api
                .withSuccessHandler((result) => {
                  resolve(result);
                })
                .withFailureHandler((error) => {
                  console.error(`âŒ ${fnName} erreur:`, error);
                  reject(error);
                })[fnName](...args);
              return;
            }
            // âœ… Fonction non disponible
            reject(new Error(`Fonction ${fnName} non disponible dans google.script.run`));
            return;
          }

          // âœ… Google Apps Script non disponible
          reject(new Error('Google Apps Script non disponible. Assurez-vous que l\'application est dÃ©ployÃ©e.'));

        } catch (error) {
          console.error(`ğŸ’¥ Erreur dans gsRun:`, error);
          reject(error);
        }
      });
    }

    // ========== FONCTION AFFICHAGE D'ERREUR UNIVERSELLE ==========
    function showErrorState(message, suggestions = []) {
      const board = document.getElementById('board');
      if (!board) {
        console.error('Ã‰lÃ©ment #board introuvable');
        return;
      }

      const defaultSuggestions = [
        'VÃ©rifiez que vos onglets se terminent par "TEST" (ex: 4Â°1TEST, 4Â°2TEST...)',
        'Assurez-vous que vos onglets contiennent des donnÃ©es avec au moins les colonnes ID et NOM',
        'CrÃ©ez un onglet "_STRUCTURE" avec les rÃ¨gles de rÃ©partition',
        'VÃ©rifiez la configuration de votre Google Sheet'
      ];

      const allSuggestions = suggestions.length > 0 ? suggestions : defaultSuggestions;

      board.innerHTML = `
    <div class="col-span-full">
      <div class="error-container">
        <div class="error-icon">
          <i class="fas fa-exclamation-triangle"></i>
        </div>
        <h2 class="error-title">Aucune donnÃ©e trouvÃ©e</h2>
        <div class="error-message">
          ${message}
        </div>
        <div class="error-suggestions">
          <h3 class="font-semibold mb-2">Suggestions pour rÃ©soudre le problÃ¨me :</h3>
          <ul>
            ${allSuggestions.map(s => `<li>${s}</li>`).join('')}
          </ul>
        </div>
        <div class="mt-4">
          <button onclick="attemptRefresh()" class="btn btn-primary">
            <i class="fas fa-sync"></i> RÃ©essayer
          </button>
          <button onclick="createDemoStructure()" class="btn btn-secondary ml-3">
            <i class="fas fa-plus"></i> CrÃ©er structure exemple
          </button>
        </div>
      </div>
    </div>
  `;
    }

    // ========== DÃ‰TECTION AUTOMATIQUE DU NIVEAU ==========
    function detectNiveau(data) {
      if (!data || data.length === 0) return '';

      // Analyser les noms de classes pour dÃ©tecter le niveau
      const classes = data.map(group => group.classe);
      const niveaux = new Set();

      classes.forEach(classe => {
        const match = classe.match(/^(\dÂ°)/);
        if (match) {
          niveaux.add(match[1]);
        }
      });

      if (niveaux.size === 1) {
        return Array.from(niveaux)[0];
      } else if (niveaux.size > 1) {
        return `Multi-niveaux (${Array.from(niveaux).join(', ')})`;
      }

      return 'Niveau non dÃ©tectÃ©';
    }

    // ========== FONCTION DE TRI DES COLONNES ==========
    function sortColumn(classe, sortType, direction = 'asc') {
      const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!dropZone) return;

      const cards = Array.from(dropZone.querySelectorAll('.student-card'));
      const students = cards.map(card => ({
        card,
        data: STATE.students[card.dataset.id]
      }));

      // facteur : +1 en asc, -1 en desc
      const f = direction === 'asc' ? 1 : -1;

      switch (sortType) {
        /* --- NOM ------------------------------------------------------- */
        case 'name':
          students.sort((a, b) => f * a.data.nom.localeCompare(b.data.nom));
          break;

        /* --- LV2 ------------------------------------------------------- */
        case 'lv2':
          students.sort((a, b) => {
            const ordre = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
            const iA = ordre.indexOf((a.data.lv2 || '').toUpperCase());
            const iB = ordre.indexOf((b.data.lv2 || '').toUpperCase());
            return f * ((iA === -1 ? 999 : iA) - (iB === -1 ? 999 : iB));
          });
          break;

        /* --- OPTION ---------------------------------------------------- */
        case 'option':
          students.sort((a, b) => {
            if (!a.data.opt && !b.data.opt) return 0;
            if (!a.data.opt) return f;   // Â« sans option Â» en bas quand asc
            if (!b.data.opt) return -f;
            return f * a.data.opt.localeCompare(b.data.opt);
          });
          break;

        /* --- SCORE COM ---------------------------------------------- */
        case 'score':
          students.sort((a, b) => {
            // Tri par score COM : meilleurs (4=Vert) en haut au premier clic
            const scoreA = a.data.scores.COM || 0;
            const scoreB = b.data.scores.COM || 0;
            return -f * (scoreB - scoreA); // meilleurs en haut en asc
          });
          break;
      }

      /* rÃ©-injection dans le DOM */
      dropZone.innerHTML = '';
      students.forEach(({ card }) => dropZone.appendChild(card));

      /* mÃ©morise le dernier tri */
      STATE.sortOrder[classe] = { type: sortType, dir: direction };
    }

    // ========== FONCTION DE VALIDATION DES MOUVEMENTS ==========
    function canMove(eleveId, srcClasse, dstClasse) {
      if (STATE.adminMode || srcClasse === dstClasse) return { ok: true };

      const e = STATE.students[eleveId];
      const dr = STATE.rules[dstClasse] || {};
      const dc = getCurrentClassContent(dstClasse);

      /* ğŸ”’ FIXE : jamais de dÃ©placement */
      if (e.mobilite === 'FIXE')
        return { ok: false, reason: `${e.nom} est FIXE dans sa classe` };

      /* ğŸ”’ CONDI : jamais de dÃ©placement individuel (conditionnÃ© par le groupe) */
      if (e.mobilite === 'CONDI')
        return { ok: false, reason: `${e.nom} est CONDI (groupe A${e.asso}) - utilisez le mode Admin` };

      /* ğŸ”’ PERMUT : BLOQUÃ‰ EN DRAG&DROP NORMAL */
      if (e.mobilite === 'PERMUT')
        return { ok: false, reason: `${e.nom} est PERMUT - utilisez le mode SWAP` };

      /* ğŸ”’ SPEC : mÃªme rÃ¨gle que FIXE  (option prioritaire) */
      if (e.mobilite === 'SPEC')
        return { ok: false, reason: `${e.nom} est SPEC (option obligatoire)` };

      /* ğŸ”’ DISSOCIATION : VÃ©rifier si code D dÃ©jÃ  prÃ©sent dans la classe cible */
      if (e.disso) {
        // VÃ©rifier si un autre Ã©lÃ¨ve avec le mÃªme code D est dÃ©jÃ  dans la classe cible
        const dissoDejaPresent = dc.some(id => {
          const s = STATE.students[id];
          return s && s.disso === e.disso;
        });

        if (dissoDejaPresent) {
          return { ok: false, reason: `Code D${e.disso} dÃ©jÃ  prÃ©sent dans ${dstClasse} - utilisez le mode SWAP` };
        }
        // Sinon, autoriser le dÃ©placement (pas de conflit)
      }

      /* CAPACITÃ‰ : on avertit mais on autorise */
      if (dr.capacity && dc.length >= dr.capacity) {
        return {
          ok: true,
          warn: `${dstClasse} dÃ©passe sa capacitÃ© (${dr.capacity})`
        };
      }

      /* ASSOCIATION */
      if (e.asso) {
        const grp = STATE.aGroups[`A${e.asso}`] || [];
        const encSrc = grp.filter(id => id !== eleveId)
          .some(id => document.querySelector(`.student-card[data-id="${id}"]`)
            ?.closest('.droppable-zone').dataset.classe === srcClasse);
        if (encSrc)
          return { ok: false, reason: `Groupe A${e.asso} doit bouger ensemble (mode Swap ou Admin)` };
      }

      /* VÃ‰RIFIER LV2 et OPTIONS */
      const checkTag = (tag, label) => {
        const tagUp = String(tag || '').trim().toUpperCase();
        if (!tagUp) return true;

        /* LV2 ESP autorisÃ© partout */
        if (label === 'LV2' && tagUp === 'ESP') return true;

        /* Aucune rÃ¨gle pour la classe âœ tout interdit */
        if (!dr.quotas || Object.keys(dr.quotas).length === 0) {
          return { ok: false, reason: `${label} ${tagUp} interdit dans ${dstClasse} (aucun quota dÃ©fini)` };
        }

        /* Tag absent dans les quotas âœ interdit */
        if (!(tagUp in dr.quotas)) {
          return { ok: false, reason: `${label} ${tagUp} interdit dans ${dstClasse}` };
        }

        /* Quota Ã  0 âœ interdit */
        if (dr.quotas[tagUp] === 0) {
          return { ok: false, reason: `${label} ${tagUp} interdit dans ${dstClasse} (quota 0)` };
        }

        /* Ã‰lÃ¨ves dÃ©jÃ  prÃ©sents avec ce tag */
        const currentCnt = dc.filter(id => {
          const s = STATE.students[id];
          return s && (String(s.lv2).toUpperCase() === tagUp ||
            String(s.opt).toUpperCase() === tagUp);
        }).length;

        if (currentCnt >= dr.quotas[tagUp]) {
          return { ok: false, reason: `Quota ${tagUp} atteint (${dr.quotas[tagUp]})` };
        }

        return true;
      };

      const r1 = checkTag(e.lv2, 'LV2');
      if (r1 !== true) return r1;
      console.log(eleveId, e.opt)
      const r2 = checkTag(e.opt, 'Option');
      if (r2 !== true) return r2;

      return { ok: true };
    }

    // ========== FONCTION UTILITAIRE POUR RÃ‰CUPÃ‰RER LE CONTENU D'UNE CLASSE ==========
    function getCurrentClassContent(classe) {
      const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!dropZone) return [];

      return Array.from(dropZone.querySelectorAll('.student-card'))
        .map(card => card.dataset.id);
    }

    // ========== FONCTIONS DE GESTION DES SWAPS ==========
    function canSwap(id1, id2) {
      const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
      const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);

      if (!card1 || !card2) return { ok: false, reason: 'Ã‰lÃ¨ve introuvable' };

      const classe1 = card1.closest('.droppable-zone').dataset.classe;
      const classe2 = card2.closest('.droppable-zone').dataset.classe;

      if (classe1 === classe2) return { ok: false, reason: 'MÃªme classe' };

      const eleve1 = STATE.students[id1];
      const eleve2 = STATE.students[id2];

      // Mode admin : tout est permis
      if (STATE.adminMode) return { ok: true };

      // âœ… PRIORITÃ‰ 1 : SWAP DE MÃŠME CONTRAINTE
      // Si les deux Ã©lÃ¨ves ont les mÃªmes contraintes (LV2, OPT, code D), le swap est autorisÃ©
      // Car cela ne change pas les quotas : on Ã©change juste deux Ã©lÃ¨ves identiques

      const lv2_1 = (eleve1.lv2 || '').toUpperCase();
      const lv2_2 = (eleve2.lv2 || '').toUpperCase();
      const opt_1 = (eleve1.opt || '').toUpperCase();
      const opt_2 = (eleve2.opt || '').toUpperCase();

      // ğŸ”’ CORRECTION BUG PERMUT/DISSO : VÃ©rifier que le swap ne crÃ©era pas de conflit DISSO
      // Les codes DISSO doivent Ãªtre SÃ‰PARÃ‰S (pas dans la mÃªme classe)
      const disso1 = (eleve1.disso || '').trim().toUpperCase();
      const disso2 = (eleve2.disso || '').trim().toUpperCase();

      // Si eleve1 a un code DISSO, vÃ©rifier que classe2 (sa future classe) ne contient pas dÃ©jÃ  ce code
      if (disso1) {
        const studentsInClasse2 = getCurrentClassContent(classe2);
        for (const studentId of studentsInClasse2) {
          if (studentId === id2) continue; // Ignorer eleve2 qui va quitter cette classe
          const otherStudent = STATE.students[studentId];
          if (!otherStudent) continue;
          const otherDisso = (otherStudent.disso || '').trim().toUpperCase();
          if (otherDisso === disso1) {
            return { ok: false, reason: `Conflit DISSO : ${classe2} contient dÃ©jÃ  un Ã©lÃ¨ve avec code ${disso1}` };
          }
        }
      }

      // Si eleve2 a un code DISSO, vÃ©rifier que classe1 (sa future classe) ne contient pas dÃ©jÃ  ce code
      if (disso2) {
        const studentsInClasse1 = getCurrentClassContent(classe1);
        for (const studentId of studentsInClasse1) {
          if (studentId === id1) continue; // Ignorer eleve1 qui va quitter cette classe
          const otherStudent = STATE.students[studentId];
          if (!otherStudent) continue;
          const otherDisso = (otherStudent.disso || '').trim().toUpperCase();
          if (otherDisso === disso2) {
            return { ok: false, reason: `Conflit DISSO : ${classe1} contient dÃ©jÃ  un Ã©lÃ¨ve avec code ${disso2}` };
          }
        }
      }

      // Cas 2 : MÃªme LV2 ET mÃªme OPT (ou pas d'OPT)
      const memeLV2 = lv2_1 === lv2_2 || (lv2_1 === 'ESP' && lv2_2 === 'ESP') || (!lv2_1 && !lv2_2);
      const memeOPT = opt_1 === opt_2 || (!opt_1 && !opt_2);

      if (memeLV2 && memeOPT) {
        return { ok: true };
      }

      // Si pas de mÃªmes contraintes, vÃ©rifier les mobilitÃ©s

      // FIXE et SPEC : jamais dÃ©plaÃ§ables en mode Swap (seulement en mode Force)
      if (eleve1.mobilite === 'FIXE' || eleve2.mobilite === 'FIXE') {
        return { ok: false, reason: 'FIXE ne peut pas bouger (utilisez le mode Force)' };
      }

      if (eleve1.mobilite === 'SPEC' || eleve2.mobilite === 'SPEC') {
        return { ok: false, reason: 'SPEC ne peut pas bouger (utilisez le mode Force)' };
      }

      // CONDI : jamais dÃ©plaÃ§ables (conditionnÃ©s par le groupe)
      if (eleve1.mobilite === 'CONDI' || eleve2.mobilite === 'CONDI') {
        return { ok: false, reason: 'CONDI ne peut pas bouger (groupe ASSO)' };
      }

      // PERMUT : vÃ©rifier compatibilitÃ©
      if (eleve1.mobilite === 'PERMUT' && eleve2.mobilite === 'PERMUT') {
        const lv1 = (eleve1.lv2 || '').toUpperCase();
        const lv2 = (eleve2.lv2 || '').toUpperCase();

        // âœ… La vÃ©rification DISSO a dÃ©jÃ  Ã©tÃ© effectuÃ©e ci-dessus (lignes 559-590)
        // Pas besoin de la refaire ici

        if (lv1 === 'ESP' || lv2 === 'ESP') {
          return { ok: true };
        }

        if (lv1 !== lv2) {
          return { ok: false, reason: `PERMUT : LV2 diffÃ©rentes` };
        }

        return { ok: true };
      }

      if (eleve1.mobilite === 'PERMUT' || eleve2.mobilite === 'PERMUT') {
        return { ok: false, reason: 'PERMUT ne peut Ã©changer qu\'avec un autre PERMUT' };
      }

      // VÃ©rifier codes D diffÃ©rents (un seul a un code D)
      if (eleve1.disso || eleve2.disso) {
        if (eleve1.disso) {
          // VÃ©rifier si D1 serait dans la mÃªme classe qu'un autre D1 aprÃ¨s le swap
          const dejaPresent = getCurrentClassContent(classe2).some(id => {
            const s = STATE.students[id];
            return s && s.disso === eleve1.disso && id !== id2;
          });

          if (dejaPresent) {
            return { ok: false, reason: `Code D${eleve1.disso} dÃ©jÃ  prÃ©sent dans ${classe2}` };
          }
        }

        if (eleve2.disso) {
          // VÃ©rifier si D2 serait dans la mÃªme classe qu'un autre D2 aprÃ¨s le swap
          const dejaPresent = getCurrentClassContent(classe1).some(id => {
            const s = STATE.students[id];
            return s && s.disso === eleve2.disso && id !== id1;
          });

          if (dejaPresent) {
            return { ok: false, reason: `Code D${eleve2.disso} dÃ©jÃ  prÃ©sent dans ${classe1}` };
          }
        }
      }

      // VÃ©rifier les quotas LV2 et OPT
      const dr1 = STATE.rules[classe2] || {};
      const dr2 = STATE.rules[classe1] || {};

      // VÃ©rifier LV2 de eleve1 dans classe2
      if (eleve1.lv2 && eleve1.lv2.toUpperCase() !== 'ESP') {
        const lv2Upper = eleve1.lv2.toUpperCase();
        if (!dr1.quotas || dr1.quotas[lv2Upper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve1.nom} (${lv2Upper}) interdit dans ${classe2}`);
          return { ok: false, reason: `${lv2Upper} interdit dans ${classe2}` };
        }
      }

      // VÃ©rifier LV2 de eleve2 dans classe1
      if (eleve2.lv2 && eleve2.lv2.toUpperCase() !== 'ESP') {
        const lv2Upper = eleve2.lv2.toUpperCase();
        if (!dr2.quotas || dr2.quotas[lv2Upper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve2.nom} (${lv2Upper}) interdit dans ${classe1}`);
          return { ok: false, reason: `${lv2Upper} interdit dans ${classe1}` };
        }
      }

      // VÃ©rifier OPT de eleve1 dans classe2
      if (eleve1.opt && eleve1.opt.trim()) {
        const optUpper = eleve1.opt.toUpperCase();
        if (!dr1.quotas || dr1.quotas[optUpper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve1.nom} (OPT ${optUpper}) interdit dans ${classe2}`);
          return { ok: false, reason: `Option ${optUpper} interdite dans ${classe2}` };
        }
      }

      // VÃ©rifier OPT de eleve2 dans classe1
      if (eleve2.opt && eleve2.opt.trim()) {
        const optUpper = eleve2.opt.toUpperCase();
        if (!dr2.quotas || dr2.quotas[optUpper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve2.nom} (OPT ${optUpper}) interdit dans ${classe1}`);
          return { ok: false, reason: `Option ${optUpper} interdite dans ${classe1}` };
        }
      }

      return { ok: true };
    }

    function performSwap(id1, id2) {
      const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
      const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);

      if (!card1 || !card2) return;

      const zone1 = card1.closest('.droppable-zone');
      const zone2 = card2.closest('.droppable-zone');

      if (!zone1 || !zone2) return;

      // Animation de swap
      card1.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      card2.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';

      // Ã‰changer les cartes
      zone2.appendChild(card1);
      zone1.appendChild(card2);

      // Marquer qu'il y a eu une action utilisateur
      if (typeof markUserAction === 'function') {
        markUserAction();
      } else {
        STATE.has_user_action = true;
      }

      // Historique
      const swapAction = {
        type: 'swap',
        id1, id2,
        eleve1Name: STATE.students[id1]?.nom || 'Ã‰lÃ¨ve 1',
        eleve2Name: STATE.students[id2]?.nom || 'Ã‰lÃ¨ve 2',
        classe1: zone1.dataset.classe,
        classe2: zone2.dataset.classe,
        timestamp: new Date().toISOString()
      };
      STATE.history.push(swapAction);
      STATE.historyTimeline.push(swapAction);
      STATE.future = [];
      updateUndoRedoButtons();

      // Mettre Ã  jour le panneau historique
      updateHistoryPanel();

      // âœ… UNE SEULE mise Ã  jour des colonnes
      updateAllColumnStats();

      // âœ… UNE SEULE mise Ã  jour des stats avancÃ©es avec dÃ©lai
      setTimeout(() => updateAdvancedStats(), 150);

      // Feedback temps rÃ©el
      if (window.RealTimeFeedback) {
        window.RealTimeFeedback.updateMetrics();
      }

      // Sauvegarde
      if (STATE.currentMode === 'CACHE') {
        setTimeout(() => saveImmediateCache(), 200);
      }

      const eleve1 = STATE.students[id1];
      const eleve2 = STATE.students[id2];
      toast(`Swap rÃ©ussi entre ${eleve1.nom} et ${eleve2.nom}`, 'success');
    }

    function handleCardClick(e) {
      if (!STATE.swapMode) return;

      const card = e.currentTarget;
      const eleveId = card.dataset.id;
      const eleve = STATE.students[eleveId];

      // PremiÃ¨re sÃ©lection
      if (!STATE.swapFirst) {
        STATE.swapFirst = eleveId;
        card.classList.add('swap-mode');

        let msg = `${eleve.nom} sÃ©lectionnÃ©`;
        if (eleve.mobilite === 'PERMUT') msg += ' (PERMUT)';
        else if (eleve.disso) msg += ` (D${eleve.disso})`;
        msg += ' â€“ choisissez un Ã©lÃ¨ve Ã  Ã©changer';
        toast(msg, 'info');

        // Mettre en Ã©vidence les autres colonnes
        document.querySelectorAll('.droppable-zone').forEach(zone => {
          if (zone.dataset.classe !== card.closest('.droppable-zone').dataset.classe) {
            zone.classList.add('swap-target');
          }
        });
        return;
      }

      // DeuxiÃ¨me sÃ©lection
      const firstId = STATE.swapFirst;
      const firstCard = document.querySelector(`.student-card[data-id="${firstId}"]`);

      // MÃªme Ã©lÃ¨ve : annuler
      if (eleveId === firstId) {
        firstCard.classList.remove('swap-mode');
        document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
        STATE.swapFirst = null;
        return;
      }

      // VÃ©rifier et effectuer le swap
      const check = canSwap(firstId, eleveId);
      if (check.ok) {
        performSwap(firstId, eleveId);
      } else {
        toast(check.reason, 'error');
      }

      // Nettoyer l'Ã©tat
      firstCard.classList.remove('swap-mode');
      document.querySelectorAll('.student-card').forEach(c => c.classList.remove('swap-mode'));
      document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
      STATE.swapFirst = null;
    }

    // ========== SIMPLIFICATION DES NOMS COMPOSÃ‰S ==========

    function simplifierNomComplet(nom, prenom) {
      if (!nom && !prenom) return '';

      nom = (nom || '').trim().replace(/\s+/g, ' ');
      prenom = (prenom || '').trim().replace(/\s+/g, ' ');

      let finalNom = '';
      let finalPrenom = '';

      if (prenom) {
        finalNom = nom.split(/[\s-]+/).filter(Boolean)[0] || nom;
        finalPrenom = prenom.split(/[\s-]+/).filter(Boolean)[0] || prenom;
      } else if (nom) {
        const parts = nom.split(/\s+/).filter(Boolean);
        finalNom = parts[0];
        finalPrenom = parts.length >= 2 ? parts[parts.length - 1] : '';
      }

      let resultat = `${finalNom} ${finalPrenom}`.trim();

      const MAX_LENGTH = 25;
      if (resultat.length > MAX_LENGTH) {
        const availableForPrenom = MAX_LENGTH - finalNom.length - 1;
        if (availableForPrenom > 0) {
          resultat = `${finalNom} ${finalPrenom.substring(0, availableForPrenom - 1)}.`.trim();
        } else {
          resultat = finalNom.substring(0, MAX_LENGTH - 1) + '.';
        }
      }

      return resultat;
    }

    window.simplifierNomComplet = simplifierNomComplet;

    // ========== PHASE 3: FONCTIONS UTILITAIRES (DRY) ==========

    /**
     * Phase 3.1: CrÃ©e un badge standardisÃ© pour Ã©viter la duplication de code
     * @param {string} type - Type de badge ('lv2', 'opt', 'asso', 'disso', 'mobilite', 'dispo', 'gender')
     * @param {string} content - Contenu textuel du badge
     * @param {Object} options - Options {title, compact, className}
     * @returns {HTMLElement} Badge crÃ©Ã©
     */
    function createBadge(type, content, options = {}) {
      const badge = document.createElement('span');
      const { title = '', compact = false, className = '' } = options;

      // Configuration par type
      const configs = {
        lv2: {
          baseClass: 'mini-badge',
          extraClass: `badge-${content.toUpperCase()}`,
          displayContent: content.toUpperCase(),
          defaultTitle: `LV2: ${content}`
        },
        opt: {
          baseClass: 'mini-badge',
          extraClass: `badge-${content.toUpperCase()}`,
          displayContent: content.toUpperCase(),
          defaultTitle: `Option: ${content}`
        },
        disso: {
          baseClass: 'mini-badge badge-disso',
          displayContent: content.replace(/^D/i, 'D'),
          defaultTitle: `Dissociation: ${content}`
        },
        asso: {
          baseClass: 'mini-badge badge-asso',
          displayContent: content.replace(/^A/i, 'A'),
          defaultTitle: `Association: ${content}`
        },
        mobilite: {
          baseClass: 'mini-badge badge-mobilite',
          extraClass: compact ? 'badge-compact' : '',
          displayContent: content,
          defaultTitle: `MobilitÃ©: ${content}`
        },
        dispo: {
          baseClass: 'badge-dispo',
          displayContent: content.toUpperCase().trim(),
          defaultTitle: `Dispositif: ${content}`
        },
        gender: {
          baseClass: 'badge-sexe',
          extraClass: `sexe-${content}`,
          displayContent: content === 'F' ? 'â™€' : 'â™‚',
          defaultTitle: ''
        }
      };

      const config = configs[type];
      if (!config) {
        console.error(`Unknown badge type: ${type}`);
        return badge;
      }

      // Construire className
      const classes = [config.baseClass, config.extraClass, className].filter(Boolean).join(' ');
      badge.className = classes;
      badge.textContent = config.displayContent;
      badge.title = title || config.defaultTitle;

      return badge;
    }

    /**
     * Phase 3.2: Compte les Ã©lÃ¨ves par sexe (F/M)
     * @param {Array} eleves - Liste d'Ã©lÃ¨ves
     * @returns {Object} {total, F, M}
     */
    function countBySex(eleves) {
      const F = eleves.filter(e => e.sexe === 'F').length;
      const M = eleves.filter(e => e.sexe === 'M').length;
      return { total: eleves.length, F, M };
    }

    /**
     * Phase 3.3: VÃ©rifie si un Ã©lÃ¨ve peut Ãªtre placÃ© dans une classe sans conflit DISSO
     * @param {string} eleveId - ID de l'Ã©lÃ¨ve Ã  placer
     * @param {string} targetClass - Classe cible
     * @param {Object} allEleves - Tous les Ã©lÃ¨ves (STATE.students)
     * @returns {boolean} true si conflit DISSO dÃ©tectÃ©
     */
    function checkDissoConflict(eleveId, targetClass, allEleves) {
      const eleve = allEleves[eleveId];
      if (!eleve || !eleve.disso) return false;

      const targetZone = document.querySelector(`[data-classe="${targetClass}"] .droppable-zone`);
      if (!targetZone) return false;

      const classStudents = Array.from(targetZone.querySelectorAll('.student-card'))
        .map(c => allEleves[c.dataset.id])
        .filter(Boolean);

      return classStudents.some(s => s.disso === eleve.disso);
    }

    /**
     * Phase 3.4: Met Ã  jour les statistiques de toutes les classes
     */
    function updateAllStats() {
      document.querySelectorAll('.class-column').forEach(column => {
        const zone = column.querySelector('.droppable-zone');
        if (!zone) return;

        const eleves = Array.from(zone.querySelectorAll('.student-card'))
          .map(c => STATE.students[c.dataset.id])
          .filter(Boolean);

        const counts = countBySex(eleves);
        column.querySelector('.count').textContent = counts.total;
        column.querySelector('.count-f').textContent = counts.F;
        column.querySelector('.count-m').textContent = counts.M;
      });
    }

    // ========== FONCTION DE CRÃ‰ATION DES CARTES Ã‰LÃˆVES ==========
    function createStudentCard(eleve) {
      /* --- STOP "CARTE VIDE" : on ignore les enregistrements sans id --- */
      if (!eleve || !eleve.id || !eleve.id.trim()) return null;
      /* ---------------------------------------------------------------- */

      const template = document.querySelector('#tpl-carte-eleve');
      const card = template.content.cloneNode(true).children[0];

      card.dataset.id = eleve.id;
      card.classList.add(`sexe-${eleve.sexe}`);

      // Attributs ARIA pour la carte Ã©lÃ¨ve
      const nomCompletAria = eleve.prenom ? `${eleve.nom} ${eleve.prenom}` : eleve.nom;
      card.setAttribute('role', 'listitem');
      card.setAttribute('aria-label', nomCompletAria);
      card.setAttribute('aria-grabbed', 'false');

      // ========== MODE SIMPLE : FOND BLANC + POLICE COULEUR SEXE + SOULIGNE ROUGE SI COM=1 ==========
      if (STATE.viewMode === 'simple') {
        card.classList.add('simple-mode');
        card.innerHTML = `<div class="simple-line">
      <span class="student-simple-name"></span>
    </div>`;
        const simpleLine = card.querySelector('.simple-line');
        const nameEl = card.querySelector('.student-simple-name');

        // Gender badge using createBadge()
        if (document.body.classList.contains('gender-badges')) {
          simpleLine.insertBefore(createBadge('gender', eleve.sexe), nameEl);
        }

        // Nom complet simplifiÃ©
        let nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);

        // Couleur de police selon sexe
        let couleurTexte = '#333'; // Gris foncÃ© par dÃ©faut
        if (eleve.sexe === 'F') {
          couleurTexte = '#ec4899'; // Rose pour F
        } else if (eleve.sexe === 'M') {
          couleurTexte = '#3b82f6'; // Bleu pour M
        }

        // SoulignÃ© rouge si score COM = 1
        let soulignement = 'none';
        let couleurSoulignement = '';
        if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
          soulignement = 'underline';
          couleurSoulignement = '#FF0000'; // Rouge
        }

        // Appliquer les styles
        nameEl.textContent = nomComplet;
        nameEl.style.display = 'block';
        nameEl.style.textAlign = 'center';
        nameEl.style.fontSize = '1.1rem';
        nameEl.style.fontWeight = '600';
        nameEl.style.padding = '8px';
        nameEl.style.color = couleurTexte;
        nameEl.style.textDecoration = soulignement;
        nameEl.style.overflow = 'hidden';
        nameEl.style.textOverflow = 'ellipsis';
        nameEl.style.whiteSpace = 'nowrap';
        nameEl.style.maxWidth = '100%';
        if (soulignement === 'underline') {
          nameEl.style.textDecorationColor = couleurSoulignement;
          nameEl.style.textDecorationThickness = '3px';
          nameEl.style.textUnderlineOffset = '3px';
        }

        card.style.background = '#fff'; // Fond blanc pour tous
        card.style.border = '1px solid rgba(0,0,0,0.1)';
        card.style.borderRadius = '6px';
      } else if (STATE.viewMode === 'essential') {
        // Mode essentiel : nom + badges essentiels (pas d'options ni scores)
        const fullNameElement = card.querySelector('.student-fullname');
        const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);
        fullNameElement.textContent = nomComplet;

        // Gender badge using createBadge()
        if (document.body.classList.contains('gender-badges')) {
          fullNameElement.parentNode.insertBefore(createBadge('gender', eleve.sexe), fullNameElement);
        }

        // NOM EN ROUGE si score COM = 1
        if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
          fullNameElement.style.color = '#FF0000';
          fullNameElement.style.fontWeight = '700';
        }

        // Badges essentiels : LV2, OPT, DISSO, ASSO (PAS DE DISPO)
        const allBadgesContainer = card.querySelector('.all-badges');
        allBadgesContainer.style.justifyContent = 'center';

        let totalBadges = 0;
        if (eleve.mobilite && eleve.mobilite !== 'LIBRE') totalBadges++;
        if (eleve.disso) totalBadges++;
        if (eleve.asso) totalBadges++;
        if (eleve.lv2) totalBadges++;
        const compactMode = totalBadges > 3;

        // Badge MobilitÃ© (using createBadge)
        if (eleve.mobilite && eleve.mobilite !== 'LIBRE') {
          let mobText = eleve.mobilite;
          if (compactMode) {
            const abrevMap = { 'CONDI': 'CO', 'FIXE': 'FI', 'PERMUT': 'PER', 'SPEC': 'SP' };
            mobText = abrevMap[eleve.mobilite] || eleve.mobilite;
          }
          allBadgesContainer.appendChild(createBadge('mobilite', mobText, { compact: compactMode }));
        }

        // Badge Dissociation (using createBadge)
        if (eleve.disso) {
          allBadgesContainer.appendChild(createBadge('disso', eleve.disso));
        }

        // Badge Association (using createBadge)
        if (eleve.asso) {
          allBadgesContainer.appendChild(createBadge('asso', eleve.asso));
        }

        // Badge LV2 (using createBadge)
        if (eleve.lv2 && eleve.lv2.trim()) {
          allBadgesContainer.appendChild(createBadge('lv2', eleve.lv2));
        }

        // Badge OPT (using createBadge)
        if (eleve.opt && eleve.opt.trim()) {
          allBadgesContainer.appendChild(createBadge('opt', eleve.opt));
        }

        // Source uniquement (pas de scores)
        card.querySelector('.source-class').textContent = eleve.source || '';
        card.querySelector('.scores').innerHTML = '';
      } else {
        // ========== MODE COMPLETE: NOM + LV2/OPT + BADGES SCORES ==========
        const fullNameElement = card.querySelector('.student-fullname');
        const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);

        // Gender badge using createBadge()
        if (document.body.classList.contains('gender-badges')) {
          fullNameElement.parentNode.insertBefore(createBadge('gender', eleve.sexe), fullNameElement);
        }

        fullNameElement.textContent = nomComplet;
        fullNameElement.className = 'student-fullname'; // Reset class in case it was modified

        // NOM EN ROUGE si score COM = 1
        if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
          fullNameElement.style.color = '#FF0000';
          fullNameElement.style.fontWeight = '700';
        }

        // Badge DISPO (using createBadge)
        const dispoContainer = card.querySelector('.badge-dispo-container');
        if (eleve.dispo && eleve.dispo.trim()) {
          dispoContainer.appendChild(createBadge('dispo', eleve.dispo));
        }

        // ========== LIGNE 2: TOUS LES BADGES (LV2, OPT, DISSO, ASSO) ==========
        const allBadgesContainer = card.querySelector('.all-badges');
        allBadgesContainer.style.justifyContent = 'center';

        // Badges using createBadge()
        if (eleve.lv2 && eleve.lv2.trim()) {
          allBadgesContainer.appendChild(createBadge('lv2', eleve.lv2));
        }

        if (eleve.opt && eleve.opt.trim()) {
          allBadgesContainer.appendChild(createBadge('opt', eleve.opt));
        }

        if (eleve.disso) {
          allBadgesContainer.appendChild(createBadge('disso', eleve.disso));
        }

        if (eleve.asso) {
          allBadgesContainer.appendChild(createBadge('asso', eleve.asso));
        }

        // ========== LIGNE 3: Source + Scores ==========
        card.querySelector('.source-class').textContent = eleve.source || '';

        // Badges scores COM/TRA/PART/ABS avec lettres et couleurs OU micro-jauges
        const scoresContainer = card.querySelector('.scores');

        // Mode Jauges Visuelles (Nouveau de la Phase 6 UX/UI)
        if (document.body.classList.contains('show-micro-charts')) {
          scoresContainer.className = 'scores-charts-container flex flex-col gap-1 mt-1 w-full px-1';

          const scoreConfig = [
            { key: 'COM', label: 'Com', colorClass: 'bg-indigo-500' },
            { key: 'TRA', label: 'Tra', colorClass: 'bg-cyan-500' },
            { key: 'PART', label: 'Par', colorClass: 'bg-emerald-500' },
            { key: 'ABS', label: 'Abs', colorClass: 'bg-amber-500' }
          ];

          scoreConfig.forEach(({ key, label, colorClass }) => {
            const value = eleve.scores[key] || 0;
            if (value > 0) {
              const rWidth = (value / 4) * 100;
              // On colore en rouge si la perf est critique (1) sauf pour les absences oÃ¹ c'est l'inverse dans certaines logiques, mais gardons simple:
              const finalColor = (value === 1) ? 'bg-red-500' : colorClass;

              const row = document.createElement('div');
              row.className = 'flex items-center gap-1.5 w-full text-[9px] leading-none';
              row.innerHTML = `
                <span class="w-5 font-bold text-slate-500 dark:text-slate-400 text-right">${label}</span>
                <div class="flex-1 h-1.5 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
                  <div class="h-full rounded-full ${finalColor}" style="width: ${rWidth}%"></div>
                </div>
              `;
              row.title = `${label}: ${value}/4`;
              scoresContainer.appendChild(row);
            }
          });

        } else {
          // Mode classique (Pastilles Texte)
          scoresContainer.className = 'scores flex flex-wrap gap-1 mt-1';
          const scoreMap = [
            { key: 'COM', label: 'Comportement', letter: 'C' },
            { key: 'TRA', label: 'Travail', letter: 'T' },
            { key: 'PART', label: 'Participation', letter: 'P' },
            { key: 'ABS', label: 'Absences', letter: 'A' }
          ];
          scoreMap.forEach(({ key, label, letter }) => {
            const value = eleve.scores[key];
            if (value && value > 0) {
              const pill = document.createElement('div');
              pill.className = `score-pill score-${value}`;
              pill.textContent = letter; // Afficher la LETTRE (C, T, P, A)
              pill.title = `${label}: ${value}/4`;
              scoresContainer.appendChild(pill);
            }
          });
        }
      }

      // Event listeners pour drag & drop et swap
      card.addEventListener('dragstart', handleDragStart);
      card.addEventListener('dragend', handleDragEnd);
      card.addEventListener('click', handleCardClick);

      // ğŸ”’ Indication visuelle pour les Ã©lÃ¨ves FIXE/SPEC/CONDI/PERMUT (le blocage est gÃ©rÃ© par le filtre Sortable)
      if (!STATE.adminMode && eleve.mobilite && ['FIXE', 'SPEC', 'CONDI', 'PERMUT'].includes(eleve.mobilite)) {
        card.classList.add('non-draggable');
        card.style.opacity = '0.85';
        card.title = `${eleve.nom} est ${eleve.mobilite} - Utilisez le mode Swap ou le mode Force pour le dÃ©placer`;
      }

      return card;
    }

    // ========== FONCTION DE CRÃ‰ATION DES COLONNES DE CLASSE ==========
    function createClassColumn(classe, eleves) {
      // On retire d'emblÃ©e les enregistrements "vides"
      const clean = eleves.filter(e => e && e.id && e.id.trim());

      const column = document.querySelector('#tpl-classe-col')
        .content.cloneNode(true).children[0];

      // Attributs ARIA pour la colonne
      const classHeader = column.querySelector('.class-header');
      if (classHeader) {
        classHeader.id = `class-header-${classe}`;
      }
      column.setAttribute('role', 'region');
      column.setAttribute('aria-labelledby', `class-header-${classe}`);

      const counts = countBySex(clean);
      column.querySelector('.classe-name').textContent = classe;
      column.querySelector('.count').textContent = counts.total;
      column.querySelector('.count-f').textContent = counts.F;
      column.querySelector('.count-m').textContent = counts.M;

      const dropZone = column.querySelector('.droppable-zone');
      dropZone.dataset.classe = classe;
      dropZone.setAttribute('role', 'list');
      dropZone.setAttribute('aria-label', `Liste des Ã©lÃ¨ves de ${classe}`);

      // Boutons de tri
      column.querySelectorAll('.sort-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          const sortType = e.currentTarget.dataset.sort;
          const prev = STATE.sortOrder[classe] || {};
          const dir = (prev.type === sortType && prev.dir === 'asc') ? 'desc' : 'asc';

          sortColumn(classe, sortType, dir);

          // Feedback visuel
          column.querySelectorAll('.sort-btn').forEach(b => {
            const arrow = b.querySelector('.sort-arrow');
            if (b === e.currentTarget) {
              b.classList.add('active');
              arrow.textContent = dir === 'asc' ? 'â†‘' : 'â†“';
            } else {
              b.classList.remove('active');
              arrow.textContent = 'â‡…';
            }
          });
        });
      });

      // Restaurer l'Ã©tat visuel du tri si existant
      const currentSort = STATE.sortOrder[classe];
      if (currentSort) {
        column.querySelectorAll('.sort-btn').forEach(btn => {
          const arrow = btn.querySelector('.sort-arrow');
          if (btn.dataset.sort === currentSort.type) {
            btn.classList.add('active');
            arrow.textContent = currentSort.dir === 'asc' ? 'â†‘' : 'â†“';
          }
        });
      }

      // Drag-and-drop
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('drop', handleDrop);
      dropZone.addEventListener('dragleave', handleDragLeave);

      const sortable = new Sortable(dropZone, {
        group: 'students',
        animation: 150,
        ghostClass: 'opacity-50',
        dragClass: 'dragging',
        // ğŸ”’ Filtre pour bloquer le drag des Ã©lÃ¨ves FIXE/SPEC/CONDI/PERMUT (sauf en mode admin)
        filter: function (evt, target) {
          if (!target || !target.dataset) {
            console.warn('âš ï¸ Filtre Sortable: target invalide', target);
            return true; // Bloquer par sÃ©curitÃ©
          }

          // ğŸ”¥ VÃ‰RIFICATION MODE FORCE
          console.log('ğŸ” Filtre Sortable - STATE.adminMode =', STATE?.adminMode);
          if (STATE.adminMode) {
            console.log('ğŸ”¥ MODE FORCE ACTIF - Drag autorisÃ© sans vÃ©rification');
            return false; // En mode admin, tout est draggable
          }

          const eleveId = target.dataset.id;
          if (!eleveId) return false; // Pas d'ID, autoriser (ne devrait pas arriver)
          const eleve = STATE.students[eleveId];
          if (eleve && eleve.mobilite && ['FIXE', 'SPEC', 'CONDI', 'PERMUT'].includes(eleve.mobilite)) {
            console.log(`ğŸ”’ Drag bloquÃ© pour ${eleve.nom} (${eleve.mobilite}) - MODE FORCE INACTIF`);
            toast(`${eleve.nom} est ${eleve.mobilite} - Utilisez le mode Swap ou le mode Force`, 'warning');
            return true; // Bloquer le drag
          }
          return false; // Autoriser le drag
        },
        onEnd: handleSortEnd,
        onStart: (evt) => {
          // Stocker l'Ã©lÃ©ment en cours de dÃ©placement
          STATE.draggingElement = evt.item;
          STATE.dragStartZone = evt.from;
        },
        onMove: (evt) => {
        }
      });



      // Cartes Ã©lÃ¨ves
      clean.forEach(e => {
        const c = createStudentCard(e);
        if (c) dropZone.appendChild(c);
      });

      // Adaptation dynamique de la taille des noms en vue simplifiÃ©e
      setTimeout(() => adjustSimpleNamesFontSize(dropZone), 0);
      return column;
    }

    // ========== HANDLERS DRAG & DROP ==========
    function handleDragStart(e) {
      if (STATE.swapMode) return; // Pas de drag en mode swap

      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', e.target.dataset.id);
      // Mettre Ã  jour aria-grabbed
      e.target.setAttribute('aria-grabbed', 'true');
      e.target.classList.add('dragging');
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      // Remettre aria-grabbed Ã  false
      e.target.setAttribute('aria-grabbed', 'false');
      document.querySelectorAll('.drag-over, .drop-forbidden').forEach(el => {
        el.classList.remove('drag-over', 'drop-forbidden');
      });
    }

    function handleDragOver(e) {
      if (STATE.swapMode) return;
      e.preventDefault();

      // VÃ©rifier si le drop est autorisÃ©
      const draggedId = e.dataTransfer.getData('text/plain') ||
        document.querySelector('.dragging')?.dataset.id;

      if (draggedId) {
        const draggedCard = document.querySelector(`.student-card[data-id="${draggedId}"]`);
        if (draggedCard) {
          const srcClasse = draggedCard.closest('.droppable-zone').dataset.classe;
          const dstClasse = e.currentTarget.dataset.classe;

          const check = canMove(draggedId, srcClasse, dstClasse);

          if (check.ok || STATE.adminMode) {
            e.currentTarget.classList.add('drag-over');
            e.currentTarget.classList.remove('drop-forbidden');

            // PrÃ©visualiser l'impact du dÃ©placement
            if (window.RealTimeFeedback && srcClasse !== dstClasse) {
              window.RealTimeFeedback.previewMove(draggedId, dstClasse);
            }
          } else {
            e.currentTarget.classList.add('drop-forbidden');
            e.currentTarget.classList.remove('drag-over');

            // RÃ©initialiser les changements si drop interdit
            if (window.RealTimeFeedback) {
              window.RealTimeFeedback.resetChanges();
            }
          }
        }
      }
    }

    function handleDragLeave(e) {
      if (e.target === e.currentTarget) {
        e.currentTarget.classList.remove('drag-over', 'drop-forbidden');

        // RÃ©initialiser les changements quand on quitte la zone
        if (RealTimeFeedback) {
          RealTimeFeedback.resetChanges();
        }
      }
    }

    function handleDrop(e) {
      if (STATE.swapMode) return;
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over', 'drop-forbidden');
    }

    // ========== handleSortEnd (version finale en bas du fichier, suppression de l'ancienne version) ==========
    window.handleSortEnd = function (evt) {
      console.log('ğŸ¯ handleSortEnd CLEAN');

      if (STATE.swapMode) return;

      const eleveId = evt.item.dataset.id;
      const oldClasse = evt.from.dataset.classe;
      const newClasse = evt.to.dataset.classe;

      // Si mÃªme classe, juste mise Ã  jour des colonnes
      if (oldClasse === newClasse) {
        updateAllColumnStats(); // â† CET APPEL MANQUE PEUT-ÃŠTRE
        if (window.RealTimeFeedback) window.RealTimeFeedback.updateMetrics();
        return;
      }

      // Marquer qu'il y a eu une action utilisateur (dÃ©placement entre classes)
      if (typeof markUserAction === 'function') {
        markUserAction();
      } else {
        STATE.has_user_action = true;
      }

      // ğŸ”¥ MODE FORCE : Tout est autorisÃ© sans vÃ©rification
      if (STATE.adminMode) {
        console.log('ğŸ”¥ MODE FORCE: DÃ©placement autorisÃ© sans vÃ©rification');
      } else {
        // Mode normal : vÃ©rifier les contraintes
        const check = canMove(eleveId, oldClasse, newClasse);

        if (!check.ok) {
          evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex] || null);
          toast(check.reason, 'error');
          updateAllColumnStats();
          return;
        }

        if (check.warn) {
          toast(check.warn, 'warning');
        }
      }

      // Historique
      const moveAction = {
        type: 'move',
        eleveId,
        eleveName: STATE.students[eleveId]?.nom || 'Ã‰lÃ¨ve',
        oldClasse,
        newClasse,
        oldIndex: evt.oldIndex,
        newIndex: evt.newIndex,
        timestamp: new Date().toISOString()
      };
      STATE.history.push(moveAction);
      STATE.historyTimeline.push(moveAction);
      STATE.future = [];
      updateUndoRedoButtons();

      // Mettre Ã  jour le panneau historique
      updateHistoryPanel();

      // âœ… UNE SEULE mise Ã  jour des colonnes
      updateAllColumnStats(); // â† CET APPEL DOIT ÃŠTRE PRÃ‰SENT

      // âœ… UNE SEULE mise Ã  jour des stats avancÃ©es avec dÃ©lai
      setTimeout(() => updateAdvancedStats(), 150);

      // Feedback temps rÃ©el
      if (RealTimeFeedback) RealTimeFeedback.updateMetrics();

      // Sauvegarde
      if (STATE.currentMode === 'CACHE') {
        setTimeout(() => saveImmediateCache(), 200);
      }
    };

    // ========== FONCTION MANQUANTE - Chargement des donnÃ©es selon le mode ==========
    async function loadDataForMode(mode) {
      showSpinner();
      try {
        // ğŸ¯ Appel Ã  l'adaptateur SAS dÃ©diÃ©
        const result = await gsRun('getClassesDataForInterfaceV2', mode);
        console.log('ğŸ¯ RÃ‰SULTAT SAS getClassesDataForInterfaceV2:', JSON.stringify(result, null, 2));
        console.log('ğŸ” Type de result:', typeof result);
        console.log('ğŸ” result.success:', result?.success);
        console.log('ğŸ” result.data (Array):', result?.data);
        console.log('ğŸ” result.rules (_STRUCTURE):', result?.rules);
        console.log('ğŸ” Nombre de classes:', result?.data?.length);

        if (!result || !result.success) {
          console.error('âŒ Erreur lors du chargement des donnÃ©es:', result?.error);
          showErrorState(result?.error || 'Erreur inconnue');
          return false;
        }

        // Stocker les donnÃ©es dans STATE
        STATE.originalData = result.data;
        STATE.rules = result.rules || {};
        STATE.niveau = detectNiveau(result.data);
        // Mettre Ã  jour l'interface
        const niveauElement = document.getElementById('niveau-detected');
        if (niveauElement) {
          niveauElement.textContent = STATE.niveau;
        }
        // CrÃ©er le dictionnaire des Ã©lÃ¨ves et les groupes
        STATE.students = {};
        STATE.aGroups = {};
        result.data.forEach(group => {
          group.eleves.forEach(eleve => {
            STATE.students[eleve.id] = eleve;
            // Grouper les associations
            if (eleve.asso) {
              const key = `A${eleve.asso}`;
              if (!STATE.aGroups[key]) STATE.aGroups[key] = [];
              STATE.aGroups[key].push(eleve.id);
            }
          });
        });
        // Afficher les colonnes
        renderBoard(result.data);
        return true;
      } catch (error) {
        console.error('ğŸ’¥ Erreur fatale:', error);
        return false;
      } finally {
        hideSpinner();
      }
    }

    // ========== FONCTION - Affichage des colonnes/classes ==========
    function renderBoard(data) {
      const board = document.getElementById('board');
      if (!board) {
        console.error('Ã‰lÃ©ment #board introuvable');
        return;
      }

      board.innerHTML = '';
      if (!data || data.length === 0) {
        showErrorState('Aucune classe trouvÃ©e');
        return;
      }

      /* --- tri naturel des intitulÃ©s "6Â°1", "6Â°2", â€¦ --- */
      const sortedData = data.slice().sort((a, b) => {
        const ma = a.classe.match(/(\d+)Â°(\d+)/);
        const mb = b.classe.match(/(\d+)Â°(\d+)/);
        if (ma && mb) {
          const nivA = +ma[1], nivB = +mb[1];
          if (nivA !== nivB) return nivA - nivB;
          return +ma[2] - +mb[2];
        }
        return a.classe.localeCompare(b.classe);
      });

      /* --- crÃ©ation des colonnes --- */
      sortedData.forEach(group => {
        const col = createClassColumn(group.classe, group.eleves);
        if (col) board.appendChild(col);
      });

      /* --- ajustements de prÃ©sentation --- */
      setTimeout(resizeCards, 100);
      updateAllColumnStats();              // <-- nouvelle ligne : compteurs Ã  jour !

      if (STATE.viewMode === 'simple') {
        setTimeout(() => {
          document.querySelectorAll('.droppable-zone')
            .forEach(zone => adjustSimpleNamesFontSize(zone));
        }, 120);
      }

      if (window.applyLisibilitePreferences) {
        window.applyLisibilitePreferences();
      }

      /* --- initialisation des graphiques --- */
      setTimeout(() => {
        if (typeof initCharts === 'function') {
          initCharts();
        }
      }, 200);
    }

    // ========== FONCTION MANQUANTE - AFFICHAGE DU BADGE DE MODE ==========
    function showModeBadge(mode) {
      const badge = document.getElementById('modeBadge');
      if (badge) {
        // DÃ©terminer le label et la couleur selon le mode
        let label = 'MODE ' + mode;
        let bgColor = '#3b82f6'; // Bleu par dÃ©faut

        switch (mode) {
          case 'TEST':
            label = 'ğŸ“š TEST (Classes test)';
            bgColor = '#3b82f6'; // Bleu
            break;
          case 'PREVIOUS':
            label = 'ğŸ“‹ PREVIOUS (AnnÃ©e passÃ©e)';
            bgColor = '#8b5cf6'; // Violet
            break;
          case 'FINAL':
            label = 'âœ… FINAL (Classes finales)';
            bgColor = '#10b981'; // Vert
            break;
          // Anciens modes pour rÃ©trocompatibilitÃ©
          case 'CACHE':
            label = 'MODE CACHE';
            bgColor = '#f59e0b'; // Orange
            break;
          case 'INT':
            label = 'MODE INT';
            bgColor = '#10b981'; // Vert
            break;
        }

        badge.textContent = label;
        badge.style.background = bgColor;
        badge.style.color = 'white';
        badge.classList.remove('hidden');
      }
    }

    // ========== FONCTION - Badge de sauvegarde ==========
    function updateSaveBadgeUI() {
      const el = document.getElementById('autosaveBadge');
      if (!el) return;
      if (STATE.last_save_ts) {
        const d = new Date(STATE.last_save_ts);
        el.textContent = `ğŸ’¾ SauvegardÃ© ${d.getHours()}h${String(d.getMinutes()).padStart(2, '0')}`;
      } else {
        el.textContent = `ğŸ’¾ Jamais`;
      }
    }

    // ========== FONCTIONS MANQUANTES - Auto-save avec dÃ©bounce intelligent ==========

    // Timer pour le dÃ©bounce intelligent
    let autoSaveDebounceTimer = null;

    /**
     * DÃ©marre l'auto-save avec dÃ©bounce intelligent
     * Sauvegarde 30 secondes aprÃ¨s la derniÃ¨re action utilisateur
     */
    function startAutoSave() {
      console.log('ğŸ”„ Auto-save CACHE activÃ© (dÃ©bounce 30s aprÃ¨s derniÃ¨re action)');

      // Fonction pour planifier la sauvegarde
      window.scheduleAutoSave = function () {
        // Annuler le timer prÃ©cÃ©dent
        if (autoSaveDebounceTimer) {
          clearTimeout(autoSaveDebounceTimer);
        }

        // Planifier une nouvelle sauvegarde dans 30 secondes
        autoSaveDebounceTimer = setTimeout(async () => {
          if (typeof window.saveImmediateCache === 'function') {
            console.log('â° DÃ©clenchement auto-save (30s aprÃ¨s derniÃ¨re action)');
            await window.saveImmediateCache();
          }
        }, 30000); // 30 secondes
      };

      // DÃ©marrer le premier cycle
      window.scheduleAutoSave();
    }

    function stopAutoSave() {
      if (autoSaveDebounceTimer !== null) {
        clearTimeout(autoSaveDebounceTimer);
        autoSaveDebounceTimer = null;
        console.log('â¹ï¸ Auto-save arrÃªtÃ©');
      }

      // Nettoyer la fonction globale
      if (window.scheduleAutoSave) {
        delete window.scheduleAutoSave;
      }
    }

    // ========== FONCTION MANQUANTE - VÃ©rifier le cache ==========
    async function checkCache() {
      const restoreBlock = document.getElementById('restoreCacheBlock');
      const lastDate = document.getElementById('lastCacheDate');

      // 1. VÃ©rifier d'abord le localStorage
      const cached = localStorage.getItem('cache-data');
      if (cached) {
        try {
          const data = JSON.parse(cached);
          if (restoreBlock) restoreBlock.classList.remove('hidden');
          if (lastDate) {
            lastDate.textContent = new Date(data.date).toLocaleString('fr-FR');
          }
          return; // On a trouvÃ© des donnÃ©es dans le localStorage
        } catch (e) {
          console.error('Cache localStorage invalide:', e);
        }
      }

      // 2. Si pas de localStorage, vÃ©rifier le backend (PropertiesService)
      try {
        console.log('ğŸ” VÃ©rification de la sauvegarde automatique depuis le backend...');
        const backendCache = await gsRun('getLastCacheInfo');

        if (backendCache && backendCache.exists && backendCache.date) {
          if (restoreBlock) restoreBlock.classList.remove('hidden');
          if (lastDate) {
            const date = new Date(backendCache.date);
            lastDate.textContent = date.toLocaleString('fr-FR');
          }
        } else {
          console.log('â„¹ï¸ Aucune sauvegarde automatique trouvÃ©e');
          if (restoreBlock) restoreBlock.classList.add('hidden');
        }
      } catch (error) {
        console.error('âŒ Erreur lors de la vÃ©rification du cache backend:', error);
      }
    }

    // ========== FONCTION MANQUANTE - Restaurer le cache ==========
    async function restoreCache() {
      const cached = localStorage.getItem('cache-data');
      if (!cached) return;
      try {
        const data = JSON.parse(cached);
        localStorage.setItem('mode-selection', data.mode);
        await initRepartitionApp();
        // Appliquer la disposition sauvegardÃ©e
        if (data.disposition) {
          Object.entries(data.disposition).forEach(([classe, ids]) => {
            const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
            if (zone) {
              ids.forEach(id => {
                const card = document.querySelector(`.student-card[data-id="${id}"]`);
                if (card) zone.appendChild(card);
              });
            }
          });
        }
        updateAllColumnStats();
        toast('Cache restaurÃ© avec succÃ¨s', 'success');
      } catch (e) {
        console.error('Erreur restauration cache:', e);
        toast('Erreur lors de la restauration', 'error');
      }
    }

    // =======================================================
    // VARIABLES GLOBALES
    // =======================================================
    let autoSaveInterval = null;

    /**
     * @typedef {Object} StudentScores
     * @property {string|number} [COM] - Score communication (0/1)
     * @property {string|number} [TRA] - Score travail
     * @property {string|number} [PART] - Score participation
     * @property {string|number} [ABS] - Score absences
     */

    /**
     * @typedef {Object} Student
     * @property {string} id - Identifiant unique de l'Ã©lÃ¨ve
     * @property {string} nom - Nom de famille
     * @property {string} prenom - PrÃ©nom
     * @property {string} sexe - Genre ('F' ou 'M')
     * @property {string} [lv2] - Langue vivante 2 (ex: 'ESP', 'ALL', 'ITA')
     * @property {string} [opt] - Option (ex: 'LATIN', 'EURO')
     * @property {string} [disso] - Code dissociation (groupe Ã  sÃ©parer)
     * @property {string} [asso] - Code association (groupe Ã  garder ensemble)
     * @property {string} [mobilite] - Statut mobilitÃ© ('LIBRE','FIXE','SPEC','CONDI','PERMUT')
     * @property {StudentScores} [scores] - Scores par critÃ¨re
     */

    /**
     * @typedef {Object} SwapAction
     * @property {string} type - Type d'action ('swap' ou 'move')
     * @property {string} [studentId] - ID de l'Ã©lÃ¨ve dÃ©placÃ©
     * @property {string} [from] - Classe d'origine
     * @property {string} [to] - Classe de destination
     */

    /**
     * @typedef {Object} AppState
     * @property {string} viewMode - Mode d'affichage ('complete', 'simple', 'compact')
     * @property {Object<string, Student>} students - Dictionnaire plat id â†’ Ã©lÃ¨ve
     * @property {Object<string, *>} rules - RÃ¨gles par classe (depuis _STRUCTURE)
     * @property {Object<string, string[]>} aGroups - Groupes d'association (clÃ© 'A'+code â†’ tableau d'IDs)
     * @property {SwapAction[]} history - Historique d'actions (undo)
     * @property {SwapAction[]} historyTimeline - Historique complet (timeline)
     * @property {SwapAction[]} future - Actions annulÃ©es (redo)
     * @property {boolean} swapMode - Mode permutation actif
     * @property {string|null} swapFirst - ID du 1er Ã©lÃ¨ve sÃ©lectionnÃ© pour swap
     * @property {boolean} adminMode - Mode administrateur actif
     * @property {string} searchTerm - Terme de recherche actuel
     * @property {boolean} darkMode - Mode sombre
     * @property {boolean} zoomMode - Mode zoom
     * @property {boolean} fullscreenStats - Stats en plein Ã©cran
     * @property {boolean} anchoredStats - Stats ancrÃ©es
     * @property {string|null} currentMode - Mode de travail courant (ex: '2NDE')
     * @property {Array|null} originalData - DonnÃ©es brutes chargÃ©es depuis le backend
     * @property {string} niveau - Niveau dÃ©tectÃ© (ex: '2NDE', '1ERE')
     * @property {Object<string, string>} sortOrder - Ordre de tri par classe
     * @property {boolean} lastSaveError - DerniÃ¨re sauvegarde en erreur
     * @property {HTMLElement|null} draggingElement - Ã‰lÃ©ment en cours de drag
     * @property {HTMLElement|null} dragStartZone - Zone de dÃ©part du drag
     * @property {boolean} has_user_action - Action utilisateur non sauvegardÃ©e
     * @property {number|null} last_save_timestamp - Timestamp derniÃ¨re sauvegarde
     */

    /** @type {AppState} */
    window.STATE = {
      viewMode: 'complete',
      students: {},
      rules: {},
      aGroups: {},
      history: [],
      historyTimeline: [], // AjoutÃ© pour le panneau historique
      future: [],
      swapMode: false,
      swapFirst: null,
      adminMode: false,
      searchTerm: '',
      darkMode: false,
      zoomMode: false,
      fullscreenStats: false,
      anchoredStats: false,
      currentMode: null,
      originalData: null,
      niveau: '',
      sortOrder: {},
      lastSaveError: false,
      draggingElement: null,
      dragStartZone: null,
      has_user_action: false,
      last_save_timestamp: null
    };

    // Alias pour compatibilitÃ© avec le code existant
    const STATE = window.STATE;

    // Variables pour les graphiques (les dÃ©placer aussi)
    window.chartCommunication = null;
    window.chartDistribution = null;
    window.chartLV2 = null;
    window.chartOptions = null;

    // ============================================
    // ARCHITECTURE MODULAIRE
    // ============================================
    /**
     * Architecture modulaire de l'application InterfaceV2
     *
     * Cette section organise le code JavaScript en modules logiques pour amÃ©liorer
     * l'organisation et la maintenabilitÃ© du code (12561 lignes).
     *
     * DOCUMENTATION COMPLÃˆTE : Voir ARCHITECTURE_MODULAIRE.md
     *
     * MODULES DISPONIBLES :
     * - App.state       : Ã‰tat global de l'application (alias de STATE)
     * - App.UI          : CrÃ©ation et manipulation des Ã©lÃ©ments UI
     * - App.DragDrop    : Gestion du drag and drop
     * - App.Views       : Gestion des diffÃ©rentes vues (simple, complete, swap, dark mode)
     * - App.History     : Historique et undo/redo
     * - App.Stats       : Statistiques et mÃ©triques
     * - App.Constraints : Validation des contraintes
     * - App.Data        : Import/Export et sauvegarde
     * - App.Search      : Recherche et filtres
     * - App.Utils       : Fonctions utilitaires
     * - App.Init        : Initialisation de l'application
     *
     * COMPATIBILITÃ‰ :
     * Des fonctions wrapper globales sont disponibles pour assurer la compatibilitÃ©
     * avec le code existant. Voir section "FONCTIONS WRAPPER POUR COMPATIBILITÃ‰" ci-dessous.
     *
     * UTILISATION :
     * // Nouveau code (recommandÃ©)
     * App.UI.toast('Message', 'success');
     *
     * // Code legacy (toujours supportÃ© via wrappers)
     * toast('Message', 'success');
     *
     * MIGRATION EN COURS :
     * âœ… App.UI          - toast, updateColumnStats, showSpinner, etc.
     * âœ… App.History     - undo, redo, updateUndoRedoButtons
     * âœ… App.Stats       - updateAdvancedStats
     * âœ… App.Data        - exportDisposition, saveImmediateCache
     * âœ… App.Utils       - isRealClass
     * â³ App.Views       - Ã€ migrer : toggleViewMode, toggleSwapMode, etc.
     * â³ App.DragDrop    - Ã€ migrer : handleDragStart, handleDrop, etc.
     * â³ App.Constraints - Ã€ migrer : canMove, canSwap
     * â³ App.Search      - Ã€ migrer : searchStudents, filterByTag
     * â³ App.Init        - Ã€ migrer : setupEventListeners, initApp
     */

    const App = {
      // ============================================
      // Ã‰TAT GLOBAL (rÃ©fÃ©rence vers STATE)
      // ============================================
      get state() {
        return STATE;
      },

      // ============================================
      // MODULE UI - CrÃ©ation et manipulation des Ã©lÃ©ments
      // ============================================
      UI: {
        /**
         * Affiche une notification toast
         * @param {string} message - Message Ã  afficher
         * @param {string} type - Type de notification (info, success, error, warning)
         */
        toast(message, type = 'info') {
          const icons = {
            info: 'fa-info-circle',
            success: 'fa-check-circle',
            error: 'fa-exclamation-circle',
            warning: 'fa-exclamation-triangle'
          };

          const isSwapError = type === 'error';
          const toast = document.createElement('div');

          if (isSwapError) {
            toast.className = `toast ${type} fade-in`;
            toast.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 9999;
          font-size: 1.5rem;
          padding: 24px 40px;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
          border-radius: 12px;
          background: #dc2626;
          color: white;
          border: none;
          font-weight: 600;
          min-width: 400px;
          text-align: center;
        `;
          } else {
            toast.className = `toast ${type} fixed bottom-4 right-4 z-50 fade-in`;
          }

          toast.innerHTML = `
        <i class="fas ${icons[type]} ${isSwapError ? 'text-2xl mr-3' : 'text-lg'}"></i>
        <span>${message}</span>
      `;

          document.body.appendChild(toast);

          const duration = isSwapError ? 4000 : 3000;

          setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease-out';
            setTimeout(() => toast.remove(), 300);
          }, duration);
        },

        /**
         * Met Ã  jour les statistiques d'une colonne de classe
         * @param {HTMLElement} column - Ã‰lÃ©ment DOM de la colonne
         * @param {Array} eleves - Liste des Ã©lÃ¨ves
         */
        updateColumnStats(column, eleves) {
          if (!column) return;

          const counts = countBySex(eleves);

          column.querySelector('.count').textContent = counts.total;
          column.querySelector('.count-f').textContent = counts.F;
          column.querySelector('.count-m').textContent = counts.M;

          const scoreCats = ['C', 'T', 'P', 'A'];
          const counters = { C: [0, 0, 0, 0], T: [0, 0, 0, 0], P: [0, 0, 0, 0], A: [0, 0, 0, 0] };

          eleves.forEach(e => {
            scoreCats.forEach(cat => {
              const v = +e.scores?.[cat] || 0;
              if (v >= 1 && v <= 4) counters[cat][v - 1]++;
            });
          });

          scoreCats.forEach(cat => {
            counters[cat].forEach((val, i) => {
              const el = column.querySelector(`.count-${cat.toLowerCase()}${i + 1}`);
              if (el) el.textContent = val;
            });
          });
        },

        /**
         * Met Ã  jour les statistiques de toutes les colonnes
         */
        updateAllColumnStats() {

          document.querySelectorAll('.class-column').forEach(column => {
            const className = column.querySelector('.classe-name').textContent;
            if (!App.Utils.isRealClass(className)) return;

            const dropZone = column.querySelector('.droppable-zone');
            const cards = Array.from(dropZone.querySelectorAll('.student-card'));
            const eleves = cards.map(card => STATE.students[card.dataset.id]).filter(Boolean);

            App.UI.updateColumnStats(column, eleves);
          });
        },

        /**
         * Ajuste la taille de police des noms en vue simplifiÃ©e
         * @param {HTMLElement} dropZone - Zone de dÃ©pÃ´t
         */
        adjustSimpleNamesFontSize(dropZone) {
          if (!STATE || STATE.viewMode !== 'simple') return;
          const cards = Array.from(dropZone.querySelectorAll('.student-card'));
          if (cards.length === 0) return;

          let zoneHeight = dropZone.clientHeight || dropZone.offsetHeight || 0;
          if (!zoneHeight) {
            const parent = dropZone.closest('.class-column');
            if (parent) zoneHeight = parent.clientHeight || parent.offsetHeight || 0;
          }
          if (!zoneHeight) return;

          const availableHeight = zoneHeight - 30;
          const minFont = 16;
          const maxFont = 32;
          let fontSize = Math.floor(availableHeight / cards.length) - 2;

          if (isNaN(fontSize) || fontSize < minFont) fontSize = minFont;
          if (fontSize > maxFont) fontSize = maxFont;

          cards.forEach(card => {
            const nameEl = card.querySelector('.student-simple-name');
            const lineEl = card.querySelector('.simple-line');
            if (nameEl) {
              nameEl.style.fontSize = fontSize + 'px';
              nameEl.style.lineHeight = (fontSize + 2) + 'px';
            }
            if (lineEl) {
              lineEl.style.height = (fontSize + 6) + 'px';
            }
          });
        },

        /**
         * Affiche/masque le spinner de chargement
         */
        showSpinner() {
          document.getElementById('loadingSpinner')?.classList.remove('hidden');
        },

        hideSpinner() {
          document.getElementById('loadingSpinner')?.classList.add('hidden');
        },

        /**
         * Ajoute un nouvel Ã©lÃ¨ve Ã  une classe
         * Fonction publique appelÃ©e par le module NewStudentModule
         * @param {Object} newStudent - Objet Ã©lÃ¨ve au format {id, nom, prenom, sexe, lv2, opt, scores, ...}
         * @param {string} classId - ID de la classe (ex: "6Â°1")
         */
        addStudentToClass(newStudent, classId) {
          console.log(`[App.UI.addStudentToClass] Ajout de ${newStudent.nom} ${newStudent.prenom} dans ${classId}`);

          if (!newStudent || !newStudent.id || !classId) {
            console.error('[App.UI.addStudentToClass] DonnÃ©es invalides');
            return false;
          }

          // 1. Ajouter Ã  STATE.students
          if (!STATE.students) STATE.students = {};
          STATE.students[newStudent.id] = newStudent;

          // 2. Ajouter Ã  STATE.classes
          if (!STATE.classes[classId]) {
            STATE.classes[classId] = { eleves: [] };
          }
          STATE.classes[classId].eleves.push(newStudent);

          // 3. Ajouter au DOM (crÃ©er la carte et l'insÃ©rer dans la zone de dÃ©pÃ´t)
          const dropZone = document.querySelector(`.droppable-zone[data-classe="${classId}"]`);
          if (dropZone && typeof createStudentCard === 'function') {
            const card = createStudentCard(newStudent);
            if (card) {
              dropZone.appendChild(card);
              console.log(`[App.UI.addStudentToClass] Carte DOM crÃ©Ã©e et insÃ©rÃ©e`);
            }
          }

          // 4. Ajouter Ã  STATE.aGroups si association
          if (newStudent.asso) {
            const key = `A${newStudent.asso}`;
            if (!STATE.aGroups) STATE.aGroups = {};
            if (!STATE.aGroups[key]) STATE.aGroups[key] = [];
            if (!STATE.aGroups[key].includes(newStudent.id)) {
              STATE.aGroups[key].push(newStudent.id);
            }
          }

          // 5. Enregistrer dans l'historique
          if (!STATE.history) STATE.history = [];
          STATE.history.push({
            type: 'add',
            eleveId: newStudent.id,
            eleveName: `${newStudent.nom} ${newStudent.prenom}`,
            classe: classId,
            timestamp: new Date().toISOString()
          });

          // 6. Mettre Ã  jour les stats
          App.UI.updateAllColumnStats();

          // 7. Mettre Ã  jour les stats avancÃ©es
          if (typeof updateAdvancedStats === 'function') {
            setTimeout(() => updateAdvancedStats(), 150);
          }

          // 8. Marquer comme modifiÃ© pour auto-save
          STATE.has_user_action = true;

          // 9. Sauvegarde immÃ©diate si mode CACHE
          if (STATE.currentMode === 'CACHE' && typeof App.Data?.saveImmediateCache === 'function') {
            setTimeout(() => App.Data.saveImmediateCache(), 200);
          }

          return true;
        }
      },

      // ============================================
      // MODULE DRAG & DROP
      // ============================================
      DragDrop: {
        // Ces fonctions seront migrÃ©es depuis le code existant
        // Pour l'instant, on laisse des placeholders qui appelleront les fonctions globales
      },

      // ============================================
      // MODULE VIEWS - Gestion des vues
      // ============================================
      Views: {
        // Placeholders pour les fonctions de vue
      },

      // ============================================
      // MODULE HISTORY - Historique et undo/redo
      // ============================================
      History: {
        /**
         * Met Ã  jour l'Ã©tat des boutons undo/redo
         */
        updateUndoRedoButtons() {
          const btnUndo = document.getElementById('btnUndo');
          const btnRedo = document.getElementById('btnRedo');

          if (btnUndo) btnUndo.disabled = STATE.history.length === 0;
          if (btnRedo) btnRedo.disabled = STATE.future.length === 0;
        },

        /**
         * Annule la derniÃ¨re action
         */
        undo() {
          if (STATE.history.length === 0) return;

          const action = STATE.history.pop();
          STATE.future.push(action);

          // Retirer aussi de historyTimeline
          if (STATE.historyTimeline.length > 0) {
            STATE.historyTimeline.pop();
          }

          if (action.type === 'move') {
            const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
            const oldZone = document.querySelector(`.droppable-zone[data-classe="${action.oldClasse}"]`);

            if (card && oldZone) {
              // InsÃ©rer Ã  l'ancienne position si possible
              if (action.oldIndex < oldZone.children.length) {
                oldZone.insertBefore(card, oldZone.children[action.oldIndex]);
              } else {
                oldZone.appendChild(card);
              }
            }
          } else if (action.type === 'swap') {
            if (typeof performSwap === 'function') {
              performSwap(action.id2, action.id1); // Swap inverse
              STATE.history.pop(); // Enlever le swap ajoutÃ© par performSwap
            }
          }

          App.History.updateUndoRedoButtons();
          App.UI.updateAllColumnStats();

          // Mettre Ã  jour le panneau historique
          if (typeof updateHistoryPanel === 'function') {
            updateHistoryPanel();
          }

          // Mise Ã  jour intelligente des statistiques
          setTimeout(() => App.Stats.updateAdvancedStats(), 150);

          // Sauvegarde aprÃ¨s undo
          if (STATE.currentMode === 'CACHE') {
            App.Data.saveImmediateCache();
          }
        },

        /**
         * Refait la derniÃ¨re action annulÃ©e
         */
        redo() {
          if (STATE.future.length === 0) return;

          const action = STATE.future.pop();

          if (action.type === 'move') {
            const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
            const newZone = document.querySelector(`.droppable-zone[data-classe="${action.newClasse}"]`);

            if (card && newZone) {
              if (action.newIndex < newZone.children.length) {
                newZone.insertBefore(card, newZone.children[action.newIndex]);
              } else {
                newZone.appendChild(card);
              }
            }
            STATE.history.push(action);
            // Ajouter aussi Ã  historyTimeline pour le panneau historique
            STATE.historyTimeline.push(action);
          } else if (action.type === 'swap') {
            if (typeof performSwap === 'function') {
              performSwap(action.id1, action.id2);
            }
          }

          App.History.updateUndoRedoButtons();
          App.UI.updateAllColumnStats();

          // Mettre Ã  jour le panneau historique
          if (typeof updateHistoryPanel === 'function') {
            updateHistoryPanel();
          }

          // Mise Ã  jour intelligente des statistiques
          setTimeout(() => App.Stats.updateAdvancedStats(), 150);

          // Sauvegarde aprÃ¨s redo
          if (STATE.currentMode === 'CACHE') {
            App.Data.saveImmediateCache();
          }
        }
      },

      // ============================================
      // MODULE STATS - Statistiques
      // ============================================
      Stats: {
        /**
         * Met Ã  jour les statistiques avancÃ©es
         */
        updateAdvancedStats() {
          console.log('chartsReady=', window.areChartsReady?.(),
            'typeof updateCharts =', typeof updateCharts);

          const panel = document.getElementById('statsPanel');
          if (!panel || panel.classList.contains('translate-x-full')) {
            return;
          }

          if (typeof updateNewMetrics === 'function') {
            updateNewMetrics();
          }

          if (typeof updateCharts === 'function') {
            updateCharts();
          }

          if (typeof updateLV2Details === 'function') {
            updateLV2Details();
          }
        }
      },

      // ============================================
      // MODULE CONSTRAINTS - Validation
      // ============================================
      Constraints: {
        // Placeholders pour les fonctions de contraintes
      },

      // ============================================
      // MODULE DATA - Import/Export
      // ============================================
      Data: {
        /**
         * Exporte la disposition actuelle
         * @returns {Object} Disposition des classes
         */
        exportDisposition() {
          const result = {};
          document.querySelectorAll('.class-column').forEach(column => {
            const classe = column.querySelector('.classe-name').textContent;
            const ids = Array.from(column.querySelectorAll('.student-card')).map(card => card.dataset.id);
            result[classe] = ids;
          });
          return result;
        },

        /**
         * Sauvegarde immÃ©diate dans le cache
         */
        async saveImmediateCache() {
          try {
            // 1. Ne rien faire si l'utilisateur n'a rien bougÃ©
            if (!STATE.has_user_action) {
              console.debug('â­ï¸ Auto-save sautÃ© (aucune action)');
              return;
            }

            const disposition = App.Data.exportDisposition();
            const cacheData = {
              date: new Date().toISOString(),
              disposition: disposition,
              mode: STATE.currentMode
            };

            // Sauvegarde locale (localStorage)
            localStorage.setItem('cache-data', JSON.stringify(cacheData));

            if (typeof gsRun === 'function') {
              try {
                // ğŸ”¥ NOUVEAU: Appel Ã  saveDispositionToSheets pour crÃ©er les onglets CACHE
                const result = await gsRun('saveDispositionToSheets', disposition);

                if (result && result.success) {

                  // 2. AprÃ¨s succÃ¨s â†’ on remet le flag Ã  false,
                  //    on horodate, on met Ã  jour le badge
                  STATE.has_user_action = false;
                  STATE.last_save_ts = Date.now();

                  if (typeof updateSaveBadge === 'function') {
                    updateSaveBadge(true);
                  }
                } else {
                  console.warn('âš ï¸ Sauvegarde CACHE Ã©chouÃ©e:', result?.error);
                  if (typeof updateSaveBadge === 'function') {
                    updateSaveBadge(false);
                  }
                }
              } catch (error) {
                console.error('âŒ Erreur sauvegarde CACHE:', error);
                if (typeof updateSaveBadge === 'function') {
                  updateSaveBadge(false);
                }
              }
            }
          } catch (error) {
            console.error('âŒ Erreur dans saveImmediateCache:', error);
          }
        }
      },

      // ============================================
      // MODULE SEARCH - Recherche et filtres
      // ============================================
      Search: {
        // Placeholders pour les fonctions de recherche
      },

      // ============================================
      // MODULE UTILS - Utilitaires
      // ============================================
      Utils: {
        /**
         * VÃ©rifie si un nom de classe est une vraie classe (pas un groupe)
         * @param {string} className - Nom de la classe
         * @returns {boolean}
         */
        isRealClass(className) {
          const groupPatterns = [
            /^level_/i,
            /^grp_/i,
            /^groupe_/i,
            /^group_/i,
            /_Groupe\d*$/i,
            /^ESP_/i,
            /^ITA_/i,
            /^ALL_/i,
            /^LATIN_/i,
            /^MATH_/i,
            /^FR_/i,
            /^Niveau/i
          ];

          for (const pattern of groupPatterns) {
            if (pattern.test(className)) {
              return false;
            }
          }

          const classPattern = /^\d+Â°\d+$/;
          return classPattern.test(className);
        }
      },

      // ============================================
      // MODULE INIT - Initialisation
      // ============================================
      Init: {
        // Placeholders pour l'initialisation
      }
    };

    // ============================================
    // FONCTIONS WRAPPER POUR COMPATIBILITÃ‰
    // ============================================
    /**
     * Ces fonctions wrapper assurent la compatibilitÃ© avec les event handlers HTML existants
     * et le code legacy. Elles dÃ©lÃ¨guent simplement vers les modules appropriÃ©s.
     */

    // Wrapper pour toast
    function toast(message, type = 'info') {
      return App.UI.toast(message, type);
    }

    // Wrapper pour updateColumnStats
    function updateColumnStats(column, eleves) {
      return App.UI.updateColumnStats(column, eleves);
    }

    // Wrapper pour updateAllColumnStats
    function updateAllColumnStats() {
      return App.UI.updateAllColumnStats();
    }

    // Wrapper pour adjustSimpleNamesFontSize
    function adjustSimpleNamesFontSize(dropZone) {
      return App.UI.adjustSimpleNamesFontSize(dropZone);
    }

    // Wrapper pour isRealClass
    function isRealClass(className) {
      return App.Utils.isRealClass(className);
    }

    // Wrapper pour exportDisposition
    function exportDisposition() {
      return App.Data.exportDisposition();
    }

    // Wrapper pour saveImmediateCache
    async function saveImmediateCache() {
      return App.Data.saveImmediateCache();
    }

    // Wrapper pour updateUndoRedoButtons
    function updateUndoRedoButtons() {
      return App.History.updateUndoRedoButtons();
    }

    // Wrapper pour updateAdvancedStats
    function updateAdvancedStats() {
      return App.Stats.updateAdvancedStats();
    }

    // Wrapper pour undo
    function undo() {
      return App.History.undo();
    }

    // Wrapper pour redo
    function redo() {
      return App.History.redo();
    }

    // Wrapper pour showSpinner/hideSpinner
    function showSpinner() {
      return App.UI.showSpinner();
    }

    function hideSpinner() {
      return App.UI.hideSpinner();
    }

    // Wrapper pour addStudentToClass (appelÃ© par le module NewStudentModule)
    function addStudentToClass(newStudent, classId) {
      return App.UI.addStudentToClass(newStudent, classId);
    }

    // =======================================================
    // FONCTIONS GLOBALES (Legacy - Ã€ migrer progressivement)
    // =======================================================
    // showSpinner() et hideSpinner() migrÃ©s vers App.UI






    // ========== AJUSTEMENT TAILLE DES CARTES ==========
    function resizeCards() {
      document.querySelectorAll('.student-card').forEach(card => {
        const w = card.offsetWidth;
        // Toujours retirer toutes les classes
        card.classList.remove('card-sm', 'card-md', 'card-lg');
        // Puis ajouter la classe appropriÃ©e
        if (w > 320) card.classList.add('card-lg');
        else if (w > 240) card.classList.add('card-md');
        else card.classList.add('card-sm');
      });
    }






    // ========== FONCTION D'OUVERTURE DU MODAL DE DÃ‰MARRAGE ==========
    // Fonction dÃ©jÃ  dÃ©finie plus haut

    // =======================================================
    // PONT INTELLIGENT AVEC LA CONSOLE DE PILOTAGE
    // ======================================================
    async function initializeBridge() {
      try {
        console.log('ğŸŒ‰ Initialisation du pont depuis la Console de Pilotage...');
        // Cette fonction cÃ´tÃ© serveur lit la propriÃ©tÃ© utilisateur 'JULES_CONTEXT' et la supprime.
        const result = await gsRun('getBridgeContextAndClear');

        if (result && result.success && result.context && result.context.mode) {
          const mode = result.context.mode;
          const sourceSheet = result.context.sourceSheetName || 'source';

          console.log(`ğŸ“¡ Contexte reÃ§u: Mode=${mode}, Source=${sourceSheet}`);

          localStorage.setItem('mode-selection', mode);
          toast(`Contexte chargÃ© depuis la console (Mode: ${mode})`, 'success');

          // Cacher le modal de dÃ©marrage et lancer l'application
          const startupModal = document.getElementById('startupModal');
          if (startupModal) {
            startupModal.classList.add('hidden');
          }
          // On a un mode, on peut lancer l'app directement
          await initRepartitionApp();

        } else {
          console.log('ğŸ¤· Aucun contexte trouvÃ© ou mode manquant, ouverture du modal de dÃ©marrage.');
          openStartupModal();
        }
      } catch (error) {
        console.error('Erreur du pont intelligent:', error);
        toast('Erreur de communication avec la console', 'error');
        openStartupModal(); // Fallback en cas d'erreur
      }
    }

    // =======================================================
    // INITIALISATION QUAND LE DOM EST PRÃŠT
    // =======================================================
    window.addEventListener('DOMContentLoaded', (event) => {
      console.log("DOM prÃªt. Tous les scripts peuvent s'exÃ©cuter.");

      // VÃ©rifier si une sauvegarde CACHE existe
      checkCache();

      // Appliquer les prÃ©fÃ©rences de lisibilitÃ© sauvegardÃ©es
      setTimeout(() => {
        if (window.applyLisibilitePreferences) {
          window.applyLisibilitePreferences();
        }
      }, 500);

      // GESTION DU MODAL DE DÃ‰MARRAGE
      const startupModal = document.getElementById('startupModal');
      const closeStartupModalBtn = document.getElementById('closeStartupModal');

      if (closeStartupModalBtn && startupModal) {
        closeStartupModalBtn.addEventListener('click', () => {
          startupModal.classList.add('hidden');
        });

        // La protection par mot de passe est gÃ©rÃ©e plus bas (ligne ~4287)
      }
      // =======================================================
      // 1.4.5 FONCTION GLOBALE POUR ANIMATIONS DES DROPDOWNS
      // =======================================================
      window.toggleDropdown = function (dropdown, button) {
        if (!dropdown) return;

        const isHidden = dropdown.classList.contains('hidden');

        if (isHidden) {
          // Ouvrir avec animation
          dropdown.classList.remove('hidden');
          // Force reflow
          void dropdown.offsetWidth;
          requestAnimationFrame(() => {
            dropdown.classList.add('show');
          });
        } else {
          // Fermer avec animation
          dropdown.classList.remove('show');
          setTimeout(() => {
            dropdown.classList.add('hidden');
          }, 150); // Correspond Ã  la durÃ©e de transition CSS
        }
      };

      window.closeAllDropdowns = function () {
        const dropdowns = document.querySelectorAll('.dropdown-menu');
        dropdowns.forEach(dropdown => {
          dropdown.classList.remove('show');
          setTimeout(() => {
            dropdown.classList.add('hidden');
          }, 150);
        });
      };

      // =======================================================
      // 1.5 GESTION DU MENU RÃ‰GLER (DROPDOWN)
      // =======================================================
      (function () {
        const btnRegler = document.getElementById('btnRegler');
        const dropdown = document.getElementById('dropdownRegler');

        if (!btnRegler || !dropdown) {
          console.warn('Menu RÃ©gler non trouvÃ©');
          return;
        }

        // Toggle dropdown avec positionnement dynamique et animation
        btnRegler.addEventListener('click', (e) => {
          e.stopPropagation();

          // Fermer tous les autres dropdowns (sauf celui-ci)
          document.querySelectorAll('.dropdown-menu').forEach(dd => {
            if (dd !== dropdown && !dd.classList.contains('hidden')) {
              dd.classList.remove('show');
              setTimeout(() => dd.classList.add('hidden'), 150);
            }
          });

          // Positionner le dropdown sous le bouton
          const rect = btnRegler.getBoundingClientRect();
          dropdown.style.top = `${rect.bottom + 8}px`;
          dropdown.style.left = `${rect.left}px`;

          // Toggle avec animation
          toggleDropdown(dropdown, btnRegler);
        });

        // EmpÃªcher la fermeture au clic interne
        dropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Fermer au clic extÃ©rieur
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && e.target !== btnRegler) {
            dropdown.classList.remove('show');
            setTimeout(() => dropdown.classList.add('hidden'), 150);
          }
        });

        // === CÃ‚BLAGE DES BOUTONS ===

        // 1. Mode Permutation (toggle)
        const btnSwapMainMenu = document.getElementById('btnSwapMainMenu');
        const swapModeIndicator = document.getElementById('swapModeIndicator');

        if (btnSwapMainMenu) {
          btnSwapMainMenu.addEventListener('click', () => {
            // Appeler la fonction existante de swap
            if (window.toggleSwapMode) {
              window.toggleSwapMode();
            } else {
              // Fallback si la fonction n'existe pas encore
              STATE.swapMode = !STATE.swapMode;
              swapModeIndicator.textContent = STATE.swapMode ? 'ON' : 'OFF';
              swapModeIndicator.classList.toggle('bg-green-500', STATE.swapMode);
              swapModeIndicator.classList.toggle('text-white', STATE.swapMode);
              swapModeIndicator.classList.toggle('bg-gray-200', !STATE.swapMode);
              swapModeIndicator.classList.toggle('text-gray-600', !STATE.swapMode);

              document.body.classList.toggle('swap-mode', STATE.swapMode);
              toast(STATE.swapMode ? 'â†”ï¸ Mode Permutation activÃ©' : 'â†”ï¸ Mode Permutation dÃ©sactivÃ©', 'info');
            }
          });
        }

        // 2. Annuler (Undo)
        const btnUndoQuick = document.getElementById('btnUndoQuick');
        const btnUndo = document.getElementById('btnUndo'); // Ancien bouton dans ParamÃ¨tres

        if (btnUndoQuick) {
          // L'Ã©vÃ©nement click est dÃ©jÃ  dÃ©fini dans le HTML (onclick="window.undo()")
          // Mais on peut sÃ©curiser l'Ã©tat disabled ici

          // Synchroniser l'Ã©tat disabled avec l'ancien bouton OU directement avec STATE
          if (btnUndo) {
            const observer = new MutationObserver(() => {
              btnUndoQuick.disabled = btnUndo.disabled;
            });
            observer.observe(btnUndo, { attributes: true, attributeFilter: ['disabled'] });
          } else {
            // Mise Ã  jour directe si l'ancien bouton n'existe pas
            setInterval(() => {
              if (STATE && STATE.history) {
                btnUndoQuick.disabled = STATE.history.length === 0;
              }
            }, 500);
          }
        }

        // 3. RÃ©tablir (Redo)
        const btnRedoQuick = document.getElementById('btnRedoQuick');
        const btnRedo = document.getElementById('btnRedo'); // Ancien bouton dans ParamÃ¨tres

        if (btnRedoQuick) {
          // Synchroniser l'Ã©tat disabled avec l'ancien bouton OU directement avec STATE
          if (btnRedo) {
            const observer = new MutationObserver(() => {
              btnRedoQuick.disabled = btnRedo.disabled;
            });
            observer.observe(btnRedo, { attributes: true, attributeFilter: ['disabled'] });
          } else {
            // Mise Ã  jour directe si l'ancien bouton n'existe pas
            setInterval(() => {
              if (STATE && STATE.future) {
                btnRedoQuick.disabled = STATE.future.length === 0;
              }
            }, 500);
          }
        }

        // 4. Historique
        const btnHistoryMenu = document.getElementById('btnHistoryMenu');

        if (btnHistoryMenu) {
          btnHistoryMenu.addEventListener('click', () => {
            if (window.toggleHistoryPanel) {
              window.toggleHistoryPanel();
            } else {
              toast('ğŸ“œ Panneau Historique ouvert', 'info');
            }
            dropdown.classList.add('hidden'); // Fermer le menu
          });
        }

        // 5. Sources (ouvre le modal de dÃ©marrage)
        const btnSourcesMenu = document.getElementById('btnSourcesMenu');

        if (btnSourcesMenu) {
          btnSourcesMenu.addEventListener('click', () => {
            if (window.openStartupModal) {
              window.openStartupModal({ force: true });
            } else {
              toast('âš ï¸ Modal Sources non disponible', 'warning');
            }
            dropdown.classList.add('hidden'); // Fermer le menu
          });
        }

        // === CÃ‚BLAGE DES RÃ‰GLAGES DE LISIBILITÃ‰ ===

        // Fonction pour appliquer les rÃ©glages
        function applyReglerSettings() {
          const fontSize = dropdown.querySelector('input[name="fontSize"]:checked')?.value || 'medium';
          const fontStyle = dropdown.querySelector('input[name="fontStyle"]:checked')?.value || 'normal';
          const contrast = dropdown.querySelector('input[name="contrast"]:checked')?.value || 'normal';
          const genderDisplay = dropdown.querySelector('input[name="genderDisplay"]:checked')?.value || 'colors';
          const showPrenoms = document.getElementById('showPrenoms')?.checked ?? true;
          const showClasse = document.getElementById('showClasseOrigine')?.checked ?? true;
          const showScores = document.getElementById('showScores')?.checked ?? true;

          const lisibiliteState = {
            size: fontSize,
            style: fontStyle,
            contrast: contrast,
            symbols: genderDisplay,
            showPrenoms: showPrenoms,
            showClasse: showClasse,
            showScores: showScores
          };
          localStorage.setItem('lisibilite-preferences', JSON.stringify(lisibiliteState));

          if (window.applyLisibilitePreferences) {
            window.applyLisibilitePreferences();
          }
        }

        // Connecter les checkboxes
        ['showPrenoms', 'showClasseOrigine', 'showScores'].forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', applyReglerSettings);
          }
        });

        // Connecter les radios pour appliquer en temps rÃ©el
        dropdown.querySelectorAll('input[type="radio"]').forEach(radio => {
          radio.addEventListener('change', () => {
            applyReglerSettings();
          });
        });

        // PrÃ©rÃ©glages
        document.getElementById('presetProjection')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'medium');
          setRadioValue('fontStyle', 'bold');
          setRadioValue('genderDisplay', 'symbols');
          const whiteBackground = document.getElementById('whiteBackground');
          if (whiteBackground) {
            whiteBackground.checked = true;
            whiteBackground.dispatchEvent(new Event('change'));
          }
          applyReglerSettings();
          toast('ğŸ“½ï¸ Mode Projection activÃ©', 'success');
        });

        document.getElementById('presetImpression')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'small');
          setRadioValue('fontStyle', 'normal');
          setRadioValue('contrast', 'normal');
          setRadioValue('genderDisplay', 'colors');
          const whiteBackground = document.getElementById('whiteBackground');
          if (whiteBackground) {
            whiteBackground.checked = false;
            whiteBackground.dispatchEvent(new Event('change'));
          }
          applyReglerSettings();
          toast('ğŸ–¨ï¸ Mode Impression activÃ©', 'success');
        });

        document.getElementById('presetAccessibilite')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'xlarge');
          setRadioValue('fontStyle', 'bold');
          setRadioValue('contrast', 'max');
          setRadioValue('genderDisplay', 'both');
          applyReglerSettings();
          toast('â™¿ Mode AccessibilitÃ© activÃ©', 'success');
        });

        // RÃ©initialiser
        document.getElementById('btnResetReglages')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'medium');
          setRadioValue('fontStyle', 'normal');
          setRadioValue('contrast', 'normal');
          setRadioValue('genderDisplay', 'colors');

          const showGenderBadges = document.getElementById('showGenderBadges');
          if (showGenderBadges) {
            showGenderBadges.checked = false;
            showGenderBadges.dispatchEvent(new Event('change'));
          }

          const whiteBackground = document.getElementById('whiteBackground');
          if (whiteBackground) {
            whiteBackground.checked = false;
            whiteBackground.dispatchEvent(new Event('change'));
          }

          document.getElementById('showPrenoms').checked = true;
          document.getElementById('showClasseOrigine').checked = true;
          document.getElementById('showScores').checked = true;

          applyReglerSettings();
          toast('ğŸ”„ RÃ©glages rÃ©initialisÃ©s', 'info');
        });

        // Plein Ã©cran
        document.getElementById('btnPleinEcran')?.addEventListener('click', () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
            toast('â›¶ Mode plein Ã©cran activÃ©', 'info');
          } else {
            document.exitFullscreen();
            toast('â›¶ Mode plein Ã©cran dÃ©sactivÃ©', 'info');
          }
        });

        // Mode sombre
        document.getElementById('btnModeSombre')?.addEventListener('click', (e) => {
          e.stopPropagation();
          document.body.classList.toggle('dark-mode');
          const isDark = document.body.classList.contains('dark-mode');
          localStorage.setItem('darkMode', isDark);
          toast(isDark ? 'ğŸŒ™ Mode sombre activÃ©' : 'â˜€ï¸ Mode clair activÃ©', 'info');
        });

        // Zoom cartes
        document.getElementById('btnZoomCartes')?.addEventListener('click', () => {
          const cards = document.querySelectorAll('.student-card');
          const isZoomed = cards[0]?.style.transform === 'scale(1.1)';
          cards.forEach(card => {
            card.style.transform = isZoomed ? '' : 'scale(1.1)';
            card.style.transition = 'transform 0.2s';
          });
          toast(isZoomed ? 'ğŸ” Zoom dÃ©sactivÃ©' : 'ğŸ” Zoom activÃ©', 'info');
        });

        // Helper pour dÃ©finir un radio
        function setRadioValue(name, value) {
          const radio = dropdown.querySelector(`input[name="${name}"][value="${value}"]`);
          if (radio) {
            radio.checked = true;
            const label = radio.closest('label');
            if (label) {
              dropdown.querySelectorAll(`input[name="${name}"]`).forEach(r => {
                const l = r.closest('label');
                if (l) {
                  l.classList.remove('bg-blue-50', 'border-blue-500', 'dark:bg-blue-900/30');
                  const s = l.querySelector('span');
                  if (s) s.classList.remove('text-blue-700');
                }
              });
              label.classList.add('bg-blue-50', 'border-blue-500', 'dark:bg-blue-900/30');
              const span = label.querySelector('span');
              if (span) span.classList.add('text-blue-700');
            }
          }
        }

        // Charger les prÃ©fÃ©rences au dÃ©marrage
        const saved = localStorage.getItem('lisibilite-preferences');
        if (saved) {
          const prefs = JSON.parse(saved);
          setRadioValue('fontSize', prefs.size || 'medium');
          setRadioValue('fontStyle', prefs.style || 'normal');
          setRadioValue('contrast', prefs.contrast || 'normal');
          setRadioValue('genderDisplay', prefs.symbols || 'colors');
        }

      })();
      // =======================================================
      // FONCTION GLOBALE POUR APPLIQUER LES PRÃ‰FÃ‰RENCES DE LISIBILITÃ‰
      // =======================================================
      window.applyLisibilitePreferences = function () {
        const saved = localStorage.getItem('lisibilite-preferences');
        if (!saved) return;

        const prefs = JSON.parse(saved);

        // Appliquer la taille des noms
        const studentCards = document.querySelectorAll('.student-card');
        studentCards.forEach(card => {
          // Supprimer toutes les classes de taille
          card.classList.remove('font-size-small', 'font-size-medium', 'font-size-large', 'font-size-xlarge');
          // Ajouter la nouvelle classe
          if (prefs.size) {
            card.classList.add(`font-size-${prefs.size}`);
          }
        });

        // Appliquer le style des noms
        studentCards.forEach(card => {
          // Supprimer toutes les classes de style
          card.classList.remove('font-style-normal', 'font-style-bold', 'font-style-highlight', 'font-style-outline');
          // Ajouter la nouvelle classe
          if (prefs.style) {
            card.classList.add(`font-style-${prefs.style}`);
          }
        });

        // Appliquer le contraste au body
        document.body.classList.remove('contrast-normal', 'contrast-high', 'contrast-max');
        if (prefs.contrast) {
          document.body.classList.add(`contrast-${prefs.contrast}`);
        }

        // Appliquer l'affichage des genres
        studentCards.forEach(card => {
          card.classList.remove('gender-colors', 'gender-symbols', 'gender-both');
          if (prefs.symbols) {
            card.classList.add(`gender-${prefs.symbols}`);
          }

        });
        // Appliquer l'affichage/masquage des prÃ©noms
        if (prefs.showPrenoms !== undefined) {
          const allNames = document.querySelectorAll('.student-fullname, .student-simple-name');
          allNames.forEach(nameEl => {
            const card = nameEl.closest('.student-card');
            if (!card || !card.dataset.id) return;

            const eleve = STATE && STATE.students ? STATE.students[card.dataset.id] : null;
            if (!eleve) return;

            if (prefs.showPrenoms) {
              // Afficher nom + prÃ©nom
              if (typeof simplifierNomComplet === 'function') {
                nameEl.textContent = simplifierNomComplet(eleve.nom, eleve.prenom);
              } else {
                nameEl.textContent = eleve.prenom ? eleve.nom + ' ' + eleve.prenom : eleve.nom;
              }
            } else {
              // Afficher nom uniquement
              nameEl.textContent = eleve.nom;
            }
          });
        }

        // Appliquer l'affichage/masquage de la classe d'origine
        if (prefs.showClasse !== undefined) {
          const sourceElements = document.querySelectorAll('.source-class');
          sourceElements.forEach(el => {
            el.style.display = prefs.showClasse ? '' : 'none';
          });
        }

        // Appliquer l'affichage/masquage des scores
        if (prefs.showScores !== undefined) {
          const scoresElements = document.querySelectorAll('.scores');
          scoresElements.forEach(el => {
            el.style.display = prefs.showScores ? '' : 'none';
          });
        }
      };

      // Appliquer les prÃ©fÃ©rences sauvegardÃ©es au dÃ©marrage
      if (typeof window.applyLisibilitePreferences === 'function') {
        setTimeout(() => window.applyLisibilitePreferences(), 200);
      }


      // =======================================================
      // 1.6.5 FONCTIONS CENTRALISÃ‰ES POUR LE PANNEAU STATS
      // =======================================================
      window.openStatsPanel = function () {
        const statsPanel = document.getElementById('statsPanel');
        const floatClose = document.getElementById('statsFloatingClose');

        if (!statsPanel) return;

        // Animation synchronisÃ©e
        requestAnimationFrame(() => {
          // 1. DÃ©finir la largeur du panneau AVANT de l'afficher
          const panelWidth = 600; // Largeur par dÃ©faut
          document.documentElement.style.setProperty('--stats-width', panelWidth + 'px');

          // 2. Ajouter la classe pour prÃ©parer la grille
          document.body.classList.add('stats-open');

          // 3. Afficher le panneau avec animation
          setTimeout(() => {
            statsPanel.classList.remove('translate-x-full');

            // Afficher le bouton flottant
            if (floatClose) {
              floatClose.classList.remove('hidden');
            }

            // Initialiser les graphiques si pas encore fait
            if (typeof chartCommunication === 'undefined' || !chartCommunication) {
              if (typeof initCharts === 'function') {
                initCharts();
              }
            }

            if (typeof updateCharts === 'function') {
              updateCharts();
            }

          }, 50);
        });
      };

      window.closeStatsPanel = function () {
        const statsPanel = document.getElementById('statsPanel');
        const floatClose = document.getElementById('statsFloatingClose');

        if (!statsPanel) return;

        // Slide out
        statsPanel.classList.add('translate-x-full');
        document.body.classList.remove('stats-open');

        // Masquer le bouton flottant
        if (floatClose) {
          floatClose.classList.add('hidden');
        }

      };

      // =======================================================
      // 1.6 GESTION DU MENU Ã‰DITER (DROPDOWN)
      // =======================================================
      (function () {
        const btnEditer = document.getElementById('btnEditer');
        const dropdown = document.getElementById('dropdownEditer');

        if (!btnEditer || !dropdown) {
          console.warn('Menu Ã‰diter non trouvÃ©');
          return;
        }

        // Toggle dropdown avec positionnement dynamique et animation
        btnEditer.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();

          // Fermer tous les autres dropdowns (sauf celui-ci)
          document.querySelectorAll('.dropdown-menu').forEach(dd => {
            if (dd !== dropdown && !dd.classList.contains('hidden')) {
              dd.classList.remove('show');
              setTimeout(() => dd.classList.add('hidden'), 150);
            }
          });

          // Positionner le dropdown sous le bouton
          const rect = btnEditer.getBoundingClientRect();
          dropdown.style.top = `${rect.bottom + 8}px`;
          dropdown.style.left = `${rect.left}px`;

          // Toggle avec animation
          if (window.toggleDropdown) {
            toggleDropdown(dropdown, btnEditer);
          } else {
            dropdown.classList.toggle('hidden');
          }
        });

        // EmpÃªcher la fermeture au clic interne
        dropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Fermer au clic extÃ©rieur
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && e.target !== btnEditer) {
            dropdown.classList.remove('show');
            setTimeout(() => dropdown.classList.add('hidden'), 150);
          }
        });

      })();

      // =======================================================
      // 1.7 GESTION DU MENU COMPARER (DROPDOWN)
      // =======================================================
      (function () {
        const btnComparer = document.getElementById('btnComparer');
        const dropdown = document.getElementById('dropdownComparer');

        if (!btnComparer || !dropdown) {
          console.warn('Menu Comparer non trouvÃ©');
          return;
        }

        // Toggle dropdown avec positionnement dynamique
        btnComparer.addEventListener('click', (e) => {
          e.stopPropagation();

          const statsPanel = document.getElementById('statsPanel');
          const rect = btnComparer.getBoundingClientRect();

          // 1. Si les stats sont OUVERTES â†’ on les FERME (panic button)
          if (statsPanel && !statsPanel.classList.contains('translate-x-full')) {
            closeStatsPanel();

            // Refermer le petit dropdown si besoin
            dropdown.classList.add('hidden');

            // AccessibilitÃ© propre
            btnComparer.setAttribute('aria-expanded', 'false');

            return;
          }

          // 2. Sinon : comportement normal â†’ toggle du menu Comparer
          dropdown.style.top = `${rect.bottom + 8}px`;
          dropdown.style.left = `${rect.left}px`;
          dropdown.classList.toggle('hidden');

          btnComparer.setAttribute(
            'aria-expanded',
            dropdown.classList.contains('hidden') ? 'false' : 'true'
          );
        });

        // EmpÃªcher la fermeture au clic interne
        dropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Fermer au clic extÃ©rieur
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && e.target !== btnComparer) {
            dropdown.classList.add('hidden');
          }
        });

        // === CÃ‚BLAGE DES BOUTONS ===

        // 1. Statistiques (ouvre le panneau stats en accordÃ©on)
        const btnStatsMenu = document.getElementById('btnStatsMenu');

        if (btnStatsMenu) {
          btnStatsMenu.addEventListener('click', () => {
            const panel = document.getElementById('statsPanel');

            if (!panel) {
              toast('âš ï¸ Panneau statistiques non disponible', 'warning');
              return;
            }

            // Fermer le menu
            dropdown.classList.add('hidden');

            // Utiliser la fonction centralisÃ©e
            openStatsPanel();

            // Mettre Ã  jour aria-expanded
            btnComparer.setAttribute('aria-expanded', 'true');

            toast('ğŸ“Š Panneau statistiques ouvert', 'info');
          });
        }

        // 2. Tableaux de bord analytiques
        const btnAnalyticsMenu = document.getElementById('btnAnalyticsMenu');

        if (btnAnalyticsMenu) {
          btnAnalyticsMenu.addEventListener('click', () => {
            if (window.openAnalyticsDashboard) {
              window.openAnalyticsDashboard();
            } else {
              toast('âš ï¸ Tableaux de bord analytiques non disponibles', 'warning');
            }
            dropdown.classList.add('hidden'); // Fermer le menu
          });
        }

      })();

      // =======================================================
      // 1.7.5 BRANCHEMENT DU BOUTON FLOTTANT STATS + GESTION Ã‰CHAP
      // =======================================================
      (function () {
        // Brancher le bouton flottant "Fermer âœ•"
        const statsFloatingClose = document.getElementById('statsFloatingClose');
        if (statsFloatingClose) {
          statsFloatingClose.addEventListener('click', () => {
            closeStatsPanel();
          });
        }

        // Fonction globale pour toggle la densitÃ© du header
        window.toggleHeaderDensity = function () {
          document.body.classList.toggle('header-xl');

          // Sauvegarder la prÃ©fÃ©rence
          if (document.body.classList.contains('header-xl')) {
            localStorage.setItem('headerDensity', 'xl');
            console.log('ğŸ–¥ï¸ Mode confort activÃ© (header XL)');
          } else {
            localStorage.setItem('headerDensity', 'compact');
            console.log('ğŸ“½ï¸ Mode compact activÃ© (rÃ©union/vidÃ©oprojecteur)');
          }
        };

        // Charger la prÃ©fÃ©rence sauvegardÃ©e au dÃ©marrage
        const savedDensity = localStorage.getItem('headerDensity');
        if (savedDensity === 'xl') {
          document.body.classList.add('header-xl');
        }

        // Raccourci clavier Alt+D pour toggle la densitÃ©
        document.addEventListener('keydown', (e) => {
          if (e.altKey && (e.key === 'd' || e.key === 'D')) {
            e.preventDefault();
            toggleHeaderDensity();
          }
        });

        // Gestion globale de la touche Ã‰chap
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            const reglerMenu = document.getElementById('dropdownRegler');
            const comparerMenu = document.getElementById('dropdownComparer');
            const editerMenu = document.getElementById('dropdownEditer');
            const statsPanel = document.getElementById('statsPanel');

            // Fermer le menu RÃ©gler
            if (reglerMenu && !reglerMenu.classList.contains('hidden')) {
              reglerMenu.classList.add('hidden');
              const btnRegler = document.getElementById('btnRegler');
              if (btnRegler) {
                btnRegler.setAttribute('aria-expanded', 'false');
              }
            }

            // Fermer le menu Comparer (le petit dropdown Comparer)
            if (comparerMenu && !comparerMenu.classList.contains('hidden')) {
              comparerMenu.classList.add('hidden');
              const btnComparer = document.getElementById('btnComparer');
              if (btnComparer) {
                btnComparer.setAttribute('aria-expanded', 'false');
              }
            }

            // Fermer le menu Ã‰diter
            if (editerMenu && !editerMenu.classList.contains('hidden')) {
              editerMenu.classList.add('hidden');
              const btnEditer = document.getElementById('btnEditer');
              if (btnEditer) {
                btnEditer.setAttribute('aria-expanded', 'false');
              }
            }

            // Fermer le panneau stats
            if (statsPanel && !statsPanel.classList.contains('translate-x-full')) {
              closeStatsPanel();
            }
          }
        });
      })();

      // =======================================================
      // 1.8 GESTION DU MENU ADMIN
      // =======================================================
      function initAdminMenu() {
        const adminRoot = document.getElementById('dropdownAdmin');
        const btnAdmin = document.getElementById('btnAdmin');
        if (!adminRoot || !btnAdmin) return;

        // Supprimer les doublons Ã©ventuels de #dropdownAdmin
        document.querySelectorAll('#dropdownAdmin').forEach((n, i) => { if (i > 0) n.remove(); });
        adminRoot.setAttribute('data-menu-root', '');

        const q = sel => adminRoot.querySelector(sel);
        const lockMsg = q('#adminLockMessage');
        const content = q('#adminContent');
        const btnUnlock = q('#btnUnlockAdmin');
        let btnLock = q('#btnLockAdmin');
        const status = document.getElementById('adminStatusIndicator');

        // Ã‰tat initial : toujours verrouillÃ© au dÃ©marrage (sÃ©curitÃ©)
        let isAdminUnlocked = false;
        localStorage.removeItem('adminUnlocked');
        localStorage.removeItem('adminForceMode');
        if (window.STATE) window.STATE.adminMode = false;

        function paintUI() {
          if (isAdminUnlocked) {
            lockMsg && lockMsg.classList.add('hidden');
            content && content.classList.remove('hidden');
            status && (status.textContent = 'ON', status.classList.add('text-white', 'font-bold'));
            btnAdmin.classList.remove('bg-red-600', 'hover:bg-red-700');
            btnAdmin.classList.add('bg-green-700', 'text-white', 'hover:bg-green-800');
          } else {
            lockMsg && lockMsg.classList.remove('hidden');
            content && content.classList.add('hidden');
            status && (status.textContent = 'OFF', status.classList.remove('text-white', 'font-bold'));
            btnAdmin.classList.remove('bg-green-700', 'hover:bg-green-800');
            btnAdmin.classList.add('bg-red-600', 'text-white', 'hover:bg-red-700');
          }
        }
        paintUI();

        // Menu fermÃ© au dÃ©marrage
        adminRoot.classList.add('hidden', 'opacity-0', 'scale-95');

        function openMenu() {
          adminRoot.classList.remove('hidden');
          void adminRoot.offsetWidth;
          requestAnimationFrame(() => {
            adminRoot.classList.remove('opacity-0', 'scale-95');
            adminRoot.classList.add('opacity-100', 'scale-100');
          });
        }

        function closeMenu() {
          adminRoot.classList.remove('opacity-100', 'scale-100');
          adminRoot.classList.add('opacity-0', 'scale-95');
          setTimeout(() => adminRoot.classList.add('hidden'), 200);
        }

        // Toggle du dropdown
        btnAdmin.addEventListener('click', (e) => {
          e.stopPropagation();
          const rect = btnAdmin.getBoundingClientRect();
          adminRoot.style.top = `${rect.bottom + 8}px`;
          adminRoot.style.left = `${rect.right - 320}px`;
          adminRoot.style.right = 'auto';
          adminRoot.classList.contains('hidden') ? openMenu() : closeMenu();
        });

        document.addEventListener('click', (e) => {
          if (!adminRoot.contains(e.target) && e.target !== btnAdmin && !adminRoot.classList.contains('hidden')) {
            closeMenu();
          }
        });
        adminRoot.addEventListener('click', e => e.stopPropagation());

        // Mot de passe
        const passwordInput = q('#adminPasswordInput');
        const passwordError = q('#adminPasswordError');
        const btnToggleVisibility = q('#btnTogglePasswordVisibility');

        if (btnToggleVisibility && passwordInput) {
          btnToggleVisibility.addEventListener('click', () => {
            const isPassword = passwordInput.type === 'password';
            passwordInput.type = isPassword ? 'text' : 'password';
            btnToggleVisibility.querySelector('i').className = isPassword ? 'fas fa-eye-slash' : 'fas fa-eye';
          });
        }

        async function checkPassword(pwd) {
          if (typeof google !== 'undefined' && google.script?.run?.getAdminPasswordFromConfig) {
            return new Promise((resolve) => {
              google.script.run
                .withSuccessHandler(configPwd => resolve(pwd === configPwd || (CONFIG && pwd === CONFIG.adminPassword)))
                .withFailureHandler(() => resolve(CONFIG && pwd === CONFIG.adminPassword))
                .getAdminPasswordFromConfig();
            });
          }
          return CONFIG && pwd === CONFIG.adminPassword;
        }

        async function unlockFlow() {
          const pwd = passwordInput ? passwordInput.value.trim() : '';
          if (!pwd) {
            passwordError && (passwordError.textContent = 'Veuillez entrer un mot de passe');
            passwordError && passwordError.classList.remove('hidden');
            passwordInput && passwordInput.classList.add('border-red-500');
            return;
          }

          if (await checkPassword(pwd)) {
            isAdminUnlocked = true;
            localStorage.setItem('adminUnlocked', 'true');
            paintUI();
            closeMenu();
            toast('Mode Admin activÃ©', 'success');
            passwordInput && (passwordInput.value = '');
            passwordError && passwordError.classList.add('hidden');
            passwordInput && passwordInput.classList.remove('border-red-500');
          } else {
            passwordError && (passwordError.textContent = 'Mot de passe incorrect');
            passwordError && passwordError.classList.remove('hidden');
            passwordInput && passwordInput.classList.add('border-red-500');
            passwordInput && passwordInput.select();
          }
        }

        btnUnlock && btnUnlock.addEventListener('click', (e) => { e.preventDefault(); unlockFlow(); });
        passwordInput && passwordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); unlockFlow(); } });
        passwordInput && passwordInput.addEventListener('input', () => {
          passwordError && passwordError.classList.add('hidden');
          passwordInput.classList.remove('border-red-500');
        });

        // Bouton Verrouiller (crÃ©Ã© si absent)
        if (!btnLock) {
          btnLock = document.createElement('button');
          btnLock.id = 'btnLockAdmin';
          btnLock.className = 'w-full px-4 py-2 my-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors';
          btnLock.innerHTML = '<i class="fas fa-lock mr-2"></i> Verrouiller le menu Admin';
          content && content.appendChild(btnLock);
        }
        btnLock.addEventListener('click', () => {
          localStorage.removeItem('adminUnlocked');
          localStorage.removeItem('adminForceMode');
          if (window.STATE) window.STATE.adminMode = false;
          isAdminUnlocked = false;
          paintUI();
          adminRoot.classList.add('hidden');
          toast('Mode Admin verrouillÃ©', 'info');
        });

        // AccordÃ©on scopÃ©
        window.toggleSection = window.toggleSection || function (key, el) {
          const root = el?.closest('[data-menu-root]') || document;
          const section = root.querySelector(`[data-section-id="${key}"]`);
          const body = section?.querySelector('.section-body') || section;
          const icon = section?.querySelector('.section-icon') || el?.querySelector('.fa-chevron-down');
          if (!body) return;
          body.classList.toggle('hidden');
          icon && icon.classList.toggle('rotate-180');
        };

        // CÃ¢blage des boutons Admin
        const wireButton = (id, handler) => {
          const btn = q(`#${id}`);
          btn && btn.addEventListener('click', () => { handler(); adminRoot.classList.add('hidden'); });
        };

        wireButton('btnSourcesAdmin', () => window.openStartupModal && openStartupModal({ force: true }));
        wireButton('btnOptimizationAdmin', () => {
          if (typeof OptimizationPanel !== 'undefined' && OptimizationPanel.open) OptimizationPanel.open();
          else if (window.openOptimizationPanel) window.openOptimizationPanel();
          else toast('Module d\'optimisation non chargÃ©', 'warning');
        });
        wireButton('menuDarkModeAdmin', () => window.toggleDarkMode && toggleDarkMode());
        wireButton('menuZoomAdmin', () => {
          const cards = document.querySelectorAll('.student-card');
          const isZoomed = cards[0]?.style.transform === 'scale(1.1)';
          cards.forEach(card => card.style.transform = isZoomed ? 'scale(1)' : 'scale(1.1)');
          toast(isZoomed ? 'Zoom dÃ©sactivÃ©' : 'Zoom activÃ©', 'info');
        });
        wireButton('menuFullscreenAdmin', () => {
          document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen();
        });
        wireButton('menuImportScoresAdmin', () => window.openImportScoresModal && openImportScoresModal());
        wireButton('btnExportAdmin', () => window.exportData && exportData());
        wireButton('menuRulesModal', () => window.openRulesModal && openRulesModal());

        // Mode Force Admin
        const toggleForce = q('#toggleAdminForceMode');
        if (toggleForce) {
          toggleForce.checked = false;

          toggleForce.addEventListener('change', () => {
            const isOn = toggleForce.checked;
            if (window.STATE) window.STATE.adminMode = isOn;
            localStorage.setItem('adminForceMode', isOn);

            toast(isOn
              ? 'Mode Force activÃ© - Contraintes ignorÃ©es'
              : 'Mode Force dÃ©sactivÃ© - Contraintes respectÃ©es',
              isOn ? 'warning' : 'success'
            );

            if (typeof renderColumns === 'function') renderColumns();
          });
        }
      }

      // Initialisation diffÃ©rÃ©e pour garantir le rendu DOM
      setTimeout(initAdminMenu, 0);

      // =======================================================
      // 2. LOGIQUE PRINCIPALE DE L'APPLICATION
      // =======================================================

      // TOUT votre code principal va ici, de "const CONFIG = ..." jusqu'Ã  la fin
      const CONFIG = {
        adminPassword: 'admin123',
        animation: {
          duration: 150
        }
      };

      // ========== GESTIONNAIRE D'ERREURS ==========
      window.addEventListener('error', (e) => {
        console.error('Erreur capturÃ©e:', e.message);
        e.preventDefault();
      });

      /* ---------- helper : Ã©lÃ¨ve vraiment valide --------- */
      function isValidStudent(e) {
        return e                     // objet prÃ©sent
          && e.id && e.id.trim()   // id non-vide
          && e.nom && e.nom.trim();/* au moins un NOM non-vide  */
      }




      // ========== MISE Ã€ JOUR DES STATISTIQUES ==========
      // Fonctions dÃ©jÃ  dÃ©finies plus haut



      // Fonction pour dÃ©placer automatiquement un groupe A
      function moveGroupA(eleveId, srcClasse, dstClasse) {
        const eleve = STATE.students[eleveId];
        if (!eleve.asso) return;

        const group = STATE.aGroups[`A${eleve.asso}`] || [];
        const movedMembers = [];

        // DÃ©placer tous les membres du groupe qui sont dans srcClasse
        group.forEach(memberId => {
          const memberCard = document.querySelector(`.student-card[data-id="${memberId}"]`);
          if (!memberCard) return;

          const memberClasse = memberCard.closest('.droppable-zone').dataset.classe;
          if (memberClasse === srcClasse) {
            const dstZone = document.querySelector(`.droppable-zone[data-classe="${dstClasse}"]`);
            if (dstZone) {
              dstZone.appendChild(memberCard);
              movedMembers.push(STATE.students[memberId].nom);
            }
          }
        });

        if (movedMembers.length > 1) {
          toast(`Groupe A${eleve.asso} dÃ©placÃ© : ${movedMembers.join(', ')}`, 'info');
        }
      }

      // ========== GESTION DES SWAPS - REMPLACEMENT COMPLET ==========
      // Remplacez TOUTE la section de gestion des swaps par ce code

      // Fonction pour vÃ©rifier si un swap est possible



      // Fonction pour gÃ©rer le clic sur une carte


      // Fonction pour activer/dÃ©sactiver le mode swap
      function toggleSwapMode() {
        STATE.swapMode = !STATE.swapMode;
        STATE.swapFirst = null;

        const btnSwapMain = document.getElementById('btnSwapMain');
        const sortables = document.querySelectorAll('.droppable-zone');

        if (STATE.swapMode) {
          if (btnSwapMain) {
            btnSwapMain.classList.add('active', 'btn-primary');
            btnSwapMain.classList.remove('btn-secondary');
            btnSwapMain.setAttribute('aria-pressed', 'true');
          }
          toast('ğŸ”„ Mode SWAP activÃ© - Cliquez sur deux Ã©lÃ¨ves pour les Ã©changer', 'info');

          // DÃ©sactiver le drag & drop
          sortables.forEach(zone => {
            const sortable = Sortable.get(zone);
            if (sortable) sortable.option('disabled', true);
          });
        } else {
          if (btnSwapMain) {
            btnSwapMain.classList.remove('active', 'btn-primary');
            btnSwapMain.classList.add('btn-secondary');
            btnSwapMain.setAttribute('aria-pressed', 'false');
          }

          // RÃ©activer le drag & drop
          sortables.forEach(zone => {
            const sortable = Sortable.get(zone);
            if (sortable) sortable.option('disabled', false);
          });

          // Nettoyer les sÃ©lections
          document.querySelectorAll('.student-card').forEach(card => {
            card.classList.remove('swap-mode');
          });
          document.querySelectorAll('.droppable-zone').forEach(zone => {
            zone.classList.remove('swap-target');
          });

          toast('Mode normal rÃ©tabli', 'info');
        }
      }
      // Exposer sur window pour les modules externes (bouton header, raccourcis)
      window.toggleSwapMode = toggleSwapMode;

      // S'assurer que performSwapAndClose est bien dÃ©fini pour la modal
      window.performSwapAndClose = function (id1, id2) {
        performSwap(id1, id2);

      }

      // ========== SMART SWAP - PHASE 7 ==========
      // Algorithme de suggestion d'Ã©change intelligent pour harmoniser les classes
      function calculateSmartSwapScore(classeName, targetClassStudents, globalStats) {
        // Reproduit la logique mathÃ©matique de Phase4_Ultimate en localJS
        const total = targetClassStudents.length;
        if (total === 0) return 10000;

        let score = 0;

        // 1. Statistiques globales (prÃ©-calculÃ©es, passÃ©es en paramÃ¨tre)
        const { globalRatioF, globalAvgCOM, globalAvgTRA, globalAvgPART } = globalStats;

        // 2. ParitÃ© (Poids 1000)
        const nbFilles = targetClassStudents.filter(s => s.sexe === 'F').length;
        const ratioF = nbFilles / total;
        score += Math.abs(ratioF - globalRatioF) * 1000;

        // 3. Constitution AcadÃ©mique (Poids 100/50)
        const avgCOM = targetClassStudents.reduce((acc, s) => acc + (s.scores?.COM || 2.5), 0) / total;
        const avgTRA = targetClassStudents.reduce((acc, s) => acc + (s.scores?.TRA || 2.5), 0) / total;
        const avgPART = targetClassStudents.reduce((acc, s) => acc + (s.scores?.PART || 2.5), 0) / total;

        score += Math.abs(avgCOM - globalAvgCOM) * 100;
        score += Math.abs(avgTRA - globalAvgTRA) * 100;
        score += Math.abs(avgPART - globalAvgPART) * 50;

        // 4. Ciblage Profils ExtrÃªmes (TÃªtes et Niv1)
        const isHead = (s) => (s.scores?.COM >= 4 || s.scores?.TRA >= 4) || ((s.scores?.COM + s.scores?.TRA + s.scores?.PART) / 3 >= 3.5);
        const isNiv1 = (s) => (s.scores?.COM <= 1 || s.scores?.TRA <= 1);

        const nbTetes = targetClassStudents.filter(isHead).length;
        const nbNiv1 = targetClassStudents.filter(isNiv1).length;

        if (nbTetes < 2) score += Math.pow(2 - nbTetes, 2) * 500; // headMin=2
        if (nbTetes > 6) score += (nbTetes - 6) * 200;            // headMax=6
        if (nbNiv1 > 4) score += Math.pow(nbNiv1 - 4, 3) * 100;  // niv1Max=4

        return score;
      }

      function findSwapSuggestions() {
        const suggestions = [];
        const classes = Object.keys(STATE.rules);

        // PrÃ©-calcul des statistiques globales (une seule fois au lieu de 5000x)
        const allStudents = Object.values(STATE.students).filter(Boolean);
        const globalTotal = allStudents.length;
        if (globalTotal === 0) return [];

        const globalStats = {
          globalRatioF: allStudents.filter(s => s.sexe === 'F').length / globalTotal,
          globalAvgCOM: allStudents.reduce((acc, s) => acc + (s.scores?.COM || 2.5), 0) / globalTotal,
          globalAvgTRA: allStudents.reduce((acc, s) => acc + (s.scores?.TRA || 2.5), 0) / globalTotal,
          globalAvgPART: allStudents.reduce((acc, s) => acc + (s.scores?.PART || 2.5), 0) / globalTotal
        };

        // Anti-freeze: Limiter Ã  2500 paires max s'il y a trop d'Ã©lÃ¨ves
        let operations = 0;
        const MAX_OPS = 2500;
        let maxReached = false;

        // Analyser chaque paire de classes
        for (let i = 0; i < classes.length && !maxReached; i++) {
          for (let j = i + 1; j < classes.length && !maxReached; j++) {
            const classe1 = classes[i];
            const classe2 = classes[j];

            const students1 = getCurrentClassContent(classe1).map(id => STATE.students[id]).filter(Boolean);
            const students2 = getCurrentClassContent(classe2).map(id => STATE.students[id]).filter(Boolean);

            // Score initial des deux classes combinÃ©es
            const scoreBefore = calculateSmartSwapScore(classe1, students1, globalStats) +
              calculateSmartSwapScore(classe2, students2, globalStats);

            // Croiser tous les Ã©lÃ¨ves des deux classes
            for (let s1 of students1) {
              if (maxReached) break;
              for (let s2 of students2) {
                if (operations++ > MAX_OPS) { maxReached = true; break; }

                // 1. VÃ©rifier les contraintes DURES (FIXE, ASSO, LV2, quotas) via canSwap
                const verif = canSwap(s1.id, s2.id);
                if (!verif.ok) continue;

                // 2. Simuler l'Ã©change
                const tempStudents1 = students1.filter(s => s.id !== s1.id).concat([s2]);
                const tempStudents2 = students2.filter(s => s.id !== s2.id).concat([s1]);

                // 3. Calculer le nouveau Score
                const scoreAfter = calculateSmartSwapScore(classe1, tempStudents1, globalStats) +
                  calculateSmartSwapScore(classe2, tempStudents2, globalStats);

                const gain = scoreBefore - scoreAfter;

                if (gain > 0.001) {
                  suggestions.push({
                    student1: s1,
                    student2: s2,
                    classe1: classe1,
                    classe2: classe2,
                    improvement: gain,
                    reason: 'Augmente l\'Harmonie Globale (' + (gain > 50 ? 'Fort' : 'LÃ©ger') + ')'
                  });
                }
              }
            }
          }
        }

        // Trier par amÃ©lioration dÃ©croissante
        suggestions.sort((a, b) => b.improvement - a.improvement);

        return suggestions.slice(0, 5); // Garder le Top 5 des meilleurs mouvements
      }

      // ========== ACTION UI : DECLENCHER L'ECHANGE INTELLIGENT ==========

      // Stocke la suggestion en cours pour l'appliquer/la rejeter
      let pendingSmartSwap = null;

      /**
       * Nettoie l'effet Spotlight et restaure l'Ã©tat normal
       */
      function dismissSmartSwap() {
        // Retirer dimmed de toutes les cartes
        document.querySelectorAll('.student-card').forEach(c => {
          c.classList.remove('dimmed', 'ring-4', 'ring-purple-500', 'ring-offset-2');
        });

        // Restaurer la barre d'instruction
        const instruction = document.getElementById('swapInstruction');
        if (instruction) {
          instruction.innerHTML = 'Cliquez un premier \u00e9l\u00e8ve...';
        }

        // Restaurer le bouton
        const btn = document.getElementById('btnSmartSwap');
        if (btn) btn.innerHTML = '<i class="fas fa-magic"></i> Sugg\u00e9rer l\'\u00c9change Id\u00e9al';

        pendingSmartSwap = null;
      }

      /**
       * Applique la suggestion Smart Swap en cours
       */
      function applySmartSwap() {
        if (!pendingSmartSwap) return;

        const { student1, student2 } = pendingSmartSwap;

        // Mesurer l'harmonie AVANT
        const harmonieBefore = (typeof computeHarmonieScore === 'function') ? computeHarmonieScore() : null;

        // Nettoyer le Spotlight avant le swap
        dismissSmartSwap();

        // ExÃ©cuter le swap via performSwap existant
        if (typeof performSwap === 'function') {
          performSwap(student1.id, student2.id);

          // Mesurer l'harmonie APRÃˆS (petit dÃ©lai pour laisser le DOM se mettre Ã  jour)
          setTimeout(() => {
            if (harmonieBefore && typeof computeHarmonieScore === 'function') {
              const harmonieAfter = computeHarmonieScore();
              const delta = harmonieAfter.score - harmonieBefore.score;
              const sign = delta >= 0 ? '+' : '';
              toast(
                'Ã‰change appliqu\u00e9 ! Harmonie : ' + harmonieBefore.score + '% \u2192 ' + harmonieAfter.score + '% (' + sign + delta + '%)',
                delta >= 0 ? 'success' : 'warning'
              );
            } else {
              toast('\u00c9change appliqu\u00e9 avec succ\u00e8s.', 'success');
            }
          }, 200);
        }
      }

      window.triggerSmartSwap = function () {
        const btn = document.getElementById('btnSmartSwap');
        if (btn) btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calcul...';

        // Petite pause pour laisser le DOM se rafraÃ®chir
        setTimeout(() => {
          // Mesurer l'harmonie actuelle pour afficher le delta
          const harmonieBefore = (typeof computeHarmonieScore === 'function') ? computeHarmonieScore() : null;

          const startTime = performance.now();
          const suggestions = findSwapSuggestions();
          const endTime = performance.now();
          console.log(`Smart Swap calcul\u00e9 en ${Math.round(endTime - startTime)}ms - ${suggestions.length} suggestion(s)`, suggestions);

          if (suggestions.length === 0) {
            toast('Aucun \u00e9change significatif trouv\u00e9 pour am\u00e9liorer l\'harmonie.', 'warning');
            if (btn) btn.innerHTML = '<i class="fas fa-magic"></i> Sugg\u00e9rer l\'\u00c9change Id\u00e9al';
            return;
          }

          const bestSwap = suggestions[0];
          pendingSmartSwap = bestSwap;

          // 1. Activer l'effet "OÃ¹ est Charlie" (Spotlight)
          document.querySelectorAll('.student-card').forEach(c => {
            c.classList.add('dimmed');
            c.classList.remove('ring-4', 'ring-purple-500', 'ring-offset-2');
          });

          // 2. Mettre en surbrillance les deux Ã©lus
          const card1 = document.querySelector(`.student-card[data-id="${bestSwap.student1.id}"]`);
          const card2 = document.querySelector(`.student-card[data-id="${bestSwap.student2.id}"]`);

          if (card1) { card1.classList.remove('dimmed'); card1.classList.add('ring-4', 'ring-purple-500', 'ring-offset-2'); }
          if (card2) { card2.classList.remove('dimmed'); card2.classList.add('ring-4', 'ring-purple-500', 'ring-offset-2'); }

          // 3. Scroll vers le premier Ã©lÃ¨ve en surbrillance
          if (card1) card1.scrollIntoView({ behavior: 'smooth', block: 'center' });

          // 4. Construire le message avec harmonie
          const nom1 = bestSwap.student1.nom + (bestSwap.student1.prenom ? ' ' + bestSwap.student1.prenom : '');
          const nom2 = bestSwap.student2.nom + (bestSwap.student2.prenom ? ' ' + bestSwap.student2.prenom : '');
          const harmonieLabel = harmonieBefore ? ' (Harmonie actuelle : ' + harmonieBefore.score + '%)' : '';

          // 5. Mettre Ã  jour la barre d'instruction avec boutons d'action
          const instruction = document.getElementById('swapInstruction');
          if (instruction) {
            instruction.innerHTML =
              '<span class="font-bold text-purple-700">Suggestion :</span> ' +
              'Inverser <b>' + nom1 + '</b> (' + bestSwap.classe1 + ') et <b>' + nom2 + '</b> (' + bestSwap.classe2 + ')' +
              harmonieLabel +
              ' <button onclick="applySmartSwap()" class="ml-3 px-3 py-0.5 bg-green-500 hover:bg-green-600 text-white text-xs font-bold rounded-full shadow transition-all hover:scale-105">' +
              '<i class="fas fa-check mr-1"></i>Appliquer</button>' +
              ' <button onclick="dismissSmartSwap()" class="ml-1 px-3 py-0.5 bg-slate-400 hover:bg-slate-500 text-white text-xs font-bold rounded-full shadow transition-all">' +
              '<i class="fas fa-times mr-1"></i>Ignorer</button>';
          }

          if (btn) btn.innerHTML = '<i class="fas fa-magic"></i> Suggestion trouv\u00e9e !';

        }, 50); // Fin timeout
      };

      window.dismissSmartSwap = dismissSmartSwap;
      window.applySmartSwap = applySmartSwap;



      // ========== GESTION UNDO/REDO ==========
      // Fonctions dÃ©jÃ  dÃ©finies plus haut

      // Le menu Admin est gÃ©rÃ© UNIQUEMENT par AdminMenuFix (ligne 3070)
      // Toute tentative d'appeler toggleAdminMode() sera bloquÃ©e par AdminMenuFix

      // ========== RECHERCHE ==========
      function setupSearch() {
        const searchInput = document.getElementById('search');

        if (!searchInput) return;

        searchInput.addEventListener('input', (e) => {
          const term = e.target.value.toLowerCase();
          STATE.searchTerm = term;

          document.querySelectorAll('.student-card').forEach(card => {
            const nameEl = card.querySelector('.student-fullname, .student-simple-name');
            if (!nameEl) return;

            const fullName = nameEl.textContent.toLowerCase();
            const match = !term || fullName.includes(term);

            card.style.display = match ? '' : 'none';
            card.classList.toggle('search-highlight', match && term);
          });
        });
      }



      // ========== FONCTIONS DE GESTION DES MODES ==========
      function openStartupModal(opts = {}) {
        const modal = document.getElementById('startupModal');
        const modalContent = document.getElementById('startupModalContent');
        if (!modal) return;

        // Si le tableau de rÃ©partition est dÃ©jÃ  affichÃ©, ne rien faire
        const board = document.getElementById('board');
        if (board && board.innerHTML.trim() !== '' && !(opts && opts.force)) {
          return;
        }

        // Afficher le modal avec animation fluide
        modal.classList.remove('hidden');

        // Animation d'entrÃ©e
        requestAnimationFrame(() => {
          modal.classList.remove('opacity-0');
          modal.classList.add('opacity-100');

          if (modalContent) {
            modalContent.classList.remove('scale-95', 'opacity-0');
            modalContent.classList.add('scale-100', 'opacity-100');
          }
        });

        checkCache(); // VÃ©rifier et afficher la derniÃ¨re sauvegarde automatique
      }



      // ========== FONCTIONS DE GESTION DES VUES ==========
      function toggleViewMode() {
        // Cycle: complete â†’ essential â†’ simple â†’ complete
        const modes = ['complete', 'essential', 'simple'];
        const currentIndex = modes.indexOf(STATE.viewMode);
        const nextIndex = (currentIndex + 1) % modes.length;
        STATE.viewMode = modes[nextIndex];

        localStorage.setItem('viewMode', STATE.viewMode);

        // Mettre Ã  jour les classes body
        document.body.classList.remove('simple-view', 'essential-view');
        if (STATE.viewMode === 'simple') {
          document.body.classList.add('simple-view');
        } else if (STATE.viewMode === 'essential') {
          document.body.classList.add('essential-view');
        }

        // Mettre Ã  jour le texte du bouton et aria-pressed
        const btn = document.getElementById('btnSimpleView');
        const textSpan = document.getElementById('viewModeText');
        if (btn && textSpan) {
          const modeLabels = {
            'complete': 'Essentielle',
            'essential': 'Simple',
            'simple': 'ComplÃ¨te'
          };
          textSpan.textContent = modeLabels[STATE.viewMode];
          // Mettre Ã  jour aria-pressed (true si mode diffÃ©rent de complete)
          btn.setAttribute('aria-pressed', STATE.viewMode !== 'complete');
        }

        // RecrÃ©er toutes les cartes pour appliquer la nouvelle vue
        document.querySelectorAll('.droppable-zone').forEach(zone => {
          const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
          zone.innerHTML = '';
          ids.forEach(id => {
            if (STATE.students && STATE.students[id]) {
              const card = createStudentCard(STATE.students[id]);
              if (card) zone.appendChild(card);
            }
          });
          setTimeout(() => adjustSimpleNamesFontSize(zone), 0);
        });
        if (window.applyLisibilitePreferences) {
          window.applyLisibilitePreferences();
        }
      }

      // Fonction adjustSimpleNamesFontSize dÃ©jÃ  dÃ©finie plus haut

      // ========== EXPORT DE LA DISPOSITION ==========
      // Fonction dÃ©jÃ  dÃ©finie plus haut

      // ========== EXPORT EXCEL ==========
      window.exportExcel = function () {
        const wb = XLSX.utils.book_new();

        // Feuille de rÃ©partition
        const data = [];
        document.querySelectorAll('.class-column').forEach(column => {
          const classe = column.querySelector('.classe-name').textContent;
          const cards = Array.from(column.querySelectorAll('.student-card'));

          cards.forEach(card => {
            const eleve = STATE.students[card.dataset.id];
            data.push({
              Classe: classe,
              Nom: eleve.nom,
              PrÃ©nom: eleve.prenom,
              Sexe: eleve.sexe,
              LV2: eleve.lv2,
              Option: eleve.opt,
              Dissociation: eleve.disso ? `D${ eleve.disso }` : '',
              Association: eleve.asso ? `A${ eleve.asso }` : '',
              'Score COM': eleve.scores.COM,
              'Score TRA': eleve.scores.TRA,
              'Score PART': eleve.scores.PART,
              'Score ABS': eleve.scores.ABS,
              'Classe origine': eleve.source,
              MobilitÃ©: eleve.mobilite
            });
          });
        });

        const ws = XLSX.utils.json_to_sheet(data);
        XLSX.utils.book_append_sheet(wb, ws, "RÃ©partition");

        // Feuille de statistiques
        const stats = [];
        document.querySelectorAll('.class-column').forEach(column => {
          const classe = column.querySelector('.classe-name').textContent;
          const count = column.querySelector('.count').textContent;
          const countF = column.querySelector('.count-f').textContent;
          const countM = column.querySelector('.count-m').textContent;

          stats.push({
            Classe: classe,
            'Total Ã©lÃ¨ves': count,
            Filles: countF,
            GarÃ§ons: countM,
            'Ratio F/M': `${ Math.round(countF / count * 100) } % / ${Math.round(countM / count * 100)
        }% `
          });
        });

        const wsStats = XLSX.utils.json_to_sheet(stats);
        XLSX.utils.book_append_sheet(wb, wsStats, "Statistiques");

        // TÃ©lÃ©charger
        const niveau = STATE.niveau.replace('Â°', 'e') || 'classes';
        XLSX.writeFile(wb, `repartition_${ niveau }_${ new Date().toISOString().split('T')[0] }.xlsx`);

        toast('Export Excel gÃ©nÃ©rÃ© avec succÃ¨s', 'success');
        closeExportModal();
      }

      // ========== EXPORT PDF ==========
      window.exportPDF = async function () {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');

        // Titre
        pdf.setFontSize(20);
        pdf.text(`RÃ©partition des Classes - ${ STATE.niveau } `, 105, 20, { align: 'center' });

        // Date
        pdf.setFontSize(12);
        pdf.text(new Date().toLocaleDateString('fr-FR'), 105, 30, { align: 'center' });

        let yPos = 50;

        // Pour chaque classe
        document.querySelectorAll('.class-column').forEach((column, index) => {
          if (yPos > 250) {
            pdf.addPage();
            yPos = 20;
          }

          const classe = column.querySelector('.classe-name').textContent;
          const count = column.querySelector('.count').textContent;
          const countF = column.querySelector('.count-f').textContent;
          const countM = column.querySelector('.count-m').textContent;

          // Titre de la classe
          pdf.setFontSize(16);
          pdf.setTextColor(91, 33, 182); // Primary color
          pdf.text(classe, 20, yPos);

          // Stats
          pdf.setFontSize(10);
          pdf.setTextColor(0, 0, 0);
          pdf.text(`Total: ${ count } Ã©lÃ¨ves(${ countF } filles, ${ countM } garÃ§ons)`, 60, yPos);

          yPos += 10;

          // Liste des Ã©lÃ¨ves
          const cards = Array.from(column.querySelectorAll('.student-card'));
          cards.forEach((card, i) => {
            if (yPos > 270) {
              pdf.addPage();
              yPos = 20;
            }

            const eleve = STATE.students[card.dataset.id];
            const text = `${ i + 1}.${ eleve.nom } ${ eleve.prenom } - ${ eleve.lv2 }${ eleve.opt ? '/' + eleve.opt : '' } `;
            pdf.text(text, 25, yPos);
            yPos += 5;
          });

          yPos += 10;
        }); // â† Fin de la boucle sur les colonnes

        // Ajouter les graphiques si le panel stats est ouvert
        if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
          pdf.addPage();
          pdf.setFontSize(16);
          pdf.text('Statistiques', 105, 20, { align: 'center' });

          // Capturer les graphiques
          const canvas1 = document.getElementById('chartStacked');
          if (canvas1) {
            const imgData1 = canvas1.toDataURL('image/png');
            pdf.addImage(imgData1, 'PNG', 20, 40, 170, 80);
          }

          const canvas2 = document.getElementById('chartDetailed');
          if (canvas2) {
            const imgData2 = canvas2.toDataURL('image/png');
            pdf.addImage(imgData2, 'PNG', 20, 130, 170, 80);
          }
        }

        const niveau = STATE.niveau.replace('Â°', 'e') || 'classes';
        pdf.save(`repartition_${ niveau }_${ new Date().toISOString().split('T')[0] }.pdf`);

        toast('Export PDF gÃ©nÃ©rÃ© avec succÃ¨s', 'success');
        closeExportModal();
      } // â† Fin correcte de la fonction exportPDF

      // ========== COMPARAISON AVANT/APRÃˆS ==========
      window.showComparison = function () {
        if (!STATE.originalData) {
          toast('Aucune donnÃ©e de comparaison disponible', 'warning');
          return; a
        }

        // CrÃ©er une modal de comparaison
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
        < div class="modal-content" style = "max-width: 1200px;" >
        <div class="modal-header">
          <h2 class="text-xl font-bold">Comparaison avant/aprÃ¨s rÃ©partition</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="comparison-container">
            <div class="comparison-side">
              <h3>Ã‰tat initial</h3>
              <div id="comparisonBefore"></div>
            </div>
            <div class="comparison-side">
              <h3>Ã‰tat actuel</h3>
              <div id="comparisonAfter"></div>
            </div>
          </div>
        </div>
      </div >
        `;

        document.body.appendChild(modal);

        // Remplir les donnÃ©es
        const beforeContainer = modal.querySelector('#comparisonBefore');
        const afterContainer = modal.querySelector('#comparisonAfter');

        // Ã‰tat initial
        STATE.originalData.forEach(group => {
          const div = document.createElement('div');
          div.className = 'mb-4';
          div.innerHTML = `
        < h4 class="font-bold" > ${ group.classe }</h4 >
        <p>Total: ${group.eleves.length} Ã©lÃ¨ves</p>
        <p>F/M: ${group.eleves.filter(e => e.sexe === 'F').length}/${group.eleves.filter(e => e.sexe === 'M').length}</p>
      `;
          beforeContainer.appendChild(div);
        });

        // Ã‰tat actuel
        document.querySelectorAll('.class-column').forEach(column => {
          const classe = column.querySelector('.classe-name').textContent;
          const count = column.querySelector('.count').textContent;
          const countF = column.querySelector('.count-f').textContent;
          const countM = column.querySelector('.count-m').textContent;

          const div = document.createElement('div');
          div.className = 'mb-4';
          div.innerHTML = `
        < h4 class="font-bold" > ${ classe }</h4 >
        <p>Total: ${count} Ã©lÃ¨ves</p>
        <p>F/M: ${countF}/${countM}</p>
      `;
          afterContainer.appendChild(div);
        });

        closeExportModal();
      }

      // ========== MODAL EXPORT ==========
      window.closeExportModal = function () {
        document.getElementById('exportModal').classList.add('hidden');
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('overlay').classList.remove('active');
      }

      // ========== Ã‰DITION DES RÃˆGLES ==========
      function openRulesModal() {
        const container = document.getElementById('rulesContainer');
        container.innerHTML = '';

        // Pour chaque classe
        Object.keys(STATE.rules).forEach(classe => {
          const rule = STATE.rules[classe];

          const div = document.createElement('div');
          div.className = 'mb-6 p-4 border rounded-lg';
          div.innerHTML = `
        < h3 class="font-bold text-lg mb-3" > ${ classe }</h3 >
          <div class="grid grid-cols-2 gap-4">
            <div class="form-group">
              <label class="form-label">CapacitÃ© maximale</label>
              <input type="number" class="form-control"
                data-classe="${classe}"
                data-field="capacity"
                value="${rule.capacity || 28}"
                min="1" max="35">
            </div>
            <div class="form-group">
              <label class="form-label">Quotas (format: OPT=nombre)</label>
              <textarea class="form-control"
                data-classe="${classe}"
                data-field="quotas"
                rows="3">${Object.entries(rule.quotas || {}).map(([k, v]) => `${k}=${v}`).join(', ')}</textarea>
            </div>
          </div>
      `;

          container.appendChild(div);
        });

        document.getElementById('rulesModal').classList.remove('hidden');
        document.getElementById('overlay').classList.remove('hidden');
        document.getElementById('overlay').classList.add('active');
      }

      window.closeRulesModal = function () {
        document.getElementById('rulesModal').classList.add('hidden');
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('overlay').classList.remove('active');
      }

      window.saveRules = async function () {
        const newRules = {};

        // Collecter les nouvelles rÃ¨gles
        document.querySelectorAll('#rulesContainer input, #rulesContainer textarea').forEach(input => {
          const classe = input.dataset.classe;
          const field = input.dataset.field;

          if (!newRules[classe]) {
            newRules[classe] = { capacity: 28, quotas: {} };
          }

          if (field === 'capacity') {
            newRules[classe].capacity = parseInt(input.value) || 28;
          } else if (field === 'quotas') {
            // Parser les quotas
            const quotasStr = input.value;
            quotasStr.split(',').forEach(pair => {
              const [opt, val] = pair.split('=').map(s => s.trim());
              if (opt && val) {
                newRules[classe].quotas[opt.toUpperCase()] = parseInt(val) || 0;
              }
            });
          }
        });

        // Mettre Ã  jour l'Ã©tat
        STATE.rules = newRules;

        // Sauvegarder en backend
        try {
          const result = await gsRun('updateStructureRules', newRules);
          if (result.success) {
            toast('RÃ¨gles mises Ã  jour avec succÃ¨s', 'success');
            closeRulesModal();
          } else {
            toast('Erreur lors de la mise Ã  jour des rÃ¨gles', 'error');
          }
        } catch (error) {
          console.error('Erreur:', error);
          toast('Erreur lors de la mise Ã  jour des rÃ¨gles', 'error');
        }
      }

      // ========== MISE Ã€ JOUR INTELLIGENTE DU PANEAU DES STATISTIQUES ==========

      // ========== GRAPHIQUES ==========
      function initCharts() {
        console.log('ğŸ¨ Initialisation des graphiques...');
        const statsContent = document.getElementById('statsContent');

        // HTML COMPLET avec tous les graphiques existants + nouveaux
        statsContent.innerHTML = `
        < div class="mb-2" >
          <div class="flex gap-2 mb-2">
            <button onclick="switchChart('COM')" class="px-3 py-1 text-xs rounded font-semibold bg-green-500 text-white" id="btnCOM">COM</button>
            <button onclick="switchChart('TRA')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnTRA">TRA</button>
            <button onclick="switchChart('PART')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnPART">PART</button>
            <button onclick="switchChart('ABS')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnABS">ABS</button>
          </div>
      </div >
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Distribution - <span id="scoreType">Comportement</span></h3>
        <canvas id="chartStacked" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Moyennes par classe</h3>
        <canvas id="chartDetailed" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="grid grid-cols-2 gap-2">
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">RÃ©partition LV2</h3>
          <canvas id="chartLV2" style="max-height: 120px;"></canvas>
        </div>
        
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">Options</h3>
          <canvas id="chartOptions" style="max-height: 120px;"></canvas>
        </div>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-top: 10px;">
        <h3 class="chart-title text-sm">Statistiques globales</h3>
        <div id="globalStats" class="text-xs"></div>
      </div>
      
      <!-- ========== NOUVEAUX AJOUTS EN BAS ========== -->
      
      <!--MÃ©triques globales-- >
  <div class="grid grid-cols-4 gap-3 mb-4 mt-4">
    <div class="stats-metric">
      <div class="metric-value" id="totalStudentsMetric">0</div>
      <div class="metric-label">Ã‰lÃ¨ves</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="genderBalanceMetric">50% F</div>
      <div class="metric-label">Ratio Filles</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="avgClassSizeMetric">0</div>
      <div class="metric-label">Moy/Classe</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="conformityScoreMetric">âœ… OK</div>
      <div class="metric-label">ProblÃ¨mes</div>
    </div>
  </div>
      
      <!--Nouveau graphique LV2 dÃ©taillÃ©-- >
        <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
          <h3 class="chart-title text-sm">
            <i class="fas fa-language text-purple-500"></i>
            RÃ©partition LV2 par Classe
          </h3>
          <canvas id="chartLV2Details" style="max-height: 180px;"></canvas>
        </div>
      `;

        // Chart 1 : Distribution empilÃ©e par classe
        const ctx1 = document.getElementById('chartStacked').getContext('2d');
        chartCommunication = new Chart(ctx1, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              { label: '1', data: [], backgroundColor: '#dc2626', stack: 'Stack 0' },
              { label: '2', data: [], backgroundColor: '#fbbf24', stack: 'Stack 0' },
              { label: '3', data: [], backgroundColor: '#22c55e', stack: 'Stack 0' },
              { label: '4', data: [], backgroundColor: '#15803d', stack: 'Stack 0' }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true,
                ticks: { font: { size: 10 } }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                ticks: { font: { size: 10 } }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'right',
                labels: {
                  boxWidth: 12,
                  font: { size: 10 }
                }
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    return `Score ${ context.datasetIndex + 1 }: ${ context.parsed.y } `;
                  }
                }
              }
            }
          }
        });

        // Chart 2 : Distribution par critÃ¨res
        const ctx2 = document.getElementById('chartDetailed').getContext('2d');
        chartDistribution = new Chart(ctx2, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              { label: 'COM', data: [], backgroundColor: '#10b981' },
              { label: 'TRA', data: [], backgroundColor: '#3b82f6' },
              { label: 'PART', data: [], backgroundColor: '#f59e0b' },
              { label: 'ABS', data: [], backgroundColor: '#ef4444' }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { font: { size: 10 } } },
              y: {
                beginAtZero: true,
                max: 4,
                ticks: { font: { size: 10 } }
              }
            },
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  boxWidth: 10,
                  font: { size: 10 }
                }
              }
            }
          }
        });

        // Chart 3 : Distribution LV2
        const ctx3 = document.getElementById('chartLV2').getContext('2d');
        chartLV2 = new Chart(ctx3, {
          type: 'doughnut',
          data: {
            labels: [],
            datasets: [{
              data: [],
              backgroundColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed', '#d97706']
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  boxWidth: 10,
                  font: { size: 10 }
                }
              }
            }
          }
        });

        // Chart 4 : Distribution Options
        const ctx4 = document.getElementById('chartOptions').getContext('2d');
        chartOptions = new Chart(ctx4, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [{
              label: 'Ã‰lÃ¨ves',
              data: [],
              backgroundColor: '#8b5cf6'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
              x: {
                beginAtZero: true,
                ticks: { font: { size: 10 } }
              },
              y: { ticks: { font: { size: 10 } } }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });

        // ========== NOUVEAU GRAPHIQUE LV2 DÃ‰TAILLÃ‰ ==========
        window.chartLV2Details = null;
        const ctx5 = document.getElementById('chartLV2Details');
        if (ctx5) {
          window.chartLV2Details = new Chart(ctx5.getContext('2d'), {
            type: 'bar',
            data: {
              labels: [],
              datasets: []
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  stacked: true,
                  ticks: { font: { size: 10 } }
                },
                y: {
                  stacked: true,
                  beginAtZero: true,
                  ticks: { font: { size: 10 } }
                }
              },
              plugins: {
                legend: {
                  position: 'bottom',
                  labels: {
                    boxWidth: 12,
                    font: { size: 10 }
                  }
                }
              }
            }
          });
        }

        // Initialiser avec COM
        updateCharts('COM');
      }

      // Variable locale pour le type de score actuel (comme dans la version qui fonctionne)
      let currentScoreType = 'COM';



      // Fonction pour changer de graphique
      window.switchChart = function (type) {
        currentScoreType = type;

        // Mettre Ã  jour les boutons
        ['COM', 'TRA', 'PART', 'ABS'].forEach(t => {
          const btn = document.getElementById(`btn${ t } `);
          if (t === type) {
            btn.classList.remove('bg-gray-300');
            btn.classList.add('bg-green-500', 'text-white');
          } else {
            btn.classList.remove('bg-green-500', 'text-white');
            btn.classList.add('bg-gray-300');
          }
        });

        // Mettre Ã  jour le titre
        const titles = {
          'COM': 'Comportement',
          'TRA': 'Travail',
          'PART': 'Participation',
          'ABS': 'AbsentÃ©isme'
        };
        document.getElementById('scoreType').textContent = titles[type];

        // Mettre Ã  jour les graphiques
        updateCharts(type);
      }

      function updateCharts(scoreType = null) {
        try {
          if (!scoreType) scoreType = currentScoreType;

          // Collecter les donnÃ©es par classe
          const dataByClass = {};
          const classes = [];
          const lv2Count = {};
          const optionCount = {};

          // âš¡ OPTIMISATION Phase 11: Utiliser cache DOM au lieu de querySelector rÃ©pÃ©tÃ©s
          const classColumns = window.DOM ? window.DOM.getAll('.class-column', true) : document.querySelectorAll('.class-column');
          classColumns.forEach(column => {
            const classe = column.querySelector('.classe-name').textContent;
            classes.push(classe);

            // IMPORTANT: RÃ©cupÃ©rer les cartes ACTUELLES de cette colonne
            const cards = Array.from(column.querySelectorAll('.student-card'));

            dataByClass[classe] = {
              total: cards.length,
              scores: {
                COM: [0, 0, 0, 0],
                TRA: [0, 0, 0, 0],
                PART: [0, 0, 0, 0],
                ABS: [0, 0, 0, 0]
              },
              averages: { COM: 0, TRA: 0, PART: 0, ABS: 0 }
            };

            // Calculer les scores pour chaque Ã©lÃ¨ve ACTUELLEMENT dans cette classe
            cards.forEach(card => {
              const eleve = STATE.students[card.dataset.id];
              if (!eleve) return;

              // Compter les scores pour le graphique empilÃ©
              const scoreMap = {
                'COM': eleve.scores.COM,
                'TRA': eleve.scores.TRA,
                'PART': eleve.scores.PART,
                'ABS': eleve.scores.ABS
              };

              const score = scoreMap[scoreType];
              if (score > 0) {
                dataByClass[classe].scores[scoreType][score - 1]++;
              }

              // Calculer les moyennes pour tous les critÃ¨res
              if (eleve.scores.COM > 0) dataByClass[classe].averages.COM += eleve.scores.COM;
              if (eleve.scores.TRA > 0) dataByClass[classe].averages.TRA += eleve.scores.TRA;
              if (eleve.scores.PART > 0) dataByClass[classe].averages.PART += eleve.scores.PART;
              if (eleve.scores.ABS > 0) dataByClass[classe].averages.ABS += eleve.scores.ABS;

              // Compter LV2 et options
              if (eleve.lv2) {
                lv2Count[eleve.lv2] = (lv2Count[eleve.lv2] || 0) + 1;
              }
              if (eleve.opt) {
                optionCount[eleve.opt] = (optionCount[eleve.opt] || 0) + 1;
              }
            });

            // Calculer les moyennes
            const total = cards.length || 1;
            dataByClass[classe].averages.COM /= total;
            dataByClass[classe].averages.TRA /= total;
            dataByClass[classe].averages.PART /= total;
            dataByClass[classe].averages.ABS /= total;
          });

          // VÃ©rifier que les graphiques existent
          if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
            console.warn('Graphiques non initialisÃ©s');
            return;
          }

          // Mettre Ã  jour Chart 1 (Distribution empilÃ©e)
          const sortedClasses = classes.sort();
          chartCommunication.data.labels = sortedClasses;

          // Mettre Ã  jour Chart 1 (Distribution empilÃ©e)
          chartCommunication.data.labels = sortedClasses;

          // Mettre Ã  jour les datasets pour le score sÃ©lectionnÃ©
          for (let i = 0; i < 4; i++) {
            chartCommunication.data.datasets[i].data = sortedClasses.map(c =>
              dataByClass[c].scores[scoreType][i]
            );
          }

          // VÃ©rification de cohÃ©rence des longueurs
          console.assert(
            sortedClasses.length === chartCommunication.data.datasets[0].data.length,
            'ğŸ’¥ IncohÃ©rence longueurs', sortedClasses.length, chartCommunication.data.datasets[0].data.length
          );

          // Mettre Ã  jour Chart 2 (Moyennes par critÃ¨re)
          chartDistribution.data.labels = sortedClasses;
          chartDistribution.data.datasets[0].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.COM * 100) / 100
          );
          chartDistribution.data.datasets[1].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.TRA * 100) / 100
          );
          chartDistribution.data.datasets[2].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.PART * 100) / 100
          );
          chartDistribution.data.datasets[3].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.ABS * 100) / 100
          );

          // Mettre Ã  jour Chart 3 (LV2)
          chartLV2.data.labels = Object.keys(lv2Count);
          chartLV2.data.datasets[0].data = Object.values(lv2Count);

          // Mettre Ã  jour Chart 4 (Options)
          chartOptions.data.labels = Object.keys(optionCount);
          chartOptions.data.datasets[0].data = Object.values(optionCount);

          // Statistiques globales
          let globalTotals = { eleves: 0, filles: 0, garcons: 0 };
          let globalScores = { COM: 0, TRA: 0, PART: 0, ABS: 0 };
          let scoreCounts = { COM: 0, TRA: 0, PART: 0, ABS: 0 };

          // Parcourir TOUTES les cartes actuellement affichÃ©es
          document.querySelectorAll('.student-card').forEach(card => {
            const eleve = STATE.students[card.dataset.id];
            if (eleve) {
              globalTotals.eleves++;
              if (eleve.sexe === 'F') globalTotals.filles++;
              else globalTotals.garcons++;

              if (eleve.scores.COM > 0) { globalScores.COM += eleve.scores.COM; scoreCounts.COM++; }
              if (eleve.scores.TRA > 0) { globalScores.TRA += eleve.scores.TRA; scoreCounts.TRA++; }
              if (eleve.scores.PART > 0) { globalScores.PART += eleve.scores.PART; scoreCounts.PART++; }
              if (eleve.scores.ABS > 0) { globalScores.ABS += eleve.scores.ABS; scoreCounts.ABS++; }
            }
          });

          const globalStatsHtml = `
        < p > <strong>Total Ã©lÃ¨ves :</strong> ${ globalTotals.eleves }</p >
      <p><strong>RÃ©partition :</strong> ${globalTotals.filles} filles (${Math.round(globalTotals.filles / globalTotals.eleves * 100)}%) / ${globalTotals.garcons} garÃ§ons (${Math.round(globalTotals.garcons / globalTotals.eleves * 100)}%)</p>
      <p class="mt-2"><strong>Moyennes globales :</strong></p>
      <ul>
        <li>Comportement : ${scoreCounts.COM > 0 ? (globalScores.COM / scoreCounts.COM).toFixed(2) : 'N/A'}</li>
        <li>Travail : ${scoreCounts.TRA > 0 ? (globalScores.TRA / scoreCounts.TRA).toFixed(2) : 'N/A'}</li>
        <li>Participation : ${scoreCounts.PART > 0 ? (globalScores.PART / scoreCounts.PART).toFixed(2) : 'N/A'}</li>
        <li>Absences : ${scoreCounts.ABS > 0 ? (globalScores.ABS / scoreCounts.ABS).toFixed(2) : 'N/A'}</li>
      </ul>
      `;

          // âš¡ OPTIMISATION Phase 11: Utiliser cache DOM
          const globalStatsElement = window.DOM ? window.DOM.get('#globalStats') : document.getElementById('globalStats');
          if (globalStatsElement) {
            globalStatsElement.innerHTML = globalStatsHtml;
          }

          chartCommunication.update();
          chartDistribution.update();
          chartLV2.update();
          chartOptions.update();

          // Mettre Ã  jour les autres mÃ©triques
          updateNewMetrics();
          updateLV2Details();

        } catch (error) {
          console.error('Erreur dans updateCharts:', error);
        }
      }

      window.updateCharts = updateCharts;

      // ========== MODE SOMBRE ==========
      function toggleDarkMode() {
        STATE.darkMode = !STATE.darkMode;
        document.body.classList.toggle('dark-mode');

        // Mettre Ã  jour l'icÃ´ne du bouton si prÃ©sent
        const btnDarkMode = document.getElementById('btnDarkMode');
        if (btnDarkMode) {
          const icon = btnDarkMode.querySelector('i');
          if (icon) {
            icon.className = STATE.darkMode ? 'fas fa-sun' : 'fas fa-moon';
          }
        }

        // Mettre Ã  jour le bouton flottant si prÃ©sent
        const darkModeToggle = document.getElementById('darkModeToggle');
        if (darkModeToggle) {
          const icon = darkModeToggle.querySelector('i');
          if (icon) {
            if (STATE.darkMode) {
              icon.className = 'fas fa-sun text-xl';
              darkModeToggle.className = 'fixed bottom-4 right-4 w-14 h-14 rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 text-white shadow-2xl hover:scale-110 transition-all duration-300 flex items-center justify-center z-[99999]';
            } else {
              icon.className = 'fas fa-moon text-xl';
              darkModeToggle.className = 'fixed bottom-4 right-4 w-14 h-14 rounded-full bg-gradient-to-br from-purple-600 to-indigo-600 text-white shadow-2xl hover:scale-110 transition-all duration-300 flex items-center justify-center z-[99999]';
            }
          }
        }

        // Sauvegarder la prÃ©fÃ©rence
        try {
          localStorage.setItem('darkMode', STATE.darkMode);
        } catch (e) {
          console.log('localStorage non disponible');
        }

        // Message avec raccourci clavier
        const message = STATE.darkMode
          ? 'ğŸŒ™ Mode sombre activÃ© (Touche D ou clic sur le bouton flottant)'
          : 'â˜€ï¸ Mode clair activÃ© (Touche D ou clic sur le bouton flottant)';
        toast(message, 'info');
      }

      // Exposer globalement
      window.toggleDarkMode = toggleDarkMode;
      window.setDarkMode = setDarkMode;

      // ========== MODE ZOOM ==========
      function toggleZoom() {
        STATE.zoomMode = !STATE.zoomMode;
        document.body.classList.toggle('zoom-cards');

        const btnZoom = document.getElementById('btnZoom');
        if (STATE.zoomMode) {
          btnZoom.innerHTML = '<i class="fas fa-search-minus"></i>';
          toast('Mode zoom activÃ©', 'info');
        } else {
          btnZoom.innerHTML = '<i class="fas fa-search-plus"></i>';
          toast('Mode zoom dÃ©sactivÃ©', 'info');
        }
      }

      // ========== PLEIN Ã‰CRAN STATS ==========
      window.toggleFullscreenStats = function () {
        STATE.fullscreenStats = !STATE.fullscreenStats;
        const statsPanel = document.getElementById('statsPanel');

        if (STATE.fullscreenStats) {
          document.body.classList.add('fullscreen-stats');
          statsPanel.classList.remove('translate-x-full');

          // Optionnel : demander le plein Ã©cran natif
          if (statsPanel.requestFullscreen) {
            statsPanel.requestFullscreen();
          }

          const btnFullscreen = document.getElementById('btnFullscreen');
          if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-compress"></i>';
        } else {
          document.body.classList.remove('fullscreen-stats');

          // Optionnel : sortir du plein Ã©cran natif
          if (document.fullscreenElement) {
            document.exitFullscreen();
          }

          const btnFullscreen = document.getElementById('btnFullscreen');
          if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-expand"></i>';
        }

        // Forcer la mise Ã  jour des graphiques
        setTimeout(() => {
          if (chartCommunication) chartCommunication.resize();
          if (chartDistribution) chartDistribution.resize();
          if (chartLV2) chartLV2.resize();
          if (chartOptions) chartOptions.resize();
        }, 300);
      }

      // ========== MODE ANCRÃ‰ ==========
      function toggleAnchoredStats() {
        STATE.anchoredStats = !STATE.anchoredStats;
        const statsPanel = document.getElementById('statsPanel');

        if (STATE.anchoredStats) {
          statsPanel.classList.add('anchored');
          document.getElementById('btnAnchor').classList.add('active');
          toast('Panel statistiques ancrÃ©', 'info');
        } else {
          statsPanel.classList.remove('anchored');
          document.getElementById('btnAnchor').classList.remove('active');
          toast('Panel statistiques flottant', 'info');
        }
      }

      // ========== RACCOURCIS CLAVIER ==========
      function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          // Ignorer si on est dans un input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          // Ctrl+Z : Annuler
          if (e.ctrlKey && e.key === 'z') {
            e.preventDefault();
            undo();
          }

          // Ctrl+Y : Refaire
          if (e.ctrlKey && e.key === 'y') {
            e.preventDefault();
            redo();
          }

          // S : Mode swap
          if (e.key === 's' && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            toggleSwapMode();
          }

          // T : Statistiques
          if (e.key === 't' && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            document.getElementById('btnStats').click();
          }

          // D : Mode sombre (RACCOURCI PRIORITAIRE)
          if (e.key === 'd' || e.key === 'D') {
            if (!e.ctrlKey && !e.altKey) {
              e.preventDefault();
              toggleDarkMode();
              console.log('ğŸŒ“ Raccourci clavier D : Mode sombre basculÃ©');
            }
          }

          // F : Plein Ã©cran stats (si panel ouvert)
          if (e.key === 'f' && !e.ctrlKey && !e.altKey) {
            if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
              e.preventDefault();
              toggleFullscreenStats();
            }
          }

          // Ctrl+F : Recherche
          if (e.ctrlKey && e.key === 'f') {
            e.preventDefault();
            document.getElementById('search').focus();
          }

          // ? : Aide
          if (e.key === '?' || (e.shiftKey && e.key === '/')) {
            e.preventDefault();
            toggleKeyboardHelp();
          }

          // M : Ouvrir le modal de sÃ©lection de mode
          if (e.key === 'm' && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            openStartupModal();
          }

          // Ã‰chap : Fermer les modals
          if (e.key === 'Escape') {
            // Fermer stats si ouvert
            if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
              const panel = document.getElementById('statsPanel');
              panel.classList.add('translate-x-full');

              setTimeout(() => {
                document.body.classList.remove('stats-open');
              }, 300);
            }

            // Fermer autres modals
            document.querySelectorAll('.modal:not(.hidden)').forEach(modal => {
              modal.classList.add('hidden');
            });

            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('overlay').classList.remove('active');
          }
        });
      }

      // ========== AIDE RACCOURCIS CLAVIER ==========
      function toggleKeyboardHelp() {
        const help = document.getElementById('keyboardShortcuts');
        help.classList.toggle('hidden');

        if (!help.classList.contains('hidden')) {
          toast('Raccourcis clavier affichÃ©s', 'info');
        }
      }

      // ========== FONCTION DE SAUVEGARDE AVEC PROGRESSION ==========
      // Extracted from setupEventListeners for better code organization (Phase 2 refactoring)
      async function lancerSauvegardeAvecProgression(saveFunctionName, buttonElement, options = {}) {
        const { title = 'SAUVEGARDE EN COURS...', successMessage = 'Sauvegarde rÃ©ussie', progressive = true, forcedMode = null } = options;

        if (!window.saveProgressManager) {
          console.error('SaveProgressManager non trouvÃ© !');
          toast('Erreur : composant de progression manquant.', 'error');
          return;
        }

        // DÃ©sactiver le bouton
        if (buttonElement) buttonElement.disabled = true;

        // DÃ©marrer la barre de progression
        window.saveProgressManager.start();
        const header = document.querySelector('#saveProgressBar .save-progress-header span');
        if (header) header.textContent = title;

        try {
          // Ã‰tape 1: PrÃ©paration (10%)
          window.saveProgressManager.updateProgress(10, 'step1');
          const disposition = exportDisposition();

          if (!disposition || Object.keys(disposition).length === 0) {
            throw new Error('Aucune classe Ã  sauvegarder');
          }

          window.saveProgressManager.updateProgress(20, 'step2');
          await new Promise(resolve => setTimeout(resolve, 200));

          // âœ… SAUVEGARDE PROGRESSIVE CLASSE PAR CLASSE (Ã©vite les timeouts)
          if (progressive && saveFunctionName === 'saveCacheData') {
            const classes = Object.keys(disposition);
            const totalClasses = classes.length;
            let successCount = 0;
            const errors = [];


            for (let i = 0; i < totalClasses; i++) {
              const classe = classes[i];
              const classMap = { [classe]: disposition[classe] };

              // Mettre Ã  jour la progression (20% Ã  90%)
              const progress = 20 + ((i / totalClasses) * 70);
              window.saveProgressManager.updateProgress(progress, 'step3');

              // Mise Ã  jour du titre avec le nom de la classe en cours
              if (header) header.innerHTML = `< i class="fas fa-save mr-2" ></i > ${ escapeHtml(title) } - ${ escapeHtml(classe) } (${ i + 1 }/${totalClasses})`;

              try {
                // âœ… Sauvegarder UNE classe Ã  la fois
                const result = await gsRun(saveFunctionName, classMap, STATE.currentMode);

                if (!result || !result.success) {
                  errors.push(`âŒ ${ classe }: ${ result?.message || 'Erreur inconnue' } `);
                  console.error(`âŒ Ã‰chec sauvegarde ${ classe }: `, result);
                } else {
                  successCount++;
                }
              } catch (err) {
                errors.push(`âŒ ${ classe }: ${ err.message } `);
                console.error(`âŒ Exception sauvegarde ${ classe }: `, err);
              }

              // Petit dÃ©lai pour Ã©viter les timeouts consÃ©cutifs
              await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Finalisation (100%)
            window.saveProgressManager.updateProgress(100, 'step4');

            if (successCount === totalClasses) {
              window.saveProgressManager.complete(true);
              toast(`âœ… ${ successCount } classe(s) sauvegardÃ©e(s) avec succÃ¨s!`, 'success');
            } else if (successCount > 0) {
              window.saveProgressManager.complete(true);
              toast(`âš ï¸ ${ successCount }/${totalClasses} classe(s) sauvegardÃ©e(s). Erreurs: ${errors.join(', ')}`, 'warning');
    console.warn('Erreurs de sauvegarde:', errors);
  } else {
    throw new Error('Aucune classe sauvegardÃ©e: ' + errors.join(', '));
  }

          } else {
    // âœ… SAUVEGARDE CLASSIQUE (pour finalizeClasses et autres)
    window.saveProgressManager.updateProgress(50, 'step2');
    await new Promise(resolve => setTimeout(resolve, 300));

    window.saveProgressManager.updateProgress(75, 'step3');

    // Utiliser le mode forcÃ© si fourni, sinon STATE.currentMode
    const modeToUse = forcedMode || STATE.currentMode;

    const result = await gsRun(saveFunctionName, disposition, modeToUse);

    if (!result || !result.success) {
      throw new Error(result?.message || 'Une erreur est survenue sur le serveur.');
    }

    window.saveProgressManager.updateProgress(100, 'step4');
    window.saveProgressManager.complete(true);
    toast(result.message || successMessage, 'success');
  }

        } catch (error) {
    console.error('Erreur lors de la sauvegarde avec progression:', error);
    toast(error.message, 'error');
    window.saveProgressManager.complete(false);
  } finally {
    // RÃ©activer le bouton
    if (buttonElement) buttonElement.disabled = false;
  }
      }

  // Expose globally for use elsewhere
  window.lancerSauvegardeAvecProgression = lancerSauvegardeAvecProgression;

  // ========== PHASE 2: EVENT LISTENERS - SPLIT INTO 6 FOCUSED FUNCTIONS ==========

  // 1. NAVIGATION CONTROLS (refresh, undo, redo, swap)
  function setupNavigationControls() {
    const btnRefresh = document.getElementById('btnRefresh');
    const btnUndo = document.getElementById('btnUndo');
    const btnRedo = document.getElementById('btnRedo');
    const btnSwapMain = document.getElementById('btnSwapMain');

    if (btnRefresh) btnRefresh.addEventListener('click', attemptRefresh);
    if (btnUndo) btnUndo.addEventListener('click', undo);
    if (btnRedo) btnRedo.addEventListener('click', redo);
    if (btnSwapMain) btnSwapMain.addEventListener('click', toggleSwapMode);
  }

  // 2. SAVE OPERATIONS (WIP, finalize)
  function setupSaveOperations() {
    const btnSaveWIP = document.getElementById('btnSaveWIP');

    if (btnSaveWIP) btnSaveWIP.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();
      lancerSauvegardeAvecProgression('saveCacheData', e.currentTarget, {
        title: 'Sauvegarde Brouillon (CACHE)...',
        successMessage: 'Brouillon sauvegardÃ© avec succÃ¨s !'
      });
    });
  }

  // 3. VIEW MODE CONTROLS (view selector, gender badges, white background)
  function setupViewModeControls() {
    const viewModeSelect = document.getElementById('viewModeSelect');
    const showGenderBadges = document.getElementById('showGenderBadges');
    const whiteBackground = document.getElementById('whiteBackground');

    // View mode selector
    if (viewModeSelect) {
      viewModeSelect.value = STATE.viewMode;

      viewModeSelect.addEventListener('change', (e) => {
        STATE.viewMode = e.target.value;
        localStorage.setItem('viewMode', STATE.viewMode);

        document.body.classList.remove('simple-view', 'essential-view');
        if (STATE.viewMode === 'simple') {
          document.body.classList.add('simple-view');
        } else if (STATE.viewMode === 'essential') {
          document.body.classList.add('essential-view');
        }

        // Recreate all cards for new view
        document.querySelectorAll('.droppable-zone').forEach(zone => {
          const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
          zone.innerHTML = '';
          ids.forEach(id => {
            const eleve = STATE.students[id];
            if (eleve) {
              zone.appendChild(createStudentCard(eleve));
            }
          });
        });

        if (STATE.viewMode === 'simple') {
          setTimeout(() => {
            document.querySelectorAll('.droppable-zone').forEach(zone => {
              adjustSimpleNamesFontSize(zone);
            });
          }, 50);
        }

        toast(`Mode ${e.target.options[e.target.selectedIndex].text}`, 'info');
      });

      // Apply initial body class
      if (STATE.viewMode === 'simple') {
        document.body.classList.add('simple-view');
      } else if (STATE.viewMode === 'essential') {
        document.body.classList.add('essential-view');
      }
    }

    // Micro Charts toggle (Nouveau Phase 6)
    const showMicroCharts = document.getElementById('showMicroCharts');
    if (showMicroCharts) {
      const microChartsEnabled = localStorage.getItem('showMicroCharts') === 'true';
      showMicroCharts.checked = microChartsEnabled;
      if (microChartsEnabled) {
        document.body.classList.add('show-micro-charts');
      }

      showMicroCharts.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        localStorage.setItem('showMicroCharts', isChecked);

        if (isChecked) {
          document.body.classList.add('show-micro-charts');
          if (window.showToast) window.showToast('Jauges visuelles activÃ©es', 'success');
        } else {
          document.body.classList.remove('show-micro-charts');
          if (window.showToast) window.showToast('Jauges visuelles dÃ©sactivÃ©es', 'info');
        }

        // Re-render UI to apply card changes
        if (window.STATE && window.STATE.classes) {
          App.UI.renderAllClasses(window.STATE.classes);
        }
      });
    }

    // Gender badges toggle
    if (showGenderBadges) {
      const genderBadgesEnabled = localStorage.getItem('showGenderBadges') === 'true';
      showGenderBadges.checked = genderBadgesEnabled;
      if (genderBadgesEnabled) {
        document.body.classList.add('gender-badges');
      }

      showGenderBadges.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        localStorage.setItem('showGenderBadges', isChecked);

        if (isChecked) {
          document.body.classList.add('gender-badges');
          if (window.showToast) window.showToast('Badges sexe activÃ©s', 'success');
        } else {
          document.body.classList.remove('gender-badges');
          if (window.showToast) window.showToast('Badges sexe dÃ©sactivÃ©s', 'info');
        }
      });
    }

    // White background toggle
    if (whiteBackground) {
      const whiteBgEnabled = localStorage.getItem('whiteBackground') === 'true';
      whiteBackground.checked = whiteBgEnabled;
      if (whiteBgEnabled) {
        document.body.classList.add('white-bg');
      }

      whiteBackground.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        localStorage.setItem('whiteBackground', isChecked);

        if (isChecked) {
          document.body.classList.add('white-bg');
          toast('Fond blanc activÃ©', 'success');
        } else {
          document.body.classList.remove('white-bg');
          toast('Fond blanc dÃ©sactivÃ©', 'info');
        }
      });
    }
  }

  // 4. ACTION BUTTONS (stats, export, rules, dark mode, zoom, help)
  function setupActionButtons() {
    const btnStats = document.getElementById('btnStats');
    const btnExport = document.getElementById('btnExport');
    const btnEditRules = document.getElementById('btnEditRules');
    const btnDarkMode = document.getElementById('btnDarkMode');
    const btnZoom = document.getElementById('btnZoom');
    const btnHelp = document.getElementById('btnHelp');

    if (btnStats) btnStats.addEventListener('click', () => {
      const panel = document.getElementById('statsPanel');

      requestAnimationFrame(() => {
        const panelWidth = 600;
        document.documentElement.style.setProperty('--stats-width', panelWidth + 'px');

        document.body.classList.add('stats-open');

        setTimeout(() => {
          panel.classList.remove('translate-x-full');
          btnStats.setAttribute('aria-expanded', 'true');

          if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
            if (typeof initCharts === 'function') {
              initCharts();
            }
          }

          updateCharts();
        }, 50);
      });
    });

    if (btnExport) btnExport.addEventListener('click', () => {
      document.getElementById('exportModal').classList.remove('hidden');
      document.getElementById('overlay').classList.remove('hidden');
      document.getElementById('overlay').classList.add('active');
    });

    if (btnEditRules) btnEditRules.addEventListener('click', openRulesModal);
    if (btnDarkMode) btnDarkMode.addEventListener('click', toggleDarkMode);
    if (btnZoom) btnZoom.addEventListener('click', toggleZoom);
    if (btnHelp) btnHelp.addEventListener('click', toggleKeyboardHelp);
  }

  // 5. PANEL CONTROLS (close, fullscreen, anchor, resize)
  function setupPanelControls() {
    const closeStats = document.getElementById('closeStats');
    const btnFullscreen = document.getElementById('btnFullscreen');
    const btnAnchor = document.getElementById('btnAnchor');
    const statsPanel = document.getElementById('statsPanel');

    if (closeStats) closeStats.addEventListener('click', () => {
      closeStatsPanel();
      const btnStats = document.getElementById('btnStats');
      if (btnStats) btnStats.setAttribute('aria-expanded', 'false');
    });

    if (btnFullscreen) btnFullscreen.addEventListener('click', toggleFullscreenStats);
    if (btnAnchor) btnAnchor.addEventListener('click', toggleAnchoredStats);
    if (statsPanel) makeResizable(statsPanel);
  }

  // 6. SEARCH FEATURE
  function setupSearchFeature() {
    setupSearch();
  }

  // ========== MAIN EVENT LISTENERS SETUP (calls all 6 functions) ==========
  function setupEventListeners() {
    setupNavigationControls();
    setupSaveOperations();
    setupViewModeControls();
    setupActionButtons();
    setupPanelControls();
    setupSearchFeature();
  }

  // ========== PANEL REDIMENSIONNABLE ==========
  function makeResizable(element) {
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;

    const handle = document.createElement('div');
    handle.style.cssText = `
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: ew-resize;
      background: transparent;
    `;

    element.appendChild(handle);

    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      startX = e.clientX;
      startWidth = element.offsetWidth;
      document.body.style.cursor = 'ew-resize';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;

      const diff = startX - e.clientX;
      const newWidth = Math.min(Math.max(400, startWidth + diff), window.innerWidth * 0.8);
      element.style.width = newWidth + 'px';

      // Mettre Ã  jour la variable CSS pour adapter la grille
      if (document.body.classList.contains('stats-open')) {
        document.documentElement.style.setProperty('--stats-width', newWidth + 'px');
      }
    });

    document.addEventListener('mouseup', () => {
      isResizing = false;
      document.body.style.cursor = '';
    });
  }


  // ========== FONCTION D'INITIALISATION UNIVERSELLE ==========
  async function initRepartitionApp() {
    let mode = localStorage.getItem('mode-selection');

    if (!mode) {
      openStartupModal();
      return;
    }

    STATE.currentMode = mode;
    showModeBadge(mode);

    // ArrÃªter les anciennes sauvegardes automatiques pour Ãªtre propre
    if (typeof stopAutoSave === 'function') stopAutoSave();
    if (typeof stopCacheAutoSave === 'function') stopCacheAutoSave();

    const ok = await loadDataForMode(mode);
    if (!ok) {
      showErrorState('Aucune donnÃ©e trouvÃ©e pour le mode ' + mode);
      return;
    }

    // DÃ©marrer la sauvegarde automatique dans le navigateur (uniquement si chargement rÃ©ussi)
    if (typeof startAutoSave === 'function') {
      startAutoSave();
    }
  }

  // Fonction pour ouvrir l'optimisation avec mot de passe
  function openOptimizationWithPassword() {
    const password = prompt('ğŸ” Entrez le mot de passe pour accÃ©der Ã  l\'optimisation automatique :');

    if (password === null) {
      // Utilisateur a annulÃ©
      return;
    }

    if (password === CONFIG.adminPassword) {
      // Mot de passe correct
      if (typeof OptimizationPanel !== 'undefined') {
        OptimizationPanel.open();
      } else {
        console.error('OptimizationPanel non disponible');
        toast('âŒ Module d\'optimisation non chargÃ©', 'error');
      }
    } else {
      // Mot de passe incorrect
      toast('âŒ Mot de passe incorrect', 'error');
    }
  }

  // Attacher les fonctions globales Ã  window
  window.initRepartitionApp = initRepartitionApp;
  window.openStartupModal = openStartupModal;
  window.openOptimizationWithPassword = openOptimizationWithPassword;
  window.restoreCache = restoreCache;
  window.checkCache = checkCache;
  window.showModeBadge = showModeBadge;
  window.stopAutoSave = stopAutoSave;
  window.startAutoSave = startAutoSave;
  window.showErrorState = showErrorState;
  window.setupEventListeners = setupEventListeners;
  window.setupKeyboardShortcuts = setupKeyboardShortcuts;
  window.updateAllColumnStats = updateAllColumnStats;
  window.updateAdvancedStats = updateAdvancedStats;
  window.toast = toast;
  window.showToast = toast; // Alias utilisÃ© par HeaderControls et toggles RÃ©gler
  window.undo = undo;
  window.redo = redo;
  window.gsRun = gsRun;

  // =======================================================
  // 3. DÃ‰MARRAGE FINAL
  // =======================================================

  // --- Event listeners pour le modal de dÃ©marrage ---
  const modal = document.getElementById('startupModal');
  const badge = document.getElementById('modeBadge');
  const closeBtn = document.getElementById('closeStartupModal');
  const btnRestore = document.getElementById('btnRestoreCache');

  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.classList.add('hidden'));
  }

  if (badge) {
    badge.addEventListener('dblclick', () => openStartupModal({ force: true }));
  }

  if (modal) {
    modal.querySelectorAll('button[data-mode]').forEach((btn) => {
      btn.addEventListener('click', async e => {
        const mode = e.currentTarget.dataset.mode;

        if (mode === 'SOURCES') {
          alert('Base Pronote non implÃ©mentÃ©e. Cette fonctionnalitÃ© sera disponible prochainement.');
          return;
        }

        // ProtÃ©ger PREVIOUS et FIN avec mot de passe admin
        if ((mode === 'PREVIOUS' || mode === 'FIN') && !STATE.adminMode) {
          const password = prompt('Veuillez entrer le mot de passe administrateur :', '');
          if (password === null) return;

          try {
            const result = await gsRun('verifierMotDePasseAdmin', password);
            if (!result || !result.success) {
              alert('Mot de passe incorrect.');
              return;
            }
            STATE.adminMode = true;
          } catch (err) {
            console.error('Erreur vÃ©rification mot de passe:', err);
            alert('Erreur lors de la vÃ©rification du mot de passe.');
            return;
          }
        }

        localStorage.setItem('mode-selection', mode);
        modal.classList.add('hidden');
        initRepartitionApp();
      });
    });
  }

  if (btnRestore) {
    btnRestore.addEventListener('click', () => {
      restoreCache();
      modal.classList.add('hidden');
    });
  }

  // Branche les Ã©couteurs d'Ã©vÃ©nements principaux
  setupEventListeners();
  setupKeyboardShortcuts();

  // ========== NOUVELLES FONCTIONNALITÃ‰S ==========

  let focusedColumn = null;

  // Fonction d'export image
  window.exportAsImage = async function () {
    toast('GÃ©nÃ©ration de l\'image en cours...', 'info');

    try {
      const board = document.getElementById('board');
      const originalStyle = board.style.cssText;

      board.style.width = '1920px';
      board.style.padding = '20px';
      board.style.background = '#ffffff';

      await new Promise(resolve => setTimeout(resolve, 500));

      const canvas = await html2canvas(board, {
        backgroundColor: '#ffffff',
        scale: 2,
        logging: false,
        useCORS: true,
        width: 1920,
        height: board.scrollHeight
      });

      board.style.cssText = originalStyle;

      const link = document.createElement('a');
      const niveau = STATE.niveau?.replace('Â°', 'e') || 'classes';
      link.download = `repartition_${niveau}_${new Date().toISOString().split('T')[0]}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();

      toast('Image exportÃ©e avec succÃ¨s', 'success');
    } catch (error) {
      console.error('Erreur export image:', error);
      toast('Erreur lors de l\'export de l\'image', 'error');
    }
  };

  function addToHistory(action) {
    action.timestamp = new Date().toISOString();
    if (action.eleveId) {
      const eleve = STATE.students[action.eleveId];
      action.eleveName = eleve ? `${eleve.nom} ${eleve.prenom || ''}` : 'Inconnu';
    }
    if (!STATE.historyTimeline) STATE.historyTimeline = [];
    STATE.historyTimeline.push(action);
    updateHistoryPanel();
  }

  window.toggleHistoryPanel = function () {
    const panel = document.getElementById('historyPanel');
    panel.classList.toggle('open');
  };

  function revertToPoint(index) {
    if (confirm(`Revenir Ã  cet Ã©tat ? (${STATE.history.length - index - 1} actions seront annulÃ©es)`)) {
      while (STATE.history.length > index + 1) {
        undo();
      }
      updateHistoryPanel();
    }
  }

  // Mode focus
  function enableFocusMode() {
    document.querySelectorAll('.class-column').forEach(column => {
      column.addEventListener('dblclick', () => {
        focusOnClass(column);
      });
    });
  }

  function focusOnClass(column) {
    if (focusedColumn) return;

    focusedColumn = column;

    const overlay = document.createElement('div');
    overlay.className = 'focus-overlay';
    document.body.appendChild(overlay);

    const hint = document.createElement('div');
    hint.className = 'exit-focus-hint';
    hint.innerHTML = 'Appuyez sur ESC pour sortir';
    document.body.appendChild(hint);

    column.classList.add('focused-column');
    document.body.style.overflow = 'hidden';

    function exitFocus(e) {
      if (e.key === 'Escape') {
        column.classList.remove('focused-column');
        overlay.remove();
        hint.remove();
        document.body.style.overflow = '';
        focusedColumn = null;
        document.removeEventListener('keydown', exitFocus);
      }
    }

    document.addEventListener('keydown', exitFocus);

    overlay.onclick = () => {
      const event = new KeyboardEvent('keydown', { key: 'Escape' });
      document.dispatchEvent(event);
    };
  }

  // SystÃ¨me de bookmarks
  window.toggleBookmarksMenu = function () {
    const menu = document.getElementById('bookmarksMenu');
    menu.classList.toggle('open');
    updateBookmarksMenu();
  };

  window.saveAsBookmark = function () {
    const name = prompt('Nom du favori :');
    if (!name) return;

    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    bookmarks[name] = {
      date: new Date().toISOString(),
      disposition: exportDisposition(),
      mode: STATE.currentMode,
      stats: {
        total: Object.keys(STATE.students).length,
        classes: document.querySelectorAll('.class-column').length,
        niveau: STATE.niveau
      }
    };

    localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));
    updateBookmarksMenu();
    toast(`Favori "${name}" sauvegardÃ©`, 'success');
  };

  window.loadBookmark = function (name) {
    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    const bookmark = bookmarks[name];

    if (!bookmark) return;

    if (!confirm(`Charger le favori "${name}" ? Cela remplacera la disposition actuelle.`)) {
      return;
    }

    Object.entries(bookmark.disposition).forEach(([classe, ids]) => {
      const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!zone) return;

      zone.innerHTML = '';

      ids.forEach(id => {
        const card = document.querySelector(`.student-card[data-id="${id}"]`);
        if (card) zone.appendChild(card);
      });
    });

    updateAllColumnStats();
    toast(`Favori "${name}" chargÃ©`, 'success');
  };

  window.deleteBookmark = function (name) {
    if (!confirm(`Supprimer le favori "${name}" ?`)) return;

    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    delete bookmarks[name];
    localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));

    updateBookmarksMenu();
    toast(`Favori "${name}" supprimÃ©`, 'info');
  };

  function updateBookmarksMenu() {
    const container = document.getElementById('bookmarksList');
    if (!container) return;

    const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
    container.innerHTML = '';

    if (Object.keys(bookmarks).length === 0) {
      container.innerHTML = '<div class="p-4 text-center text-gray-500">Aucun favori enregistrÃ©</div>';
      return;
    }

    Object.entries(bookmarks).forEach(([name, data]) => {
      const item = document.createElement('div');
      item.className = 'bookmark-item';
      item.innerHTML = `
        <div class="bookmark-name">${name}</div>
        <div class="bookmark-meta">
          SauvegardÃ© le ${new Date(data.date).toLocaleDateString('fr-FR')}
          - ${data.stats.total} Ã©lÃ¨ves
        </div>
        <div class="bookmark-actions">
          <button class="btn btn-sm btn-primary" onclick="loadBookmark('${name}')">
            <i class="fas fa-download"></i> Charger
          </button>
          <button class="btn btn-sm btn-secondary" onclick="deleteBookmark('${name}')">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      `;
      container.appendChild(item);
    });
  }

  // Initialiser les nouvelles fonctionnalitÃ©s
  enableFocusMode();
  updateHistoryPanel();

  // Fermer les menus au clic externe
  document.addEventListener('click', (e) => {
    if (!e.target.closest('#btnBookmarks') && !e.target.closest('#bookmarksMenu')) {
      document.getElementById('bookmarksMenu')?.classList.remove('open');
    }
  });

  // Ajouter les event listeners pour les nouveaux boutons
  const btnHistory = document.getElementById('btnHistory');
  const btnBookmarks = document.getElementById('btnBookmarks');

  if (btnHistory) btnHistory.addEventListener('click', toggleHistoryPanel);
  if (btnBookmarks) btnBookmarks.addEventListener('click', toggleBookmarksMenu);

  // Initialiser les filtres
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.addEventListener('click', () => applyQuickFilter(btn.dataset.filter));
  });

  // CORRECTION : TOUJOURS afficher le modal au dÃ©marrage
  // L'utilisateur doit pouvoir choisir Ã  chaque fois
  initializeBridge();

  // Gestion des menus dÃ©roulants fixes au clic
  (function () {
    function setupDropdown(wrapperId, btnId, dropdownId) {
      const wrapper = document.getElementById(wrapperId);
      const btn = document.getElementById(btnId);
      const dropdown = document.getElementById(dropdownId);
      if (!wrapper || !btn || !dropdown) return;
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        // Fermer tous les autres dropdowns
        document.querySelectorAll('.app-header .absolute').forEach(d => {
          if (d !== dropdown) {
            d.classList.add('hidden');
            d.setAttribute('aria-hidden', 'true');
            // Trouver le bouton associÃ© et mettre Ã  jour aria-expanded
            const otherBtns = document.querySelectorAll('[aria-haspopup="menu"]');
            otherBtns.forEach(otherBtn => {
              if (otherBtn.nextElementSibling === d || (otherBtn.parentElement && otherBtn.parentElement.contains(d))) {
                otherBtn.setAttribute('aria-expanded', 'false');
              }
            });
          }
        });
        const isHidden = dropdown.classList.toggle('hidden');
        // Mettre Ã  jour les attributs ARIA
        btn.setAttribute('aria-expanded', !isHidden);
        dropdown.setAttribute('aria-hidden', isHidden);
      });
      // EmpÃªcher la fermeture si on clique dans le menu
      dropdown.addEventListener('click', e => e.stopPropagation());
    }
    setupDropdown('settingsMenuWrapper', 'btnSettings', 'settingsDropdown');

    // Mapper les nouveaux boutons du menu ParamÃ¨tres aux fonctions existantes
    const settingsDropdown = document.getElementById('settingsDropdown');
    if (settingsDropdown) {
      // Section Affichage
      const menuDarkMode = document.getElementById('menuDarkMode');
      if (menuDarkMode) {
        menuDarkMode.addEventListener('click', () => {
          toggleDarkMode();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuZoom = document.getElementById('menuZoom');
      if (menuZoom) {
        menuZoom.addEventListener('click', () => {
          toggleZoom();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuFullscreen = document.getElementById('menuFullscreen');
      if (menuFullscreen) {
        menuFullscreen.addEventListener('click', () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
          settingsDropdown.classList.add('hidden');
        });
      }

      // Section Actions - Annuler/Refaire dÃ©jÃ  gÃ©rÃ©s par leurs ID existants (btnUndo, btnRedo)
      // Boutons Favoris, Optimiser, Contraintes, Filtres supprimÃ©s (non fonctionnels)

      // Section DonnÃ©es
      const menuImportScores = document.getElementById('menuImportScores');
      const btnImportScores = document.getElementById('btnImportScores');
      if (menuImportScores && btnImportScores) {
        menuImportScores.addEventListener('click', () => {
          btnImportScores.click();
          settingsDropdown.classList.add('hidden');
        });
      }

      const menuRules = document.getElementById('menuRules');
      const btnEditRules = document.getElementById('btnEditRules');
      if (menuRules && btnEditRules) {
        menuRules.addEventListener('click', () => {
          btnEditRules.click();
          settingsDropdown.classList.add('hidden');
        });
      }

      // Section Filtres
      const filterBtnsCompact = settingsDropdown.querySelectorAll('.filter-btn-compact');
      filterBtnsCompact.forEach(btn => {
        btn.addEventListener('click', () => {
          const filter = btn.dataset.filter;
          // Retirer la classe active de tous les boutons
          filterBtnsCompact.forEach(b => b.classList.remove('active'));
          // Ajouter la classe active au bouton cliquÃ©
          btn.classList.add('active');
          // Appliquer le filtre en utilisant la fonction existante
          applyQuickFilter(filter);
          // Fermer le menu
          settingsDropdown.classList.add('hidden');
        });
      });

      // Section Aide - btnHelp et btnTutorial dÃ©jÃ  gÃ©rÃ©s par leurs ID existants
    }

    // Fermer tous les menus au clic extÃ©rieur
    document.addEventListener('click', () => {
      document.querySelectorAll('.app-header .absolute').forEach(d => {
        d.classList.add('hidden');
        d.setAttribute('aria-hidden', 'true');
      });
      // Mettre Ã  jour aria-expanded pour tous les boutons de menu
      document.querySelectorAll('[aria-haspopup="menu"]').forEach(btn => {
        btn.setAttribute('aria-expanded', 'false');
      });
    });
  })();

    }); // Fin du DOMContentLoaded


  // =======================================================
  // MODULES EXTRAITS â€” Final Cut (voir fichiers sÃ©parÃ©s)
  // =======================================================
  // Les blocs suivants ont Ã©tÃ© extraits pour maintenabilitÃ© :
  //   - InterfaceV2_Metrics.html         (mÃ©triques, dark mode, search, notifications)
  //   - InterfaceV2_PanelsUtils.html     (timeline, filtres rapides, tooltips, cache, tri colonnes)
  //   - InterfaceV2_GroupsHelper.html    (module groupes V2, fonctions additionnelles)
  //   - InterfaceV2_AdvancedFeatures.html (RealTimeFeedback, ScoreVisualizer, ConflictDetector, LiveScore, HistoryManager)
  // ChargÃ©s via <?!= include() ?> dans InterfaceV2.html


  // 7. MODE SIMULATION
  // ========== INTÃ‰GRATION DES NOUVELLES FONCTIONS ==========

  // Ajouter les boutons dans l'interface
  // ========== CONFIGURATION DES BOUTONS AVANCÃ‰S DANS LE MENU ACTIONS ==========
  function configureAdvancedFeaturesButtons() {
    // Bouton Import Scores
    const importBtn = document.getElementById('btnImportScores');
    if (importBtn) {
      importBtn.onclick = () => {
        ScoreImporter.importScoresFromINT();
        // Fermer le menu aprÃ¨s clic
        document.getElementById('actionsDropdown').classList.add('hidden');
      };
    }

    // Bouton Optimisation
    const optimizeBtn = document.getElementById('btnOptimize');
    if (optimizeBtn) {
      optimizeBtn.onclick = () => {
        OptimizerV2.applyOptimization();
        document.getElementById('actionsDropdown').classList.add('hidden');
      };
    }

    // Bouton Contraintes
    const constraintsBtn = document.getElementById('btnConstraints');
    if (constraintsBtn) {
      constraintsBtn.onclick = () => {
        ConstraintManager.showConstraintViolations();
        document.getElementById('actionsDropdown').classList.add('hidden');
      };
    }

    // Bouton Feedback en temps rÃ©el (dans le menu des groupes)
    document.addEventListener('click', (e) => {
      if (e.target.closest('#btnGroupFeedback')) {
        if (RealTimeFeedback) {
          const panel = document.getElementById('feedbackPanel');
          if (panel && panel.style.display === 'none') {
            RealTimeFeedback.show();
            e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Masquer';
          } else {
            RealTimeFeedback.hide();
            e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Indicateurs';
          }
        }
      }

      // Bouton Statistiques des groupes
      if (e.target.closest('#btnGroupStats')) {
        const statsPanel = document.getElementById('statsPanel');
        if (statsPanel) {
          // Basculer l'affichage du panneau de statistiques
          if (statsPanel.classList.contains('translate-x-full')) {
            statsPanel.classList.remove('translate-x-full');

            // Initialiser le contenu seulement si pas encore fait
            const statsContent = document.getElementById('statsContent');
            if (!statsContent.innerHTML.trim()) {
              if (typeof initCharts === 'function') {
                initCharts();
              }
            }

            // MISE Ã€ JOUR INTELLIGENTE DES STATISTIQUES
            if (typeof updateStatsPanel === 'function') {
              updateStatsPanel();
            }

            // Changer le titre pour indiquer qu'on affiche les stats des groupes
            const title = statsPanel.querySelector('h2');
            if (title) {
              title.textContent = 'Statistiques des Groupes';
            }
          } else {
            statsPanel.classList.add('translate-x-full');
          }
        }
      }
    });
  }

  // ========== INITIALISATION AU CHARGEMENT ==========

  document.addEventListener('DOMContentLoaded', () => {
    // Feedback temps rÃ©el
    setTimeout(() => { if (RealTimeFeedback) RealTimeFeedback.init(); }, 500);

    // Boutons avancÃ©s
    setTimeout(configureAdvancedFeaturesButtons, 2000);

    // Fermeture stats
    const closeStatsBtn = document.getElementById('closeStats');
    if (closeStatsBtn) {
      closeStatsBtn.addEventListener('click', () => {
        closeStatsPanel();
        const btnStats = document.getElementById('btnStats');
        if (btnStats) btnStats.setAttribute('aria-expanded', 'false');
      });
    }

    // Toggle mode sombre flottant
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (darkModeToggle) darkModeToggle.addEventListener('click', toggleDarkMode);

    // Sauvegarder l'Ã©tat initial + optimiser le rendu
    setTimeout(() => { HistoryManager.saveState(); }, 3000);
    setTimeout(optimizeCardRendering, 1000);
  });

  // Fonction pour initialiser les groupes aprÃ¨s fermeture du modal
  window.initializeGroupsAfterModal = function () {
    // Respecter le paramÃ¨tre global UI (SHOW_GROUPS_BUTTON)
    if (typeof google !== 'undefined' && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function (settings) {
          if (settings && settings.SHOW_GROUPS_BUTTON) {
            addGroupsButton();
          } else {
            removeGroupsButton();
          }
          // Charger les groupes sauvegardÃ©s SANS les afficher
          if (window.GroupManager && GroupManager.loadGroups) {
            GroupManager.loadGroups();
            if (GroupManager.updateGroupsButton) {
              GroupManager.updateGroupsButton();
            }
          }
        })
        .withFailureHandler(function (err) {
          console.error('Erreur getUiSettings:', err);
          removeGroupsButton();
        })
        .getUiSettings();
    } else {
      // En mode local (pas de GAS), ne pas afficher par dÃ©faut
      removeGroupsButton();
    }
  };

  // ========== THROTTLE DU FEEDBACK TEMPS RÃ‰EL ==========
  if (window.RealTimeFeedback) {
    const originalUpdateMetrics = RealTimeFeedback.updateMetrics;
    let lastUpdate = 0;
    const THROTTLE_DELAY = 500; // Mise Ã  jour max toutes les 500ms

    RealTimeFeedback.updateMetrics = function () {
      const now = Date.now();
      if (now - lastUpdate < THROTTLE_DELAY) {
        return;
      }
      lastUpdate = now;

      if (originalUpdateMetrics) {
        originalUpdateMetrics.call(this);
      }
    };
  }


  // VÃ©rifier si les graphiques sont prÃªts
  window.areChartsReady = function () {
    return window.chartCommunication &&
      window.chartDistribution &&
      window.chartLV2 &&
      window.chartOptions &&
      typeof window.chartCommunication.update === 'function';
  };

  // Optimisation du rendu des cartes
  window.optimizeCardRendering = function () {
    // Utiliser requestAnimationFrame pour les mises Ã  jour visuelles
    const cards = document.querySelectorAll('.student-card');
    let index = 0;

    function processNextBatch() {
      const batchSize = 10;
      const batch = Array.from(cards).slice(index, index + batchSize);

      batch.forEach(card => {
        // Appliquer les optimisations de rendu
        card.style.willChange = 'transform';
        card.style.backfaceVisibility = 'hidden';
      });

      index += batchSize;

      if (index < cards.length) {
        requestAnimationFrame(processNextBatch);
      }
    }

    requestAnimationFrame(processNextBatch);
  };


  // ========== UTILITAIRES FINAUX ==========
  if (typeof window.chartLV2Details === 'undefined') {
    window.chartLV2Details = null;
  }

  // 2. Fonction utilitaire pour mise Ã  jour sÃ©curisÃ©e des graphiques
  window.safeUpdateChart = function (chart) {
    if (chart && typeof chart.update === 'function') {
      try {
        chart.update('none'); // Mise Ã  jour sans animation pour plus de fluiditÃ©
      } catch (error) {
        console.warn('Erreur mise Ã  jour graphique:', error);
      }
    }
  };

  // 3. SystÃ¨me de gestion des event listeners pour Ã©viter les doublons
  window.EventManager = {
    listeners: [],

    add: function (element, event, handler, options = {}) {
      // VÃ©rifier si le listener existe dÃ©jÃ 
      const existing = this.listeners.find(l =>
        l.element === element && l.event === event && l.handler === handler
      );

      if (!existing) {
        element.addEventListener(event, handler, options);
        this.listeners.push({ element, event, handler, options });
      }
    },

    remove: function (element, event, handler) {
      element.removeEventListener(event, handler);
      this.listeners = this.listeners.filter(l =>
        !(l.element === element && l.event === event && l.handler === handler)
      );
    },

    clear: function () {
      this.listeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      this.listeners = [];
    }
  };

  // Initialisation unique de l'application
  window.addEventListener('DOMContentLoaded', () => {
    if (window._initialized) return;
    window._initialized = true;

    setTimeout(() => {
      if (typeof initRepartitionApp === 'function') initRepartitionApp();
    }, 100);
  });


  }) (); // Fin du DOM Environment Guard IIFE
</script>