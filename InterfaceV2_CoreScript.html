<script>
  (function () {
    'use strict';

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ›¡ï¸ DOM ENVIRONMENT GUARD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Protection contre l'exÃ©cution de code DOM cÃ´tÃ© serveur Apps Script
    // Si typeof document === 'undefined', on est cÃ´tÃ© serveur â†’ sortir
    if (typeof document === 'undefined') {
      console.warn('[CoreScript] Skipping client-side code in server context');
      return;
    }
    // Ã€ partir d'ici, le code s'exÃ©cute uniquement cÃ´tÃ© client (navigateur)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Scripts principaux extraits de InterfaceV2.html pour amÃ©liorer la lisibilitÃ©.
    // =======================================================
    // FONCTIONS UTILITAIRES GLOBALES (accessibles partout)
    // =======================================================

    /**
     * Ã‰chappe les caractÃ¨res HTML dangereux dans une chaÃ®ne.
     * Ã€ utiliser systÃ©matiquement avant toute insertion de donnÃ©es
     * utilisateur (noms, options, classes) via innerHTML.
     * @param {*} str - Valeur Ã  Ã©chapper
     * @returns {string} ChaÃ®ne HTML-safe
     */
    window.escapeHtml = function (str) {
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    };

    // ğŸ”§ PROTECTION REALTIME FEEDBACK
    window.RealTimeFeedback = window.RealTimeFeedback || null;


    // ========== GESTION DES NOTIFICATIONS ET CHARGEMENT ==========
    // Mapping global pour compatibilitÃ©
    window.toast = function (message, type, duration) {
      if (typeof UIComponents !== 'undefined' && UIComponents.Toast) {
        if (type === 'success') return UIComponents.Toast.success(message, duration);
        if (type === 'error') return UIComponents.Toast.error(message, duration);
        if (type === 'warning') return UIComponents.Toast.warning(message, duration);
        return UIComponents.Toast.info(message, duration);
      }
      console.log(`[TOAST] ${type}: ${message}`);
    };

    // Fonction de sauvegarde avec barre de progression via UIComponents
    async function saveWithProgressINT() {
      if (typeof UIComponents === 'undefined' || !UIComponents.LoadingOverlay) {
        console.warn("UIComponents non trouvÃ©, exÃ©cution de la sauvegarde sans overlay...");
        return _saveInternal(); // fallback basique
      }

      const steps = [
        { label: 'PrÃ©paration des donnÃ©es...', icon: 'âš™ï¸' },
        { label: 'Validation LV2 obligatoire...', icon: 'âœ…' },
        { label: 'CrÃ©ation onglets FIN...', icon: 'ğŸ“‘' },
        { label: 'Formatage automatique...', icon: 'âœ¨' },
        { label: 'Finalisation...', icon: 'ğŸ‰' }
      ];

      UIComponents.LoadingOverlay.show('CrÃ©ation des onglets FIN...', steps);

      try {
        // Ã‰tape 1 : PrÃ©paration
        UIComponents.LoadingOverlay.setStep(0);
        await new Promise(resolve => setTimeout(resolve, 500));

        const disposition = exportDisposition();
        if (Object.keys(disposition).length === 0) {
          throw new Error('Aucune classe Ã  sauvegarder');
        }

        // Ã‰tape 2 : Validation LV2
        UIComponents.LoadingOverlay.setStep(1);
        await new Promise(resolve => setTimeout(resolve, 300));

        // Ã‰tape 3 : CrÃ©ation des onglets FIN
        UIComponents.LoadingOverlay.setStep(2);

        // Sauvegarder depuis le mode actuellement actif (sources/test/def/CACHE)
        const result = await gsRun('saveElevesSnapshot', disposition, STATE.currentMode);
        if (!result?.success) {
          throw new Error(result?.error || 'Erreur serveur');
        }

        // Ã‰tape 4 : Formatage automatique
        UIComponents.LoadingOverlay.setStep(3);
        await new Promise(resolve => setTimeout(resolve, 300));

        // Ã‰tape 5 : Finalisation
        UIComponents.LoadingOverlay.setStep(4);
        await new Promise(resolve => setTimeout(resolve, 300));

        UIComponents.LoadingOverlay.hide();
        toast(`Onglets INT crÃ©Ã©s et formatÃ©s avec succÃ¨s pour ${Object.keys(disposition).length} classes`, 'success');

      } catch (error) {
        console.error('Erreur crÃ©ation onglets FIN:', error);
        UIComponents.LoadingOverlay.hide();
        toast('Erreur: ' + error.message, 'error');
      }
    }

    async function _saveInternal() {
      try {
        const disposition = exportDisposition();
        if (Object.keys(disposition).length === 0) throw new Error('Aucune classe Ã  sauvegarder');
        const result = await gsRun('saveElevesSnapshot', disposition, STATE.currentMode);
        if (!result?.success) throw new Error(result?.error || 'Erreur serveur');
        toast(`Onglets INT crÃ©Ã©s avec succÃ¨s`, 'success');
      } catch (error) {
        console.error(error);
        toast('Erreur: ' + error.message, 'error');
      }
    }

    // ========== ANCIENNES FONCTIONS MIGRÃ‰ES VERS App.* ==========
    // Les fonctions suivantes ont Ã©tÃ© dÃ©placÃ©es vers l'architecture modulaire :
    // - toast() -> App.UI.toast()
    // - adjustSimpleNamesFontSize() -> App.UI.adjustSimpleNamesFontSize()
    // - isRealClass() -> App.Utils.isRealClass()
    // - updateColumnStats() -> App.UI.updateColumnStats()
    // - updateAllColumnStats() -> App.UI.updateAllColumnStats()
    // - updateAdvancedStats() -> App.Stats.updateAdvancedStats()
    // - exportDisposition() -> App.Data.exportDisposition()
    // - saveImmediateCache() -> App.Data.saveImmediateCache()
    // - updateUndoRedoButtons() -> App.History.updateUndoRedoButtons()
    //
    // Des wrappers globaux sont disponibles pour compatibilitÃ© (voir section WRAPPERS ci-dessous)
    // undo() et redo() migrÃ©s vers App.History

    // ========== APPELS GOOGLE APPS SCRIPT ==========
    function gsRun(fnName, ...args) {
      return new Promise((resolve, reject) => {
        console.log(`ğŸ“¡ Appel fonction: ${fnName}`);

        try {
          // VÃ©rifier si on est dans l'environnement Google Apps Script
          if (typeof google !== 'undefined' && google.script && google.script.run) {
            const api = google.script.run;

            if (typeof api[fnName] === 'function') {
              // Appel correct : d'abord les handlers, puis la fonction
              api
                .withSuccessHandler((result) => {
                  resolve(result);
                })
                .withFailureHandler((error) => {
                  console.error(`âŒ ${fnName} erreur:`, error);
                  reject(error);
                })[fnName](...args);
              return;
            }
            // âœ… Fonction non disponible
            reject(new Error(`Fonction ${fnName} non disponible dans google.script.run`));
            return;
          }

          // âœ… Google Apps Script non disponible
          reject(new Error('Google Apps Script non disponible. Assurez-vous que l\'application est dÃ©ployÃ©e.'));

        } catch (error) {
          console.error(`ğŸ’¥ Erreur dans gsRun:`, error);
          reject(error);
        }
      });
    }

    // ========== FONCTION AFFICHAGE D'ERREUR UNIVERSELLE ==========
    function showErrorState(message, suggestions = []) {
      const board = document.getElementById('board');
      if (!board) {
        console.error('Ã‰lÃ©ment #board introuvable');
        return;
      }

      const defaultSuggestions = [
        'VÃ©rifiez que vos onglets se terminent par "TEST" (ex: 4Â°1TEST, 4Â°2TEST...)',
        'Assurez-vous que vos onglets contiennent des donnÃ©es avec au moins les colonnes ID et NOM',
        'CrÃ©ez un onglet "_STRUCTURE" avec les rÃ¨gles de rÃ©partition',
        'VÃ©rifiez la configuration de votre Google Sheet'
      ];

      const allSuggestions = suggestions.length > 0 ? suggestions : defaultSuggestions;

      board.innerHTML = `
    <div class="col-span-full">
      <div class="error-container">
        <div class="error-icon">
          <i class="fas fa-exclamation-triangle"></i>
        </div>
        <h2 class="error-title">Aucune donnÃ©e trouvÃ©e</h2>
        <div class="error-message">
          ${message}
        </div>
        <div class="error-suggestions">
          <h3 class="font-semibold mb-2">Suggestions pour rÃ©soudre le problÃ¨me :</h3>
          <ul>
            ${allSuggestions.map(s => `<li>${s}</li>`).join('')}
          </ul>
        </div>
        <div class="mt-4">
          <button onclick="attemptRefresh()" class="btn btn-primary">
            <i class="fas fa-sync"></i> RÃ©essayer
          </button>
          <button onclick="createDemoStructure()" class="btn btn-secondary ml-3">
            <i class="fas fa-plus"></i> CrÃ©er structure exemple
          </button>
        </div>
      </div>
    </div>
  `;
    }

    // ========== DÃ‰TECTION AUTOMATIQUE DU NIVEAU ==========
    function detectNiveau(data) {
      if (!data || data.length === 0) return '';

      // Analyser les noms de classes pour dÃ©tecter le niveau
      const classes = data.map(group => group.classe);
      const niveaux = new Set();

      classes.forEach(classe => {
        const match = classe.match(/^(\dÂ°)/);
        if (match) {
          niveaux.add(match[1]);
        }
      });

      if (niveaux.size === 1) {
        return Array.from(niveaux)[0];
      } else if (niveaux.size > 1) {
        return `Multi-niveaux (${Array.from(niveaux).join(', ')})`;
      }

      return 'Niveau non dÃ©tectÃ©';
    }

    // ========== FONCTION DE TRI DES COLONNES ==========
    function sortColumn(classe, sortType, direction = 'asc') {
      const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!dropZone) return;

      const cards = Array.from(dropZone.querySelectorAll('.student-card'));
      const students = cards.map(card => ({
        card,
        data: STATE.students[card.dataset.id]
      }));

      // facteur : +1 en asc, -1 en desc
      const f = direction === 'asc' ? 1 : -1;

      switch (sortType) {
        /* --- NOM ------------------------------------------------------- */
        case 'name':
          students.sort((a, b) => f * a.data.nom.localeCompare(b.data.nom));
          break;

        /* --- LV2 ------------------------------------------------------- */
        case 'lv2':
          students.sort((a, b) => {
            const ordre = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
            const iA = ordre.indexOf((a.data.lv2 || '').toUpperCase());
            const iB = ordre.indexOf((b.data.lv2 || '').toUpperCase());
            return f * ((iA === -1 ? 999 : iA) - (iB === -1 ? 999 : iB));
          });
          break;

        /* --- OPTION ---------------------------------------------------- */
        case 'option':
          students.sort((a, b) => {
            if (!a.data.opt && !b.data.opt) return 0;
            if (!a.data.opt) return f;   // Â« sans option Â» en bas quand asc
            if (!b.data.opt) return -f;
            return f * a.data.opt.localeCompare(b.data.opt);
          });
          break;

        /* --- SCORE COM ---------------------------------------------- */
        case 'score':
          students.sort((a, b) => {
            // Tri par score COM : meilleurs (4=Vert) en haut au premier clic
            const scoreA = a.data.scores.COM || 0;
            const scoreB = b.data.scores.COM || 0;
            return -f * (scoreB - scoreA); // meilleurs en haut en asc
          });
          break;
      }

      /* rÃ©-injection dans le DOM */
      dropZone.innerHTML = '';
      students.forEach(({ card }) => dropZone.appendChild(card));

      /* mÃ©morise le dernier tri */
      STATE.sortOrder[classe] = { type: sortType, dir: direction };
    }

    // ========== FONCTION DE VALIDATION DES MOUVEMENTS ==========
    function canMove(eleveId, srcClasse, dstClasse) {
      if (STATE.adminMode || srcClasse === dstClasse) return { ok: true };

      const e = STATE.students[eleveId];
      const dr = STATE.rules[dstClasse] || {};
      const dc = getCurrentClassContent(dstClasse);

      /* ğŸ”’ FIXE : jamais de dÃ©placement */
      if (e.mobilite === 'FIXE')
        return { ok: false, reason: `${e.nom} est FIXE dans sa classe` };

      /* ğŸ”’ CONDI : jamais de dÃ©placement individuel (conditionnÃ© par le groupe) */
      if (e.mobilite === 'CONDI')
        return { ok: false, reason: `${e.nom} est CONDI (groupe A${e.asso}) - utilisez le mode Admin` };

      /* ğŸ”’ PERMUT : BLOQUÃ‰ EN DRAG&DROP NORMAL */
      if (e.mobilite === 'PERMUT')
        return { ok: false, reason: `${e.nom} est PERMUT - utilisez le mode SWAP` };

      /* ğŸ”’ SPEC : mÃªme rÃ¨gle que FIXE  (option prioritaire) */
      if (e.mobilite === 'SPEC')
        return { ok: false, reason: `${e.nom} est SPEC (option obligatoire)` };

      /* ğŸ”’ DISSOCIATION : VÃ©rifier si code D dÃ©jÃ  prÃ©sent dans la classe cible */
      if (e.disso) {
        // VÃ©rifier si un autre Ã©lÃ¨ve avec le mÃªme code D est dÃ©jÃ  dans la classe cible
        const dissoDejaPresent = dc.some(id => {
          const s = STATE.students[id];
          return s && s.disso === e.disso;
        });

        if (dissoDejaPresent) {
          return { ok: false, reason: `Code D${e.disso} dÃ©jÃ  prÃ©sent dans ${dstClasse} - utilisez le mode SWAP` };
        }
        // Sinon, autoriser le dÃ©placement (pas de conflit)
      }

      /* CAPACITÃ‰ : on avertit mais on autorise */
      if (dr.capacity && dc.length >= dr.capacity) {
        return {
          ok: true,
          warn: `${dstClasse} dÃ©passe sa capacitÃ© (${dr.capacity})`
        };
      }

      /* ASSOCIATION */
      if (e.asso) {
        const grp = STATE.aGroups[`A${e.asso}`] || [];
        const encSrc = grp.filter(id => id !== eleveId)
          .some(id => document.querySelector(`.student-card[data-id="${id}"]`)
            ?.closest('.droppable-zone').dataset.classe === srcClasse);
        if (encSrc)
          return { ok: false, reason: `Groupe A${e.asso} doit bouger ensemble (mode Swap ou Admin)` };
      }

      /* VÃ‰RIFIER LV2 et OPTIONS */
      const checkTag = (tag, label) => {
        const tagUp = String(tag || '').trim().toUpperCase();
        if (!tagUp) return true;

        /* LV2 ESP autorisÃ© partout */
        if (label === 'LV2' && tagUp === 'ESP') return true;

        /* Aucune rÃ¨gle pour la classe âœ tout interdit */
        if (!dr.quotas || Object.keys(dr.quotas).length === 0) {
          return { ok: false, reason: `${label} ${tagUp} interdit dans ${dstClasse} (aucun quota dÃ©fini)` };
        }

        /* Tag absent dans les quotas âœ interdit */
        if (!(tagUp in dr.quotas)) {
          return { ok: false, reason: `${label} ${tagUp} interdit dans ${dstClasse}` };
        }

        /* Quota Ã  0 âœ interdit */
        if (dr.quotas[tagUp] === 0) {
          return { ok: false, reason: `${label} ${tagUp} interdit dans ${dstClasse} (quota 0)` };
        }

        /* Ã‰lÃ¨ves dÃ©jÃ  prÃ©sents avec ce tag */
        const currentCnt = dc.filter(id => {
          const s = STATE.students[id];
          return s && (String(s.lv2).toUpperCase() === tagUp ||
            String(s.opt).toUpperCase() === tagUp);
        }).length;

        if (currentCnt >= dr.quotas[tagUp]) {
          return { ok: false, reason: `Quota ${tagUp} atteint (${dr.quotas[tagUp]})` };
        }

        return true;
      };

      const r1 = checkTag(e.lv2, 'LV2');
      if (r1 !== true) return r1;
      console.log(eleveId, e.opt)
      const r2 = checkTag(e.opt, 'Option');
      if (r2 !== true) return r2;

      return { ok: true };
    }

    // ========== FONCTION UTILITAIRE POUR RÃ‰CUPÃ‰RER LE CONTENU D'UNE CLASSE ==========
    function getCurrentClassContent(classe) {
      const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!dropZone) return [];

      return Array.from(dropZone.querySelectorAll('.student-card'))
        .map(card => card.dataset.id);
    }

    // ========== FONCTIONS DE GESTION DES SWAPS ==========
    function canSwap(id1, id2) {
      const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
      const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);

      if (!card1 || !card2) return { ok: false, reason: 'Ã‰lÃ¨ve introuvable' };

      const classe1 = card1.closest('.droppable-zone').dataset.classe;
      const classe2 = card2.closest('.droppable-zone').dataset.classe;

      if (classe1 === classe2) return { ok: false, reason: 'MÃªme classe' };

      const eleve1 = STATE.students[id1];
      const eleve2 = STATE.students[id2];

      // Mode admin : tout est permis
      if (STATE.adminMode) return { ok: true };

      // âœ… PRIORITÃ‰ 1 : SWAP DE MÃŠME CONTRAINTE
      // Si les deux Ã©lÃ¨ves ont les mÃªmes contraintes (LV2, OPT, code D), le swap est autorisÃ©
      // Car cela ne change pas les quotas : on Ã©change juste deux Ã©lÃ¨ves identiques

      const lv2_1 = (eleve1.lv2 || '').toUpperCase();
      const lv2_2 = (eleve2.lv2 || '').toUpperCase();
      const opt_1 = (eleve1.opt || '').toUpperCase();
      const opt_2 = (eleve2.opt || '').toUpperCase();

      // ğŸ”’ CORRECTION BUG PERMUT/DISSO : VÃ©rifier que le swap ne crÃ©era pas de conflit DISSO
      // Les codes DISSO doivent Ãªtre SÃ‰PARÃ‰S (pas dans la mÃªme classe)
      const disso1 = (eleve1.disso || '').trim().toUpperCase();
      const disso2 = (eleve2.disso || '').trim().toUpperCase();

      // Si eleve1 a un code DISSO, vÃ©rifier que classe2 (sa future classe) ne contient pas dÃ©jÃ  ce code
      if (disso1) {
        const studentsInClasse2 = getCurrentClassContent(classe2);
        for (const studentId of studentsInClasse2) {
          if (studentId === id2) continue; // Ignorer eleve2 qui va quitter cette classe
          const otherStudent = STATE.students[studentId];
          if (!otherStudent) continue;
          const otherDisso = (otherStudent.disso || '').trim().toUpperCase();
          if (otherDisso === disso1) {
            return { ok: false, reason: `Conflit DISSO : ${classe2} contient dÃ©jÃ  un Ã©lÃ¨ve avec code ${disso1}` };
          }
        }
      }

      // Si eleve2 a un code DISSO, vÃ©rifier que classe1 (sa future classe) ne contient pas dÃ©jÃ  ce code
      if (disso2) {
        const studentsInClasse1 = getCurrentClassContent(classe1);
        for (const studentId of studentsInClasse1) {
          if (studentId === id1) continue; // Ignorer eleve1 qui va quitter cette classe
          const otherStudent = STATE.students[studentId];
          if (!otherStudent) continue;
          const otherDisso = (otherStudent.disso || '').trim().toUpperCase();
          if (otherDisso === disso2) {
            return { ok: false, reason: `Conflit DISSO : ${classe1} contient dÃ©jÃ  un Ã©lÃ¨ve avec code ${disso2}` };
          }
        }
      }

      // Cas 2 : MÃªme LV2 ET mÃªme OPT (ou pas d'OPT)
      const memeLV2 = lv2_1 === lv2_2 || (lv2_1 === 'ESP' && lv2_2 === 'ESP') || (!lv2_1 && !lv2_2);
      const memeOPT = opt_1 === opt_2 || (!opt_1 && !opt_2);

      if (memeLV2 && memeOPT) {
        return { ok: true };
      }

      // Si pas de mÃªmes contraintes, vÃ©rifier les mobilitÃ©s

      // FIXE et SPEC : jamais dÃ©plaÃ§ables en mode Swap (seulement en mode Force)
      if (eleve1.mobilite === 'FIXE' || eleve2.mobilite === 'FIXE') {
        return { ok: false, reason: 'FIXE ne peut pas bouger (utilisez le mode Force)' };
      }

      if (eleve1.mobilite === 'SPEC' || eleve2.mobilite === 'SPEC') {
        return { ok: false, reason: 'SPEC ne peut pas bouger (utilisez le mode Force)' };
      }

      // CONDI : jamais dÃ©plaÃ§ables (conditionnÃ©s par le groupe)
      if (eleve1.mobilite === 'CONDI' || eleve2.mobilite === 'CONDI') {
        return { ok: false, reason: 'CONDI ne peut pas bouger (groupe ASSO)' };
      }

      // PERMUT : vÃ©rifier compatibilitÃ©
      if (eleve1.mobilite === 'PERMUT' && eleve2.mobilite === 'PERMUT') {
        const lv1 = (eleve1.lv2 || '').toUpperCase();
        const lv2 = (eleve2.lv2 || '').toUpperCase();

        // âœ… La vÃ©rification DISSO a dÃ©jÃ  Ã©tÃ© effectuÃ©e ci-dessus (lignes 559-590)
        // Pas besoin de la refaire ici

        if (lv1 === 'ESP' || lv2 === 'ESP') {
          return { ok: true };
        }

        if (lv1 !== lv2) {
          return { ok: false, reason: `PERMUT : LV2 diffÃ©rentes` };
        }

        return { ok: true };
      }

      if (eleve1.mobilite === 'PERMUT' || eleve2.mobilite === 'PERMUT') {
        return { ok: false, reason: 'PERMUT ne peut Ã©changer qu\'avec un autre PERMUT' };
      }

      // VÃ©rifier codes D diffÃ©rents (un seul a un code D)
      if (eleve1.disso || eleve2.disso) {
        if (eleve1.disso) {
          // VÃ©rifier si D1 serait dans la mÃªme classe qu'un autre D1 aprÃ¨s le swap
          const dejaPresent = getCurrentClassContent(classe2).some(id => {
            const s = STATE.students[id];
            return s && s.disso === eleve1.disso && id !== id2;
          });

          if (dejaPresent) {
            return { ok: false, reason: `Code D${eleve1.disso} dÃ©jÃ  prÃ©sent dans ${classe2}` };
          }
        }

        if (eleve2.disso) {
          // VÃ©rifier si D2 serait dans la mÃªme classe qu'un autre D2 aprÃ¨s le swap
          const dejaPresent = getCurrentClassContent(classe1).some(id => {
            const s = STATE.students[id];
            return s && s.disso === eleve2.disso && id !== id1;
          });

          if (dejaPresent) {
            return { ok: false, reason: `Code D${eleve2.disso} dÃ©jÃ  prÃ©sent dans ${classe1}` };
          }
        }
      }

      // VÃ©rifier les quotas LV2 et OPT
      const dr1 = STATE.rules[classe2] || {};
      const dr2 = STATE.rules[classe1] || {};

      // VÃ©rifier LV2 de eleve1 dans classe2
      if (eleve1.lv2 && eleve1.lv2.toUpperCase() !== 'ESP') {
        const lv2Upper = eleve1.lv2.toUpperCase();
        if (!dr1.quotas || dr1.quotas[lv2Upper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve1.nom} (${lv2Upper}) interdit dans ${classe2}`);
          return { ok: false, reason: `${lv2Upper} interdit dans ${classe2}` };
        }
      }

      // VÃ©rifier LV2 de eleve2 dans classe1
      if (eleve2.lv2 && eleve2.lv2.toUpperCase() !== 'ESP') {
        const lv2Upper = eleve2.lv2.toUpperCase();
        if (!dr2.quotas || dr2.quotas[lv2Upper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve2.nom} (${lv2Upper}) interdit dans ${classe1}`);
          return { ok: false, reason: `${lv2Upper} interdit dans ${classe1}` };
        }
      }

      // VÃ©rifier OPT de eleve1 dans classe2
      if (eleve1.opt && eleve1.opt.trim()) {
        const optUpper = eleve1.opt.toUpperCase();
        if (!dr1.quotas || dr1.quotas[optUpper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve1.nom} (OPT ${optUpper}) interdit dans ${classe2}`);
          return { ok: false, reason: `Option ${optUpper} interdite dans ${classe2}` };
        }
      }

      // VÃ©rifier OPT de eleve2 dans classe1
      if (eleve2.opt && eleve2.opt.trim()) {
        const optUpper = eleve2.opt.toUpperCase();
        if (!dr2.quotas || dr2.quotas[optUpper] === 0) {
          console.log(`âŒ Swap refusÃ©: ${eleve2.nom} (OPT ${optUpper}) interdit dans ${classe1}`);
          return { ok: false, reason: `Option ${optUpper} interdite dans ${classe1}` };
        }
      }

      return { ok: true };
    }

    function performSwap(id1, id2) {
      const card1 = document.querySelector(`.student-card[data-id="${id1}"]`);
      const card2 = document.querySelector(`.student-card[data-id="${id2}"]`);

      if (!card1 || !card2) return;

      const zone1 = card1.closest('.droppable-zone');
      const zone2 = card2.closest('.droppable-zone');

      if (!zone1 || !zone2) return;

      // Animation de swap
      card1.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      card2.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';

      // Ã‰changer les cartes
      zone2.appendChild(card1);
      zone1.appendChild(card2);

      // Marquer qu'il y a eu une action utilisateur
      if (typeof markUserAction === 'function') {
        markUserAction();
      } else {
        STATE.has_user_action = true;
      }

      // Historique
      const swapAction = {
        type: 'swap',
        id1, id2,
        eleve1Name: STATE.students[id1]?.nom || 'Ã‰lÃ¨ve 1',
        eleve2Name: STATE.students[id2]?.nom || 'Ã‰lÃ¨ve 2',
        classe1: zone1.dataset.classe,
        classe2: zone2.dataset.classe,
        timestamp: new Date().toISOString()
      };
      STATE.history.push(swapAction);
      STATE.historyTimeline.push(swapAction);
      STATE.future = [];
      updateUndoRedoButtons();

      // Mettre Ã  jour le panneau historique
      updateHistoryPanel();

      // âœ… UNE SEULE mise Ã  jour des colonnes
      updateAllColumnStats();

      // âœ… UNE SEULE mise Ã  jour des stats avancÃ©es avec dÃ©lai
      setTimeout(() => updateAdvancedStats(), 150);

      // Feedback temps rÃ©el
      if (window.RealTimeFeedback) {
        window.RealTimeFeedback.updateMetrics();
      }

      // Sauvegarde
      if (STATE.currentMode === 'CACHE') {
        setTimeout(() => saveImmediateCache(), 200);
      }

      const eleve1 = STATE.students[id1];
      const eleve2 = STATE.students[id2];
      toast(`Swap rÃ©ussi entre ${eleve1.nom} et ${eleve2.nom}`, 'success');
    }

    function handleCardClick(e) {
      if (!STATE.swapMode) return;

      const card = e.currentTarget;
      const eleveId = card.dataset.id;
      const eleve = STATE.students[eleveId];

      // PremiÃ¨re sÃ©lection
      if (!STATE.swapFirst) {
        STATE.swapFirst = eleveId;
        card.classList.add('swap-mode');

        let msg = `${eleve.nom} sÃ©lectionnÃ©`;
        if (eleve.mobilite === 'PERMUT') msg += ' (PERMUT)';
        else if (eleve.disso) msg += ` (D${eleve.disso})`;
        msg += ' â€“ choisissez un Ã©lÃ¨ve Ã  Ã©changer';
        toast(msg, 'info');

        // Mettre en Ã©vidence les autres colonnes
        document.querySelectorAll('.droppable-zone').forEach(zone => {
          if (zone.dataset.classe !== card.closest('.droppable-zone').dataset.classe) {
            zone.classList.add('swap-target');
          }
        });
        return;
      }

      // DeuxiÃ¨me sÃ©lection
      const firstId = STATE.swapFirst;
      const firstCard = document.querySelector(`.student-card[data-id="${firstId}"]`);

      // MÃªme Ã©lÃ¨ve : annuler
      if (eleveId === firstId) {
        firstCard.classList.remove('swap-mode');
        document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
        STATE.swapFirst = null;
        return;
      }

      // VÃ©rifier et effectuer le swap
      const check = canSwap(firstId, eleveId);
      if (check.ok) {
        performSwap(firstId, eleveId);
      } else {
        toast(check.reason, 'error');
      }

      // Nettoyer l'Ã©tat
      firstCard.classList.remove('swap-mode');
      document.querySelectorAll('.student-card').forEach(c => c.classList.remove('swap-mode'));
      document.querySelectorAll('.droppable-zone').forEach(z => z.classList.remove('swap-target'));
      STATE.swapFirst = null;
    }

    // ========== SIMPLIFICATION DES NOMS COMPOSÃ‰S ==========

    function simplifierNomComplet(nom, prenom) {
      if (!nom && !prenom) return '';

      nom = (nom || '').trim().replace(/\s+/g, ' ');
      prenom = (prenom || '').trim().replace(/\s+/g, ' ');

      let finalNom = '';
      let finalPrenom = '';

      if (prenom) {
        finalNom = nom.split(/[\s-]+/).filter(Boolean)[0] || nom;
        finalPrenom = prenom.split(/[\s-]+/).filter(Boolean)[0] || prenom;
      } else if (nom) {
        const parts = nom.split(/\s+/).filter(Boolean);
        finalNom = parts[0];
        finalPrenom = parts.length >= 2 ? parts[parts.length - 1] : '';
      }

      let resultat = `${finalNom} ${finalPrenom}`.trim();

      const MAX_LENGTH = 25;
      if (resultat.length > MAX_LENGTH) {
        const availableForPrenom = MAX_LENGTH - finalNom.length - 1;
        if (availableForPrenom > 0) {
          resultat = `${finalNom} ${finalPrenom.substring(0, availableForPrenom - 1)}.`.trim();
        } else {
          resultat = finalNom.substring(0, MAX_LENGTH - 1) + '.';
        }
      }

      return resultat;
    }

    window.simplifierNomComplet = simplifierNomComplet;

    // ========== PHASE 3: FONCTIONS UTILITAIRES (DRY) ==========

    /**
     * Phase 3.1: CrÃ©e un badge standardisÃ© pour Ã©viter la duplication de code
     * @param {string} type - Type de badge ('lv2', 'opt', 'asso', 'disso', 'mobilite', 'dispo', 'gender')
     * @param {string} content - Contenu textuel du badge
     * @param {Object} options - Options {title, compact, className}
     * @returns {HTMLElement} Badge crÃ©Ã©
     */
    function createBadge(type, content, options = {}) {
      const badge = document.createElement('span');
      const { title = '', compact = false, className = '' } = options;

      // Configuration par type
      const configs = {
        lv2: {
          baseClass: 'mini-badge',
          extraClass: `badge-${content.toUpperCase()}`,
          displayContent: content.toUpperCase(),
          defaultTitle: `LV2: ${content}`
        },
        opt: {
          baseClass: 'mini-badge',
          extraClass: `badge-${content.toUpperCase()}`,
          displayContent: content.toUpperCase(),
          defaultTitle: `Option: ${content}`
        },
        disso: {
          baseClass: 'mini-badge badge-disso',
          displayContent: content.replace(/^D/i, 'D'),
          defaultTitle: `Dissociation: ${content}`
        },
        asso: {
          baseClass: 'mini-badge badge-asso',
          displayContent: content.replace(/^A/i, 'A'),
          defaultTitle: `Association: ${content}`
        },
        mobilite: {
          baseClass: 'mini-badge badge-mobilite',
          extraClass: compact ? 'badge-compact' : '',
          displayContent: content,
          defaultTitle: `MobilitÃ©: ${content}`
        },
        dispo: {
          baseClass: 'badge-dispo',
          displayContent: content.toUpperCase().trim(),
          defaultTitle: `Dispositif: ${content}`
        },
        gender: {
          baseClass: 'badge-sexe',
          extraClass: `sexe-${content}`,
          displayContent: content === 'F' ? 'â™€' : 'â™‚',
          defaultTitle: ''
        }
      };

      const config = configs[type];
      if (!config) {
        console.error(`Unknown badge type: ${type}`);
        return badge;
      }

      // Construire className
      const classes = [config.baseClass, config.extraClass, className].filter(Boolean).join(' ');
      badge.className = classes;
      badge.textContent = config.displayContent;
      badge.title = title || config.defaultTitle;

      return badge;
    }

    /**
     * Phase 3.2: Compte les Ã©lÃ¨ves par sexe (F/M)
     * @param {Array} eleves - Liste d'Ã©lÃ¨ves
     * @returns {Object} {total, F, M}
     */
    function countBySex(eleves) {
      const F = eleves.filter(e => e.sexe === 'F').length;
      const M = eleves.filter(e => e.sexe === 'M').length;
      return { total: eleves.length, F, M };
    }

    /**
     * Phase 3.3: VÃ©rifie si un Ã©lÃ¨ve peut Ãªtre placÃ© dans une classe sans conflit DISSO
     * @param {string} eleveId - ID de l'Ã©lÃ¨ve Ã  placer
     * @param {string} targetClass - Classe cible
     * @param {Object} allEleves - Tous les Ã©lÃ¨ves (STATE.students)
     * @returns {boolean} true si conflit DISSO dÃ©tectÃ©
     */
    function checkDissoConflict(eleveId, targetClass, allEleves) {
      const eleve = allEleves[eleveId];
      if (!eleve || !eleve.disso) return false;

      const targetZone = document.querySelector(`[data-classe="${targetClass}"] .droppable-zone`);
      if (!targetZone) return false;

      const classStudents = Array.from(targetZone.querySelectorAll('.student-card'))
        .map(c => allEleves[c.dataset.id])
        .filter(Boolean);

      return classStudents.some(s => s.disso === eleve.disso);
    }

    /**
     * Phase 3.4: Met Ã  jour les statistiques de toutes les classes
     */
    function updateAllStats() {
      document.querySelectorAll('.class-column').forEach(column => {
        const zone = column.querySelector('.droppable-zone');
        if (!zone) return;

        const eleves = Array.from(zone.querySelectorAll('.student-card'))
          .map(c => STATE.students[c.dataset.id])
          .filter(Boolean);

        const counts = countBySex(eleves);
        column.querySelector('.count').textContent = counts.total;
        column.querySelector('.count-f').textContent = counts.F;
        column.querySelector('.count-m').textContent = counts.M;
      });
    }

    // ========== FONCTION DE CRÃ‰ATION DES CARTES Ã‰LÃˆVES ==========
    function createStudentCard(eleve) {
      /* --- STOP "CARTE VIDE" : on ignore les enregistrements sans id --- */
      if (!eleve || !eleve.id || !eleve.id.trim()) return null;
      /* ---------------------------------------------------------------- */

      const template = document.querySelector('#tpl-carte-eleve');
      const card = template.content.cloneNode(true).children[0];

      card.dataset.id = eleve.id;
      card.classList.add(`sexe-${eleve.sexe}`);

      // Attributs ARIA pour la carte Ã©lÃ¨ve
      const nomCompletAria = eleve.prenom ? `${eleve.nom} ${eleve.prenom}` : eleve.nom;
      card.setAttribute('role', 'listitem');
      card.setAttribute('aria-label', nomCompletAria);
      card.setAttribute('aria-grabbed', 'false');

      // ========== MODE SIMPLE : FOND BLANC + POLICE COULEUR SEXE + SOULIGNE ROUGE SI COM=1 ==========
      if (STATE.viewMode === 'simple') {
        card.classList.add('simple-mode');
        card.innerHTML = `<div class="simple-line">
      <span class="student-simple-name"></span>
    </div>`;
        const simpleLine = card.querySelector('.simple-line');
        const nameEl = card.querySelector('.student-simple-name');

        // Gender badge using createBadge()
        if (document.body.classList.contains('gender-badges')) {
          simpleLine.insertBefore(createBadge('gender', eleve.sexe), nameEl);
        }

        // Nom complet simplifiÃ©
        let nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);

        // Couleur de police selon sexe
        let couleurTexte = '#333'; // Gris foncÃ© par dÃ©faut
        if (eleve.sexe === 'F') {
          couleurTexte = '#ec4899'; // Rose pour F
        } else if (eleve.sexe === 'M') {
          couleurTexte = '#3b82f6'; // Bleu pour M
        }

        // SoulignÃ© rouge si score COM = 1
        let soulignement = 'none';
        let couleurSoulignement = '';
        if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
          soulignement = 'underline';
          couleurSoulignement = '#FF0000'; // Rouge
        }

        // Appliquer les styles
        nameEl.textContent = nomComplet;
        nameEl.style.display = 'block';
        nameEl.style.textAlign = 'center';
        nameEl.style.fontSize = '1.1rem';
        nameEl.style.fontWeight = '600';
        nameEl.style.padding = '8px';
        nameEl.style.color = couleurTexte;
        nameEl.style.textDecoration = soulignement;
        nameEl.style.overflow = 'hidden';
        nameEl.style.textOverflow = 'ellipsis';
        nameEl.style.whiteSpace = 'nowrap';
        nameEl.style.maxWidth = '100%';
        if (soulignement === 'underline') {
          nameEl.style.textDecorationColor = couleurSoulignement;
          nameEl.style.textDecorationThickness = '3px';
          nameEl.style.textUnderlineOffset = '3px';
        }

        card.style.background = '#fff'; // Fond blanc pour tous
        card.style.border = '1px solid rgba(0,0,0,0.1)';
        card.style.borderRadius = '6px';
      } else if (STATE.viewMode === 'essential') {
        // Mode essentiel : nom + badges essentiels (pas d'options ni scores)
        const fullNameElement = card.querySelector('.student-fullname');
        const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);
        fullNameElement.textContent = nomComplet;

        // Gender badge using createBadge()
        if (document.body.classList.contains('gender-badges')) {
          fullNameElement.parentNode.insertBefore(createBadge('gender', eleve.sexe), fullNameElement);
        }

        // NOM EN ROUGE si score COM = 1
        if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
          fullNameElement.style.color = '#FF0000';
          fullNameElement.style.fontWeight = '700';
        }

        // Badges essentiels : LV2, OPT, DISSO, ASSO (PAS DE DISPO)
        const allBadgesContainer = card.querySelector('.all-badges');
        allBadgesContainer.style.justifyContent = 'center';

        let totalBadges = 0;
        if (eleve.mobilite && eleve.mobilite !== 'LIBRE') totalBadges++;
        if (eleve.disso) totalBadges++;
        if (eleve.asso) totalBadges++;
        if (eleve.lv2) totalBadges++;
        const compactMode = totalBadges > 3;

        // Badge MobilitÃ© (using createBadge)
        if (eleve.mobilite && eleve.mobilite !== 'LIBRE') {
          let mobText = eleve.mobilite;
          if (compactMode) {
            const abrevMap = { 'CONDI': 'CO', 'FIXE': 'FI', 'PERMUT': 'PER', 'SPEC': 'SP' };
            mobText = abrevMap[eleve.mobilite] || eleve.mobilite;
          }
          allBadgesContainer.appendChild(createBadge('mobilite', mobText, { compact: compactMode }));
        }

        // Badge Dissociation (using createBadge)
        if (eleve.disso) {
          allBadgesContainer.appendChild(createBadge('disso', eleve.disso));
        }

        // Badge Association (using createBadge)
        if (eleve.asso) {
          allBadgesContainer.appendChild(createBadge('asso', eleve.asso));
        }

        // Badge LV2 (using createBadge)
        if (eleve.lv2 && eleve.lv2.trim()) {
          allBadgesContainer.appendChild(createBadge('lv2', eleve.lv2));
        }

        // Badge OPT (using createBadge)
        if (eleve.opt && eleve.opt.trim()) {
          allBadgesContainer.appendChild(createBadge('opt', eleve.opt));
        }

        // Source uniquement (pas de scores)
        card.querySelector('.source-class').textContent = eleve.source || '';
        card.querySelector('.scores').innerHTML = '';
      } else {
        // ========== MODE COMPLETE: NOM + LV2/OPT + BADGES SCORES ==========
        const fullNameElement = card.querySelector('.student-fullname');
        const nomComplet = simplifierNomComplet(eleve.nom, eleve.prenom);

        // Gender badge using createBadge()
        if (document.body.classList.contains('gender-badges')) {
          fullNameElement.parentNode.insertBefore(createBadge('gender', eleve.sexe), fullNameElement);
        }

        fullNameElement.textContent = nomComplet;
        fullNameElement.className = 'student-fullname'; // Reset class in case it was modified

        // NOM EN ROUGE si score COM = 1
        if (eleve.scores && eleve.scores.COM && parseInt(eleve.scores.COM) === 1) {
          fullNameElement.style.color = '#FF0000';
          fullNameElement.style.fontWeight = '700';
        }

        // Badge DISPO (using createBadge)
        const dispoContainer = card.querySelector('.badge-dispo-container');
        if (eleve.dispo && eleve.dispo.trim()) {
          dispoContainer.appendChild(createBadge('dispo', eleve.dispo));
        }

        // ========== LIGNE 2: TOUS LES BADGES (LV2, OPT, DISSO, ASSO) ==========
        const allBadgesContainer = card.querySelector('.all-badges');
        allBadgesContainer.style.justifyContent = 'center';

        // Badges using createBadge()
        if (eleve.lv2 && eleve.lv2.trim()) {
          allBadgesContainer.appendChild(createBadge('lv2', eleve.lv2));
        }

        if (eleve.opt && eleve.opt.trim()) {
          allBadgesContainer.appendChild(createBadge('opt', eleve.opt));
        }

        if (eleve.disso) {
          allBadgesContainer.appendChild(createBadge('disso', eleve.disso));
        }

        if (eleve.asso) {
          allBadgesContainer.appendChild(createBadge('asso', eleve.asso));
        }

        // ========== LIGNE 3: Source + Scores ==========
        card.querySelector('.source-class').textContent = eleve.source || '';

        // Badges scores COM/TRA/PART/ABS avec lettres et couleurs OU micro-jauges
        const scoresContainer = card.querySelector('.scores');

        // Mode Jauges Visuelles (Nouveau de la Phase 6 UX/UI)
        if (document.body.classList.contains('show-micro-charts')) {
          scoresContainer.className = 'scores-charts-container flex flex-col gap-1 mt-1 w-full px-1';

          const scoreConfig = [
            { key: 'COM', label: 'Com', colorClass: 'bg-indigo-500' },
            { key: 'TRA', label: 'Tra', colorClass: 'bg-cyan-500' },
            { key: 'PART', label: 'Par', colorClass: 'bg-emerald-500' },
            { key: 'ABS', label: 'Abs', colorClass: 'bg-amber-500' }
          ];

          scoreConfig.forEach(({ key, label, colorClass }) => {
            const value = eleve.scores[key] || 0;
            if (value > 0) {
              const rWidth = (value / 4) * 100;
              // On colore en rouge si la perf est critique (1) sauf pour les absences oÃ¹ c'est l'inverse dans certaines logiques, mais gardons simple:
              const finalColor = (value === 1) ? 'bg-red-500' : colorClass;

              const row = document.createElement('div');
              row.className = 'flex items-center gap-1.5 w-full text-[9px] leading-none';
              row.innerHTML = `
                <span class="w-5 font-bold text-slate-500 dark:text-slate-400 text-right">${label}</span>
                <div class="flex-1 h-1.5 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
                  <div class="h-full rounded-full ${finalColor}" style="width: ${rWidth}%"></div>
                </div>
              `;
              row.title = `${label}: ${value}/4`;
              scoresContainer.appendChild(row);
            }
          });

        } else {
          // Mode classique (Pastilles Texte)
          scoresContainer.className = 'scores flex flex-wrap gap-1 mt-1';
          const scoreMap = [
            { key: 'COM', label: 'Comportement', letter: 'C' },
            { key: 'TRA', label: 'Travail', letter: 'T' },
            { key: 'PART', label: 'Participation', letter: 'P' },
            { key: 'ABS', label: 'Absences', letter: 'A' }
          ];
          scoreMap.forEach(({ key, label, letter }) => {
            const value = eleve.scores[key];
            if (value && value > 0) {
              const pill = document.createElement('div');
              pill.className = `score-pill score-${value}`;
              pill.textContent = letter; // Afficher la LETTRE (C, T, P, A)
              pill.title = `${label}: ${value}/4`;
              scoresContainer.appendChild(pill);
            }
          });
        }
      }

      // Event listeners pour drag & drop et swap
      card.addEventListener('dragstart', handleDragStart);
      card.addEventListener('dragend', handleDragEnd);
      card.addEventListener('click', handleCardClick);

      // ğŸ”’ Indication visuelle pour les Ã©lÃ¨ves FIXE/SPEC/CONDI/PERMUT (le blocage est gÃ©rÃ© par le filtre Sortable)
      if (!STATE.adminMode && eleve.mobilite && ['FIXE', 'SPEC', 'CONDI', 'PERMUT'].includes(eleve.mobilite)) {
        card.classList.add('non-draggable');
        card.style.opacity = '0.85';
        card.title = `${eleve.nom} est ${eleve.mobilite} - Utilisez le mode Swap ou le mode Force pour le dÃ©placer`;
      }

      return card;
    }

    // ========== FONCTION DE CRÃ‰ATION DES COLONNES DE CLASSE ==========
    function createClassColumn(classe, eleves) {
      // On retire d'emblÃ©e les enregistrements "vides"
      const clean = eleves.filter(e => e && e.id && e.id.trim());

      const column = document.querySelector('#tpl-classe-col')
        .content.cloneNode(true).children[0];

      // Attributs ARIA pour la colonne
      const classHeader = column.querySelector('.class-header');
      if (classHeader) {
        classHeader.id = `class-header-${classe}`;
      }
      column.setAttribute('role', 'region');
      column.setAttribute('aria-labelledby', `class-header-${classe}`);

      const counts = countBySex(clean);
      column.querySelector('.classe-name').textContent = classe;
      column.querySelector('.count').textContent = counts.total;
      column.querySelector('.count-f').textContent = counts.F;
      column.querySelector('.count-m').textContent = counts.M;

      const dropZone = column.querySelector('.droppable-zone');
      dropZone.dataset.classe = classe;
      dropZone.setAttribute('role', 'list');
      dropZone.setAttribute('aria-label', `Liste des Ã©lÃ¨ves de ${classe}`);

      // Boutons de tri
      column.querySelectorAll('.sort-btn').forEach(btn => {
        btn.addEventListener('click', e => {
          const sortType = e.currentTarget.dataset.sort;
          const prev = STATE.sortOrder[classe] || {};
          const dir = (prev.type === sortType && prev.dir === 'asc') ? 'desc' : 'asc';

          sortColumn(classe, sortType, dir);

          // Feedback visuel
          column.querySelectorAll('.sort-btn').forEach(b => {
            const arrow = b.querySelector('.sort-arrow');
            if (b === e.currentTarget) {
              b.classList.add('active');
              arrow.textContent = dir === 'asc' ? 'â†‘' : 'â†“';
            } else {
              b.classList.remove('active');
              arrow.textContent = 'â‡…';
            }
          });
        });
      });

      // Restaurer l'Ã©tat visuel du tri si existant
      const currentSort = STATE.sortOrder[classe];
      if (currentSort) {
        column.querySelectorAll('.sort-btn').forEach(btn => {
          const arrow = btn.querySelector('.sort-arrow');
          if (btn.dataset.sort === currentSort.type) {
            btn.classList.add('active');
            arrow.textContent = currentSort.dir === 'asc' ? 'â†‘' : 'â†“';
          }
        });
      }

      // Drag-and-drop
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('drop', handleDrop);
      dropZone.addEventListener('dragleave', handleDragLeave);

      const sortable = new Sortable(dropZone, {
        group: 'students',
        animation: 150,
        ghostClass: 'opacity-50',
        dragClass: 'dragging',
        // ğŸ”’ Filtre pour bloquer le drag des Ã©lÃ¨ves FIXE/SPEC/CONDI/PERMUT (sauf en mode admin)
        filter: function (evt, target) {
          if (!target || !target.dataset) {
            console.warn('âš ï¸ Filtre Sortable: target invalide', target);
            return true; // Bloquer par sÃ©curitÃ©
          }

          // ğŸ”¥ VÃ‰RIFICATION MODE FORCE
          console.log('ğŸ” Filtre Sortable - STATE.adminMode =', STATE?.adminMode);
          if (STATE.adminMode) {
            console.log('ğŸ”¥ MODE FORCE ACTIF - Drag autorisÃ© sans vÃ©rification');
            return false; // En mode admin, tout est draggable
          }

          const eleveId = target.dataset.id;
          if (!eleveId) return false; // Pas d'ID, autoriser (ne devrait pas arriver)
          const eleve = STATE.students[eleveId];
          if (eleve && eleve.mobilite && ['FIXE', 'SPEC', 'CONDI', 'PERMUT'].includes(eleve.mobilite)) {
            console.log(`ğŸ”’ Drag bloquÃ© pour ${eleve.nom} (${eleve.mobilite}) - MODE FORCE INACTIF`);
            toast(`${eleve.nom} est ${eleve.mobilite} - Utilisez le mode Swap ou le mode Force`, 'warning');
            return true; // Bloquer le drag
          }
          return false; // Autoriser le drag
        },
        onEnd: handleSortEnd,
        onStart: (evt) => {
          // Stocker l'Ã©lÃ©ment en cours de dÃ©placement
          STATE.draggingElement = evt.item;
          STATE.dragStartZone = evt.from;
        },
        onMove: (evt) => {
        }
      });



      // Cartes Ã©lÃ¨ves
      clean.forEach(e => {
        const c = createStudentCard(e);
        if (c) dropZone.appendChild(c);
      });

      // Adaptation dynamique de la taille des noms en vue simplifiÃ©e
      setTimeout(() => adjustSimpleNamesFontSize(dropZone), 0);
      return column;
    }

    // ========== HANDLERS DRAG & DROP ==========
    function handleDragStart(e) {
      if (STATE.swapMode) return; // Pas de drag en mode swap

      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', e.target.dataset.id);
      // Mettre Ã  jour aria-grabbed
      e.target.setAttribute('aria-grabbed', 'true');
      e.target.classList.add('dragging');
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      // Remettre aria-grabbed Ã  false
      e.target.setAttribute('aria-grabbed', 'false');
      document.querySelectorAll('.drag-over, .drop-forbidden').forEach(el => {
        el.classList.remove('drag-over', 'drop-forbidden');
      });
    }

    function handleDragOver(e) {
      if (STATE.swapMode) return;
      e.preventDefault();

      // VÃ©rifier si le drop est autorisÃ©
      const draggedId = e.dataTransfer.getData('text/plain') ||
        document.querySelector('.dragging')?.dataset.id;

      if (draggedId) {
        const draggedCard = document.querySelector(`.student-card[data-id="${draggedId}"]`);
        if (draggedCard) {
          const srcClasse = draggedCard.closest('.droppable-zone').dataset.classe;
          const dstClasse = e.currentTarget.dataset.classe;

          const check = canMove(draggedId, srcClasse, dstClasse);

          if (check.ok || STATE.adminMode) {
            e.currentTarget.classList.add('drag-over');
            e.currentTarget.classList.remove('drop-forbidden');

            // PrÃ©visualiser l'impact du dÃ©placement
            if (window.RealTimeFeedback && srcClasse !== dstClasse) {
              window.RealTimeFeedback.previewMove(draggedId, dstClasse);
            }
          } else {
            e.currentTarget.classList.add('drop-forbidden');
            e.currentTarget.classList.remove('drag-over');

            // RÃ©initialiser les changements si drop interdit
            if (window.RealTimeFeedback) {
              window.RealTimeFeedback.resetChanges();
            }
          }
        }
      }
    }

    function handleDragLeave(e) {
      if (e.target === e.currentTarget) {
        e.currentTarget.classList.remove('drag-over', 'drop-forbidden');

        // RÃ©initialiser les changements quand on quitte la zone
        if (RealTimeFeedback) {
          RealTimeFeedback.resetChanges();
        }
      }
    }

    function handleDrop(e) {
      if (STATE.swapMode) return;
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over', 'drop-forbidden');
    }

    // ========== handleSortEnd (version finale en bas du fichier, suppression de l'ancienne version) ==========
    window.handleSortEnd = function (evt) {
      console.log('ğŸ¯ handleSortEnd CLEAN');

      if (STATE.swapMode) return;

      const eleveId = evt.item.dataset.id;
      const oldClasse = evt.from.dataset.classe;
      const newClasse = evt.to.dataset.classe;

      // Si mÃªme classe, juste mise Ã  jour des colonnes
      if (oldClasse === newClasse) {
        updateAllColumnStats(); // â† CET APPEL MANQUE PEUT-ÃŠTRE
        if (window.RealTimeFeedback) window.RealTimeFeedback.updateMetrics();
        return;
      }

      // Marquer qu'il y a eu une action utilisateur (dÃ©placement entre classes)
      if (typeof markUserAction === 'function') {
        markUserAction();
      } else {
        STATE.has_user_action = true;
      }

      // ğŸ”¥ MODE FORCE : Tout est autorisÃ© sans vÃ©rification
      if (STATE.adminMode) {
        console.log('ğŸ”¥ MODE FORCE: DÃ©placement autorisÃ© sans vÃ©rification');
      } else {
        // Mode normal : vÃ©rifier les contraintes
        const check = canMove(eleveId, oldClasse, newClasse);

        if (!check.ok) {
          evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex] || null);
          toast(check.reason, 'error');
          updateAllColumnStats();
          return;
        }

        if (check.warn) {
          toast(check.warn, 'warning');
        }
      }

      // Historique
      const moveAction = {
        type: 'move',
        eleveId,
        eleveName: STATE.students[eleveId]?.nom || 'Ã‰lÃ¨ve',
        oldClasse,
        newClasse,
        oldIndex: evt.oldIndex,
        newIndex: evt.newIndex,
        timestamp: new Date().toISOString()
      };
      STATE.history.push(moveAction);
      STATE.historyTimeline.push(moveAction);
      STATE.future = [];
      updateUndoRedoButtons();

      // Mettre Ã  jour le panneau historique
      updateHistoryPanel();

      // âœ… UNE SEULE mise Ã  jour des colonnes
      updateAllColumnStats(); // â† CET APPEL DOIT ÃŠTRE PRÃ‰SENT

      // âœ… UNE SEULE mise Ã  jour des stats avancÃ©es avec dÃ©lai
      setTimeout(() => updateAdvancedStats(), 150);

      // Feedback temps rÃ©el
      if (RealTimeFeedback) RealTimeFeedback.updateMetrics();

      // Sauvegarde
      if (STATE.currentMode === 'CACHE') {
        setTimeout(() => saveImmediateCache(), 200);
      }
    };

    // ========== FONCTION MANQUANTE - Chargement des donnÃ©es selon le mode ==========
    async function loadDataForMode(mode) {
      showSpinner();
      try {
        // ğŸ¯ Appel Ã  l'adaptateur SAS dÃ©diÃ©
        const result = await gsRun('getClassesDataForInterfaceV2', mode);
        console.log('ğŸ¯ RÃ‰SULTAT SAS getClassesDataForInterfaceV2:', JSON.stringify(result, null, 2));
        console.log('ğŸ” Type de result:', typeof result);
        console.log('ğŸ” result.success:', result?.success);
        console.log('ğŸ” result.data (Array):', result?.data);
        console.log('ğŸ” result.rules (_STRUCTURE):', result?.rules);
        console.log('ğŸ” Nombre de classes:', result?.data?.length);

        if (!result || !result.success) {
          console.error('âŒ Erreur lors du chargement des donnÃ©es:', result?.error);
          showErrorState(result?.error || 'Erreur inconnue');
          return false;
        }

        // Stocker les donnÃ©es dans STATE
        STATE.originalData = result.data;
        STATE.rules = result.rules || {};
        STATE.niveau = detectNiveau(result.data);
        // Mettre Ã  jour l'interface
        const niveauElement = document.getElementById('niveau-detected');
        if (niveauElement) {
          niveauElement.textContent = STATE.niveau;
        }
        // CrÃ©er le dictionnaire des Ã©lÃ¨ves et les groupes
        STATE.students = {};
        STATE.aGroups = {};
        result.data.forEach(group => {
          group.eleves.forEach(eleve => {
            STATE.students[eleve.id] = eleve;
            // Grouper les associations
            if (eleve.asso) {
              const key = `A${eleve.asso}`;
              if (!STATE.aGroups[key]) STATE.aGroups[key] = [];
              STATE.aGroups[key].push(eleve.id);
            }
          });
        });
        // Afficher les colonnes
        renderBoard(result.data);
        return true;
      } catch (error) {
        console.error('ğŸ’¥ Erreur fatale:', error);
        return false;
      } finally {
        hideSpinner();
      }
    }

    // ========== FONCTION - Affichage des colonnes/classes ==========
    function renderBoard(data) {
      const board = document.getElementById('board');
      if (!board) {
        console.error('Ã‰lÃ©ment #board introuvable');
        return;
      }

      board.innerHTML = '';
      if (!data || data.length === 0) {
        showErrorState('Aucune classe trouvÃ©e');
        return;
      }

      /* --- tri naturel des intitulÃ©s "6Â°1", "6Â°2", â€¦ --- */
      const sortedData = data.slice().sort((a, b) => {
        const ma = a.classe.match(/(\d+)Â°(\d+)/);
        const mb = b.classe.match(/(\d+)Â°(\d+)/);
        if (ma && mb) {
          const nivA = +ma[1], nivB = +mb[1];
          if (nivA !== nivB) return nivA - nivB;
          return +ma[2] - +mb[2];
        }
        return a.classe.localeCompare(b.classe);
      });

      /* --- crÃ©ation des colonnes --- */
      sortedData.forEach(group => {
        const col = createClassColumn(group.classe, group.eleves);
        if (col) board.appendChild(col);
      });

      /* --- ajustements de prÃ©sentation --- */
      setTimeout(resizeCards, 100);
      updateAllColumnStats();              // <-- nouvelle ligne : compteurs Ã  jour !

      if (STATE.viewMode === 'simple') {
        setTimeout(() => {
          document.querySelectorAll('.droppable-zone')
            .forEach(zone => adjustSimpleNamesFontSize(zone));
        }, 120);
      }

      if (window.applyLisibilitePreferences) {
        window.applyLisibilitePreferences();
      }

      /* --- initialisation des graphiques --- */
      setTimeout(() => {
        if (typeof initCharts === 'function') {
          initCharts();
        }
      }, 200);
    }

    // ========== FONCTION MANQUANTE - AFFICHAGE DU BADGE DE MODE ==========
    function showModeBadge(mode) {
      const badge = document.getElementById('modeBadge');
      if (badge) {
        // DÃ©terminer le label et la couleur selon le mode
        let label = 'MODE ' + mode;
        let bgColor = '#3b82f6'; // Bleu par dÃ©faut

        switch (mode) {
          case 'TEST':
            label = 'ğŸ“š TEST (Classes test)';
            bgColor = '#3b82f6'; // Bleu
            break;
          case 'PREVIOUS':
            label = 'ğŸ“‹ PREVIOUS (AnnÃ©e passÃ©e)';
            bgColor = '#8b5cf6'; // Violet
            break;
          case 'FINAL':
            label = 'âœ… FINAL (Classes finales)';
            bgColor = '#10b981'; // Vert
            break;
          // Anciens modes pour rÃ©trocompatibilitÃ©
          case 'CACHE':
            label = 'MODE CACHE';
            bgColor = '#f59e0b'; // Orange
            break;
          case 'INT':
            label = 'MODE INT';
            bgColor = '#10b981'; // Vert
            break;
        }

        badge.textContent = label;
        badge.style.background = bgColor;
        badge.style.color = 'white';
        badge.classList.remove('hidden');
      }
    }

    // ========== FONCTION - Badge de sauvegarde ==========
    function updateSaveBadgeUI() {
      const el = document.getElementById('autosaveBadge');
      if (!el) return;
      if (STATE.last_save_ts) {
        const d = new Date(STATE.last_save_ts);
        el.textContent = `ğŸ’¾ SauvegardÃ© ${d.getHours()}h${String(d.getMinutes()).padStart(2, '0')}`;
      } else {
        el.textContent = `ğŸ’¾ Jamais`;
      }
    }

    // ========== FONCTIONS MANQUANTES - Auto-save avec dÃ©bounce intelligent ==========

    // Timer pour le dÃ©bounce intelligent
    let autoSaveDebounceTimer = null;

    /**
     * DÃ©marre l'auto-save avec dÃ©bounce intelligent
     * Sauvegarde 30 secondes aprÃ¨s la derniÃ¨re action utilisateur
     */
    function startAutoSave() {
      console.log('ğŸ”„ Auto-save CACHE activÃ© (dÃ©bounce 30s aprÃ¨s derniÃ¨re action)');

      // Fonction pour planifier la sauvegarde
      window.scheduleAutoSave = function () {
        // Annuler le timer prÃ©cÃ©dent
        if (autoSaveDebounceTimer) {
          clearTimeout(autoSaveDebounceTimer);
        }

        // Planifier une nouvelle sauvegarde dans 30 secondes
        autoSaveDebounceTimer = setTimeout(async () => {
          if (typeof window.saveImmediateCache === 'function') {
            console.log('â° DÃ©clenchement auto-save (30s aprÃ¨s derniÃ¨re action)');
            await window.saveImmediateCache();
          }
        }, 30000); // 30 secondes
      };

      // DÃ©marrer le premier cycle
      window.scheduleAutoSave();
    }

    function stopAutoSave() {
      if (autoSaveDebounceTimer !== null) {
        clearTimeout(autoSaveDebounceTimer);
        autoSaveDebounceTimer = null;
        console.log('â¹ï¸ Auto-save arrÃªtÃ©');
      }

      // Nettoyer la fonction globale
      if (window.scheduleAutoSave) {
        delete window.scheduleAutoSave;
      }
    }

    // ========== FONCTION MANQUANTE - VÃ©rifier le cache ==========
    async function checkCache() {
      const restoreBlock = document.getElementById('restoreCacheBlock');
      const lastDate = document.getElementById('lastCacheDate');

      // 1. VÃ©rifier d'abord le localStorage
      const cached = localStorage.getItem('cache-data');
      if (cached) {
        try {
          const data = JSON.parse(cached);
          if (restoreBlock) restoreBlock.classList.remove('hidden');
          if (lastDate) {
            lastDate.textContent = new Date(data.date).toLocaleString('fr-FR');
          }
          return; // On a trouvÃ© des donnÃ©es dans le localStorage
        } catch (e) {
          console.error('Cache localStorage invalide:', e);
        }
      }

      // 2. Si pas de localStorage, vÃ©rifier le backend (PropertiesService)
      try {
        console.log('ğŸ” VÃ©rification de la sauvegarde automatique depuis le backend...');
        const backendCache = await gsRun('getLastCacheInfo');

        if (backendCache && backendCache.exists && backendCache.date) {
          if (restoreBlock) restoreBlock.classList.remove('hidden');
          if (lastDate) {
            const date = new Date(backendCache.date);
            lastDate.textContent = date.toLocaleString('fr-FR');
          }
        } else {
          console.log('â„¹ï¸ Aucune sauvegarde automatique trouvÃ©e');
          if (restoreBlock) restoreBlock.classList.add('hidden');
        }
      } catch (error) {
        console.error('âŒ Erreur lors de la vÃ©rification du cache backend:', error);
      }
    }

    // ========== FONCTION MANQUANTE - Restaurer le cache ==========
    async function restoreCache() {
      const cached = localStorage.getItem('cache-data');
      if (!cached) return;
      try {
        const data = JSON.parse(cached);
        localStorage.setItem('mode-selection', data.mode);
        await initRepartitionApp();
        // Appliquer la disposition sauvegardÃ©e
        if (data.disposition) {
          Object.entries(data.disposition).forEach(([classe, ids]) => {
            const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
            if (zone) {
              ids.forEach(id => {
                const card = document.querySelector(`.student-card[data-id="${id}"]`);
                if (card) zone.appendChild(card);
              });
            }
          });
        }
        updateAllColumnStats();
        toast('Cache restaurÃ© avec succÃ¨s', 'success');
      } catch (e) {
        console.error('Erreur restauration cache:', e);
        toast('Erreur lors de la restauration', 'error');
      }
    }

    // =======================================================
    // VARIABLES GLOBALES
    // =======================================================
    let autoSaveInterval = null;

    /**
     * @typedef {Object} StudentScores
     * @property {string|number} [COM] - Score communication (0/1)
     * @property {string|number} [TRA] - Score travail
     * @property {string|number} [PART] - Score participation
     * @property {string|number} [ABS] - Score absences
     */

    /**
     * @typedef {Object} Student
     * @property {string} id - Identifiant unique de l'Ã©lÃ¨ve
     * @property {string} nom - Nom de famille
     * @property {string} prenom - PrÃ©nom
     * @property {string} sexe - Genre ('F' ou 'M')
     * @property {string} [lv2] - Langue vivante 2 (ex: 'ESP', 'ALL', 'ITA')
     * @property {string} [opt] - Option (ex: 'LATIN', 'EURO')
     * @property {string} [disso] - Code dissociation (groupe Ã  sÃ©parer)
     * @property {string} [asso] - Code association (groupe Ã  garder ensemble)
     * @property {string} [mobilite] - Statut mobilitÃ© ('LIBRE','FIXE','SPEC','CONDI','PERMUT')
     * @property {StudentScores} [scores] - Scores par critÃ¨re
     */

    /**
     * @typedef {Object} SwapAction
     * @property {string} type - Type d'action ('swap' ou 'move')
     * @property {string} [studentId] - ID de l'Ã©lÃ¨ve dÃ©placÃ©
     * @property {string} [from] - Classe d'origine
     * @property {string} [to] - Classe de destination
     */

    /**
     * @typedef {Object} AppState
     * @property {string} viewMode - Mode d'affichage ('complete', 'simple', 'compact')
     * @property {Object<string, Student>} students - Dictionnaire plat id â†’ Ã©lÃ¨ve
     * @property {Object<string, *>} rules - RÃ¨gles par classe (depuis _STRUCTURE)
     * @property {Object<string, string[]>} aGroups - Groupes d'association (clÃ© 'A'+code â†’ tableau d'IDs)
     * @property {SwapAction[]} history - Historique d'actions (undo)
     * @property {SwapAction[]} historyTimeline - Historique complet (timeline)
     * @property {SwapAction[]} future - Actions annulÃ©es (redo)
     * @property {boolean} swapMode - Mode permutation actif
     * @property {string|null} swapFirst - ID du 1er Ã©lÃ¨ve sÃ©lectionnÃ© pour swap
     * @property {boolean} adminMode - Mode administrateur actif
     * @property {string} searchTerm - Terme de recherche actuel
     * @property {boolean} darkMode - Mode sombre
     * @property {boolean} zoomMode - Mode zoom
     * @property {boolean} fullscreenStats - Stats en plein Ã©cran
     * @property {boolean} anchoredStats - Stats ancrÃ©es
     * @property {string|null} currentMode - Mode de travail courant (ex: '2NDE')
     * @property {Array|null} originalData - DonnÃ©es brutes chargÃ©es depuis le backend
     * @property {string} niveau - Niveau dÃ©tectÃ© (ex: '2NDE', '1ERE')
     * @property {Object<string, string>} sortOrder - Ordre de tri par classe
     * @property {boolean} lastSaveError - DerniÃ¨re sauvegarde en erreur
     * @property {HTMLElement|null} draggingElement - Ã‰lÃ©ment en cours de drag
     * @property {HTMLElement|null} dragStartZone - Zone de dÃ©part du drag
     * @property {boolean} has_user_action - Action utilisateur non sauvegardÃ©e
     * @property {number|null} last_save_timestamp - Timestamp derniÃ¨re sauvegarde
     */

    /** @type {AppState} */
    window.STATE = {
      viewMode: 'complete',
      students: {},
      rules: {},
      aGroups: {},
      history: [],
      historyTimeline: [], // AjoutÃ© pour le panneau historique
      future: [],
      swapMode: false,
      swapFirst: null,
      adminMode: false,
      searchTerm: '',
      darkMode: false,
      zoomMode: false,
      fullscreenStats: false,
      anchoredStats: false,
      currentMode: null,
      originalData: null,
      niveau: '',
      sortOrder: {},
      lastSaveError: false,
      draggingElement: null,
      dragStartZone: null,
      has_user_action: false,
      last_save_timestamp: null
    };

    // Alias pour compatibilitÃ© avec le code existant
    const STATE = window.STATE;

    // Variables pour les graphiques (les dÃ©placer aussi)
    window.chartCommunication = null;
    window.chartDistribution = null;
    window.chartLV2 = null;
    window.chartOptions = null;

    // ============================================
    // ARCHITECTURE MODULAIRE
    // ============================================
    /**
     * Architecture modulaire de l'application InterfaceV2
     *
     * Cette section organise le code JavaScript en modules logiques pour amÃ©liorer
     * l'organisation et la maintenabilitÃ© du code (12561 lignes).
     *
     * DOCUMENTATION COMPLÃˆTE : Voir ARCHITECTURE_MODULAIRE.md
     *
     * MODULES DISPONIBLES :
     * - App.state       : Ã‰tat global de l'application (alias de STATE)
     * - App.UI          : CrÃ©ation et manipulation des Ã©lÃ©ments UI
     * - App.DragDrop    : Gestion du drag and drop
     * - App.Views       : Gestion des diffÃ©rentes vues (simple, complete, swap, dark mode)
     * - App.History     : Historique et undo/redo
     * - App.Stats       : Statistiques et mÃ©triques
     * - App.Constraints : Validation des contraintes
     * - App.Data        : Import/Export et sauvegarde
     * - App.Search      : Recherche et filtres
     * - App.Utils       : Fonctions utilitaires
     * - App.Init        : Initialisation de l'application
     *
     * COMPATIBILITÃ‰ :
     * Des fonctions wrapper globales sont disponibles pour assurer la compatibilitÃ©
     * avec le code existant. Voir section "FONCTIONS WRAPPER POUR COMPATIBILITÃ‰" ci-dessous.
     *
     * UTILISATION :
     * // Nouveau code (recommandÃ©)
     * App.UI.toast('Message', 'success');
     *
     * // Code legacy (toujours supportÃ© via wrappers)
     * toast('Message', 'success');
     *
     * MIGRATION EN COURS :
     * âœ… App.UI          - toast, updateColumnStats, showSpinner, etc.
     * âœ… App.History     - undo, redo, updateUndoRedoButtons
     * âœ… App.Stats       - updateAdvancedStats
     * âœ… App.Data        - exportDisposition, saveImmediateCache
     * âœ… App.Utils       - isRealClass
     * â³ App.Views       - Ã€ migrer : toggleViewMode, toggleSwapMode, etc.
     * â³ App.DragDrop    - Ã€ migrer : handleDragStart, handleDrop, etc.
     * â³ App.Constraints - Ã€ migrer : canMove, canSwap
     * â³ App.Search      - Ã€ migrer : searchStudents, filterByTag
     * â³ App.Init        - Ã€ migrer : setupEventListeners, initApp
     */

    const App = {
      // ============================================
      // Ã‰TAT GLOBAL (rÃ©fÃ©rence vers STATE)
      // ============================================
      get state() {
        return STATE;
      },

      // ============================================
      // MODULE UI - CrÃ©ation et manipulation des Ã©lÃ©ments
      // ============================================
      UI: {
        /**
         * Affiche une notification toast
         * @param {string} message - Message Ã  afficher
         * @param {string} type - Type de notification (info, success, error, warning)
         */
        toast(message, type = 'info') {
          const icons = {
            info: 'fa-info-circle',
            success: 'fa-check-circle',
            error: 'fa-exclamation-circle',
            warning: 'fa-exclamation-triangle'
          };

          const isSwapError = type === 'error';
          const toast = document.createElement('div');

          if (isSwapError) {
            toast.className = `toast ${type} fade-in`;
            toast.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 9999;
          font-size: 1.5rem;
          padding: 24px 40px;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
          border-radius: 12px;
          background: #dc2626;
          color: white;
          border: none;
          font-weight: 600;
          min-width: 400px;
          text-align: center;
        `;
          } else {
            toast.className = `toast ${type} fixed bottom-4 right-4 z-50 fade-in`;
          }

          toast.innerHTML = `
        <i class="fas ${icons[type]} ${isSwapError ? 'text-2xl mr-3' : 'text-lg'}"></i>
        <span>${message}</span>
      `;

          document.body.appendChild(toast);

          const duration = isSwapError ? 4000 : 3000;

          setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease-out';
            setTimeout(() => toast.remove(), 300);
          }, duration);
        },

        /**
         * Met Ã  jour les statistiques d'une colonne de classe
         * @param {HTMLElement} column - Ã‰lÃ©ment DOM de la colonne
         * @param {Array} eleves - Liste des Ã©lÃ¨ves
         */
        updateColumnStats(column, eleves) {
          if (!column) return;

          const counts = countBySex(eleves);

          column.querySelector('.count').textContent = counts.total;
          column.querySelector('.count-f').textContent = counts.F;
          column.querySelector('.count-m').textContent = counts.M;

          const scoreCats = ['C', 'T', 'P', 'A'];
          const counters = { C: [0, 0, 0, 0], T: [0, 0, 0, 0], P: [0, 0, 0, 0], A: [0, 0, 0, 0] };

          eleves.forEach(e => {
            scoreCats.forEach(cat => {
              const v = +e.scores?.[cat] || 0;
              if (v >= 1 && v <= 4) counters[cat][v - 1]++;
            });
          });

          scoreCats.forEach(cat => {
            counters[cat].forEach((val, i) => {
              const el = column.querySelector(`.count-${cat.toLowerCase()}${i + 1}`);
              if (el) el.textContent = val;
            });
          });
        },

        /**
         * Met Ã  jour les statistiques de toutes les colonnes
         */
        updateAllColumnStats() {

          document.querySelectorAll('.class-column').forEach(column => {
            const className = column.querySelector('.classe-name').textContent;
            if (!App.Utils.isRealClass(className)) return;

            const dropZone = column.querySelector('.droppable-zone');
            const cards = Array.from(dropZone.querySelectorAll('.student-card'));
            const eleves = cards.map(card => STATE.students[card.dataset.id]).filter(Boolean);

            App.UI.updateColumnStats(column, eleves);
          });
        },

        /**
         * Ajuste la taille de police des noms en vue simplifiÃ©e
         * @param {HTMLElement} dropZone - Zone de dÃ©pÃ´t
         */
        adjustSimpleNamesFontSize(dropZone) {
          if (!STATE || STATE.viewMode !== 'simple') return;
          const cards = Array.from(dropZone.querySelectorAll('.student-card'));
          if (cards.length === 0) return;

          let zoneHeight = dropZone.clientHeight || dropZone.offsetHeight || 0;
          if (!zoneHeight) {
            const parent = dropZone.closest('.class-column');
            if (parent) zoneHeight = parent.clientHeight || parent.offsetHeight || 0;
          }
          if (!zoneHeight) return;

          const availableHeight = zoneHeight - 30;
          const minFont = 16;
          const maxFont = 32;
          let fontSize = Math.floor(availableHeight / cards.length) - 2;

          if (isNaN(fontSize) || fontSize < minFont) fontSize = minFont;
          if (fontSize > maxFont) fontSize = maxFont;

          cards.forEach(card => {
            const nameEl = card.querySelector('.student-simple-name');
            const lineEl = card.querySelector('.simple-line');
            if (nameEl) {
              nameEl.style.fontSize = fontSize + 'px';
              nameEl.style.lineHeight = (fontSize + 2) + 'px';
            }
            if (lineEl) {
              lineEl.style.height = (fontSize + 6) + 'px';
            }
          });
        },

        /**
         * Affiche/masque le spinner de chargement
         */
        showSpinner() {
          document.getElementById('loadingSpinner')?.classList.remove('hidden');
        },

        hideSpinner() {
          document.getElementById('loadingSpinner')?.classList.add('hidden');
        },

        /**
         * Ajoute un nouvel Ã©lÃ¨ve Ã  une classe
         * Fonction publique appelÃ©e par le module NewStudentModule
         * @param {Object} newStudent - Objet Ã©lÃ¨ve au format {id, nom, prenom, sexe, lv2, opt, scores, ...}
         * @param {string} classId - ID de la classe (ex: "6Â°1")
         */
        addStudentToClass(newStudent, classId) {
          console.log(`[App.UI.addStudentToClass] Ajout de ${newStudent.nom} ${newStudent.prenom} dans ${classId}`);

          if (!newStudent || !newStudent.id || !classId) {
            console.error('[App.UI.addStudentToClass] DonnÃ©es invalides');
            return false;
          }

          // 1. Ajouter Ã  STATE.students
          if (!STATE.students) STATE.students = {};
          STATE.students[newStudent.id] = newStudent;

          // 2. Ajouter Ã  STATE.classes
          if (!STATE.classes[classId]) {
            STATE.classes[classId] = { eleves: [] };
          }
          STATE.classes[classId].eleves.push(newStudent);

          // 3. Ajouter au DOM (crÃ©er la carte et l'insÃ©rer dans la zone de dÃ©pÃ´t)
          const dropZone = document.querySelector(`.droppable-zone[data-classe="${classId}"]`);
          if (dropZone && typeof createStudentCard === 'function') {
            const card = createStudentCard(newStudent);
            if (card) {
              dropZone.appendChild(card);
              console.log(`[App.UI.addStudentToClass] Carte DOM crÃ©Ã©e et insÃ©rÃ©e`);
            }
          }

          // 4. Ajouter Ã  STATE.aGroups si association
          if (newStudent.asso) {
            const key = `A${newStudent.asso}`;
            if (!STATE.aGroups) STATE.aGroups = {};
            if (!STATE.aGroups[key]) STATE.aGroups[key] = [];
            if (!STATE.aGroups[key].includes(newStudent.id)) {
              STATE.aGroups[key].push(newStudent.id);
            }
          }

          // 5. Enregistrer dans l'historique
          if (!STATE.history) STATE.history = [];
          STATE.history.push({
            type: 'add',
            eleveId: newStudent.id,
            eleveName: `${newStudent.nom} ${newStudent.prenom}`,
            classe: classId,
            timestamp: new Date().toISOString()
          });

          // 6. Mettre Ã  jour les stats
          App.UI.updateAllColumnStats();

          // 7. Mettre Ã  jour les stats avancÃ©es
          if (typeof updateAdvancedStats === 'function') {
            setTimeout(() => updateAdvancedStats(), 150);
          }

          // 8. Marquer comme modifiÃ© pour auto-save
          STATE.has_user_action = true;

          // 9. Sauvegarde immÃ©diate si mode CACHE
          if (STATE.currentMode === 'CACHE' && typeof App.Data?.saveImmediateCache === 'function') {
            setTimeout(() => App.Data.saveImmediateCache(), 200);
          }

          return true;
        }
      },

      // ============================================
      // MODULE DRAG & DROP
      // ============================================
      DragDrop: {
        // Ces fonctions seront migrÃ©es depuis le code existant
        // Pour l'instant, on laisse des placeholders qui appelleront les fonctions globales
      },

      // ============================================
      // MODULE VIEWS - Gestion des vues
      // ============================================
      Views: {
        // Placeholders pour les fonctions de vue
      },

      // ============================================
      // MODULE HISTORY - Historique et undo/redo
      // ============================================
      History: {
        /**
         * Met Ã  jour l'Ã©tat des boutons undo/redo
         */
        updateUndoRedoButtons() {
          const btnUndo = document.getElementById('btnUndo');
          const btnRedo = document.getElementById('btnRedo');

          if (btnUndo) btnUndo.disabled = STATE.history.length === 0;
          if (btnRedo) btnRedo.disabled = STATE.future.length === 0;
        },

        /**
         * Annule la derniÃ¨re action
         */
        undo() {
          if (STATE.history.length === 0) return;

          const action = STATE.history.pop();
          STATE.future.push(action);

          // Retirer aussi de historyTimeline
          if (STATE.historyTimeline.length > 0) {
            STATE.historyTimeline.pop();
          }

          if (action.type === 'move') {
            const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
            const oldZone = document.querySelector(`.droppable-zone[data-classe="${action.oldClasse}"]`);

            if (card && oldZone) {
              // InsÃ©rer Ã  l'ancienne position si possible
              if (action.oldIndex < oldZone.children.length) {
                oldZone.insertBefore(card, oldZone.children[action.oldIndex]);
              } else {
                oldZone.appendChild(card);
              }
            }
          } else if (action.type === 'swap') {
            if (typeof performSwap === 'function') {
              performSwap(action.id2, action.id1); // Swap inverse
              STATE.history.pop(); // Enlever le swap ajoutÃ© par performSwap
            }
          }

          App.History.updateUndoRedoButtons();
          App.UI.updateAllColumnStats();

          // Mettre Ã  jour le panneau historique
          if (typeof updateHistoryPanel === 'function') {
            updateHistoryPanel();
          }

          // Mise Ã  jour intelligente des statistiques
          setTimeout(() => App.Stats.updateAdvancedStats(), 150);

          // Sauvegarde aprÃ¨s undo
          if (STATE.currentMode === 'CACHE') {
            App.Data.saveImmediateCache();
          }
        },

        /**
         * Refait la derniÃ¨re action annulÃ©e
         */
        redo() {
          if (STATE.future.length === 0) return;

          const action = STATE.future.pop();

          if (action.type === 'move') {
            const card = document.querySelector(`.student-card[data-id="${action.eleveId}"]`);
            const newZone = document.querySelector(`.droppable-zone[data-classe="${action.newClasse}"]`);

            if (card && newZone) {
              if (action.newIndex < newZone.children.length) {
                newZone.insertBefore(card, newZone.children[action.newIndex]);
              } else {
                newZone.appendChild(card);
              }
            }
            STATE.history.push(action);
            // Ajouter aussi Ã  historyTimeline pour le panneau historique
            STATE.historyTimeline.push(action);
          } else if (action.type === 'swap') {
            if (typeof performSwap === 'function') {
              performSwap(action.id1, action.id2);
            }
          }

          App.History.updateUndoRedoButtons();
          App.UI.updateAllColumnStats();

          // Mettre Ã  jour le panneau historique
          if (typeof updateHistoryPanel === 'function') {
            updateHistoryPanel();
          }

          // Mise Ã  jour intelligente des statistiques
          setTimeout(() => App.Stats.updateAdvancedStats(), 150);

          // Sauvegarde aprÃ¨s redo
          if (STATE.currentMode === 'CACHE') {
            App.Data.saveImmediateCache();
          }
        }
      },

      // ============================================
      // MODULE STATS - Statistiques
      // ============================================
      Stats: {
        /**
         * Met Ã  jour les statistiques avancÃ©es
         */
        updateAdvancedStats() {
          console.log('chartsReady=', window.areChartsReady?.(),
            'typeof updateCharts =', typeof updateCharts);

          const panel = document.getElementById('statsPanel');
          if (!panel || panel.classList.contains('translate-x-full')) {
            return;
          }

          if (typeof updateNewMetrics === 'function') {
            updateNewMetrics();
          }

          if (typeof updateCharts === 'function') {
            updateCharts();
          }

          if (typeof updateLV2Details === 'function') {
            updateLV2Details();
          }
        }
      },

      // ============================================
      // MODULE CONSTRAINTS - Validation
      // ============================================
      Constraints: {
        // Placeholders pour les fonctions de contraintes
      },

      // ============================================
      // MODULE DATA - Import/Export
      // ============================================
      Data: {
        /**
         * Exporte la disposition actuelle
         * @returns {Object} Disposition des classes
         */
        exportDisposition() {
          const result = {};
          document.querySelectorAll('.class-column').forEach(column => {
            const classe = column.querySelector('.classe-name').textContent;
            const ids = Array.from(column.querySelectorAll('.student-card')).map(card => card.dataset.id);
            result[classe] = ids;
          });
          return result;
        },

        /**
         * Sauvegarde immÃ©diate dans le cache
         */
        async saveImmediateCache() {
          try {
            // 1. Ne rien faire si l'utilisateur n'a rien bougÃ©
            if (!STATE.has_user_action) {
              console.debug('â­ï¸ Auto-save sautÃ© (aucune action)');
              return;
            }

            const disposition = App.Data.exportDisposition();
            const cacheData = {
              date: new Date().toISOString(),
              disposition: disposition,
              mode: STATE.currentMode
            };

            // Sauvegarde locale (localStorage)
            localStorage.setItem('cache-data', JSON.stringify(cacheData));

            if (typeof gsRun === 'function') {
              try {
                // ğŸ”¥ NOUVEAU: Appel Ã  saveDispositionToSheets pour crÃ©er les onglets CACHE
                const result = await gsRun('saveDispositionToSheets', disposition);

                if (result && result.success) {

                  // 2. AprÃ¨s succÃ¨s â†’ on remet le flag Ã  false,
                  //    on horodate, on met Ã  jour le badge
                  STATE.has_user_action = false;
                  STATE.last_save_ts = Date.now();

                  if (typeof updateSaveBadge === 'function') {
                    updateSaveBadge(true);
                  }
                } else {
                  console.warn('âš ï¸ Sauvegarde CACHE Ã©chouÃ©e:', result?.error);
                  if (typeof updateSaveBadge === 'function') {
                    updateSaveBadge(false);
                  }
                }
              } catch (error) {
                console.error('âŒ Erreur sauvegarde CACHE:', error);
                if (typeof updateSaveBadge === 'function') {
                  updateSaveBadge(false);
                }
              }
            }
          } catch (error) {
            console.error('âŒ Erreur dans saveImmediateCache:', error);
          }
        }
      },

      // ============================================
      // MODULE SEARCH - Recherche et filtres
      // ============================================
      Search: {
        // Placeholders pour les fonctions de recherche
      },

      // ============================================
      // MODULE UTILS - Utilitaires
      // ============================================
      Utils: {
        /**
         * VÃ©rifie si un nom de classe est une vraie classe (pas un groupe)
         * @param {string} className - Nom de la classe
         * @returns {boolean}
         */
        isRealClass(className) {
          const groupPatterns = [
            /^level_/i,
            /^grp_/i,
            /^groupe_/i,
            /^group_/i,
            /_Groupe\d*$/i,
            /^ESP_/i,
            /^ITA_/i,
            /^ALL_/i,
            /^LATIN_/i,
            /^MATH_/i,
            /^FR_/i,
            /^Niveau/i
          ];

          for (const pattern of groupPatterns) {
            if (pattern.test(className)) {
              return false;
            }
          }

          const classPattern = /^\d+Â°\d+$/;
          return classPattern.test(className);
        }
      },

      // ============================================
      // MODULE INIT - Initialisation
      // ============================================
      Init: {
        // Placeholders pour l'initialisation
      }
    };

    // ============================================
    // FONCTIONS WRAPPER POUR COMPATIBILITÃ‰
    // ============================================
    /**
     * Ces fonctions wrapper assurent la compatibilitÃ© avec les event handlers HTML existants
     * et le code legacy. Elles dÃ©lÃ¨guent simplement vers les modules appropriÃ©s.
     */

    // Wrapper pour toast
    function toast(message, type = 'info') {
      return App.UI.toast(message, type);
    }

    // Wrapper pour updateColumnStats
    function updateColumnStats(column, eleves) {
      return App.UI.updateColumnStats(column, eleves);
    }

    // Wrapper pour updateAllColumnStats
    function updateAllColumnStats() {
      return App.UI.updateAllColumnStats();
    }

    // Wrapper pour adjustSimpleNamesFontSize
    function adjustSimpleNamesFontSize(dropZone) {
      return App.UI.adjustSimpleNamesFontSize(dropZone);
    }

    // Wrapper pour isRealClass
    function isRealClass(className) {
      return App.Utils.isRealClass(className);
    }

    // Wrapper pour exportDisposition
    function exportDisposition() {
      return App.Data.exportDisposition();
    }

    // Wrapper pour saveImmediateCache
    async function saveImmediateCache() {
      return App.Data.saveImmediateCache();
    }

    // Wrapper pour updateUndoRedoButtons
    function updateUndoRedoButtons() {
      return App.History.updateUndoRedoButtons();
    }

    // Wrapper pour updateAdvancedStats
    function updateAdvancedStats() {
      return App.Stats.updateAdvancedStats();
    }

    // Wrapper pour undo
    function undo() {
      return App.History.undo();
    }

    // Wrapper pour redo
    function redo() {
      return App.History.redo();
    }

    // Wrapper pour showSpinner/hideSpinner
    function showSpinner() {
      return App.UI.showSpinner();
    }

    function hideSpinner() {
      return App.UI.hideSpinner();
    }

    // Wrapper pour addStudentToClass (appelÃ© par le module NewStudentModule)
    function addStudentToClass(newStudent, classId) {
      return App.UI.addStudentToClass(newStudent, classId);
    }

    // =======================================================
    // FONCTIONS GLOBALES (Legacy - Ã€ migrer progressivement)
    // =======================================================
    // showSpinner() et hideSpinner() migrÃ©s vers App.UI






    // ========== AJUSTEMENT TAILLE DES CARTES ==========
    function resizeCards() {
      document.querySelectorAll('.student-card').forEach(card => {
        const w = card.offsetWidth;
        // Toujours retirer toutes les classes
        card.classList.remove('card-sm', 'card-md', 'card-lg');
        // Puis ajouter la classe appropriÃ©e
        if (w > 320) card.classList.add('card-lg');
        else if (w > 240) card.classList.add('card-md');
        else card.classList.add('card-sm');
      });
    }






    // ========== FONCTION D'OUVERTURE DU MODAL DE DÃ‰MARRAGE ==========
    // Fonction dÃ©jÃ  dÃ©finie plus haut

    // =======================================================
    // PONT INTELLIGENT AVEC LA CONSOLE DE PILOTAGE
    // ======================================================
    async function initializeBridge() {
      try {
        console.log('ğŸŒ‰ Initialisation du pont depuis la Console de Pilotage...');
        // Cette fonction cÃ´tÃ© serveur lit la propriÃ©tÃ© utilisateur 'JULES_CONTEXT' et la supprime.
        const result = await gsRun('getBridgeContextAndClear');

        if (result && result.success && result.context && result.context.mode) {
          const mode = result.context.mode;
          const sourceSheet = result.context.sourceSheetName || 'source';

          console.log(`ğŸ“¡ Contexte reÃ§u: Mode=${mode}, Source=${sourceSheet}`);

          localStorage.setItem('mode-selection', mode);
          toast(`Contexte chargÃ© depuis la console (Mode: ${mode})`, 'success');

          // Cacher le modal de dÃ©marrage et lancer l'application
          const startupModal = document.getElementById('startupModal');
          if (startupModal) {
            startupModal.classList.add('hidden');
          }
          // On a un mode, on peut lancer l'app directement
          await initRepartitionApp();

        } else {
          console.log('ğŸ¤· Aucun contexte trouvÃ© ou mode manquant, ouverture du modal de dÃ©marrage.');
          openStartupModal();
        }
      } catch (error) {
        console.error('Erreur du pont intelligent:', error);
        toast('Erreur de communication avec la console', 'error');
        openStartupModal(); // Fallback en cas d'erreur
      }
    }

    // =======================================================
    // INITIALISATION QUAND LE DOM EST PRÃŠT
    // =======================================================
    window.addEventListener('DOMContentLoaded', (event) => {
      console.log("DOM prÃªt. Tous les scripts peuvent s'exÃ©cuter.");

      // VÃ©rifier si une sauvegarde CACHE existe
      checkCache();

      // Appliquer les prÃ©fÃ©rences de lisibilitÃ© sauvegardÃ©es
      setTimeout(() => {
        if (window.applyLisibilitePreferences) {
          window.applyLisibilitePreferences();
        }
      }, 500);

      // GESTION DU MODAL DE DÃ‰MARRAGE
      const startupModal = document.getElementById('startupModal');
      const closeStartupModalBtn = document.getElementById('closeStartupModal');

      if (closeStartupModalBtn && startupModal) {
        closeStartupModalBtn.addEventListener('click', () => {
          startupModal.classList.add('hidden');
        });

        // La protection par mot de passe est gÃ©rÃ©e plus bas (ligne ~4287)
      }
      // =======================================================
      // 1.4.5 FONCTION GLOBALE POUR ANIMATIONS DES DROPDOWNS
      // =======================================================
      window.toggleDropdown = function (dropdown, button) {
        if (!dropdown) return;

        const isHidden = dropdown.classList.contains('hidden');

        if (isHidden) {
          // Ouvrir avec animation
          dropdown.classList.remove('hidden');
          // Force reflow
          void dropdown.offsetWidth;
          requestAnimationFrame(() => {
            dropdown.classList.add('show');
          });
        } else {
          // Fermer avec animation
          dropdown.classList.remove('show');
          setTimeout(() => {
            dropdown.classList.add('hidden');
          }, 150); // Correspond Ã  la durÃ©e de transition CSS
        }
      };

      window.closeAllDropdowns = function () {
        const dropdowns = document.querySelectorAll('.dropdown-menu');
        dropdowns.forEach(dropdown => {
          dropdown.classList.remove('show');
          setTimeout(() => {
            dropdown.classList.add('hidden');
          }, 150);
        });
      };

      // =======================================================
      // 1.5 GESTION DU MENU RÃ‰GLER (DROPDOWN)
      // =======================================================
      (function () {
        const btnRegler = document.getElementById('btnRegler');
        const dropdown = document.getElementById('dropdownRegler');

        if (!btnRegler || !dropdown) {
          console.warn('Menu RÃ©gler non trouvÃ©');
          return;
        }

        // Toggle dropdown avec positionnement dynamique et animation
        btnRegler.addEventListener('click', (e) => {
          e.stopPropagation();

          // Fermer tous les autres dropdowns (sauf celui-ci)
          document.querySelectorAll('.dropdown-menu').forEach(dd => {
            if (dd !== dropdown && !dd.classList.contains('hidden')) {
              dd.classList.remove('show');
              setTimeout(() => dd.classList.add('hidden'), 150);
            }
          });

          // Positionner le dropdown sous le bouton
          const rect = btnRegler.getBoundingClientRect();
          dropdown.style.top = `${rect.bottom + 8}px`;
          dropdown.style.left = `${rect.left}px`;

          // Toggle avec animation
          toggleDropdown(dropdown, btnRegler);
        });

        // EmpÃªcher la fermeture au clic interne
        dropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Fermer au clic extÃ©rieur
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && e.target !== btnRegler) {
            dropdown.classList.remove('show');
            setTimeout(() => dropdown.classList.add('hidden'), 150);
          }
        });

        // === CÃ‚BLAGE DES BOUTONS ===

        // 1. Mode Permutation (toggle)
        const btnSwapMainMenu = document.getElementById('btnSwapMainMenu');
        const swapModeIndicator = document.getElementById('swapModeIndicator');

        if (btnSwapMainMenu) {
          btnSwapMainMenu.addEventListener('click', () => {
            // Appeler la fonction existante de swap
            if (window.toggleSwapMode) {
              window.toggleSwapMode();
            } else {
              // Fallback si la fonction n'existe pas encore
              STATE.swapMode = !STATE.swapMode;
              swapModeIndicator.textContent = STATE.swapMode ? 'ON' : 'OFF';
              swapModeIndicator.classList.toggle('bg-green-500', STATE.swapMode);
              swapModeIndicator.classList.toggle('text-white', STATE.swapMode);
              swapModeIndicator.classList.toggle('bg-gray-200', !STATE.swapMode);
              swapModeIndicator.classList.toggle('text-gray-600', !STATE.swapMode);

              document.body.classList.toggle('swap-mode', STATE.swapMode);
              toast(STATE.swapMode ? 'â†”ï¸ Mode Permutation activÃ©' : 'â†”ï¸ Mode Permutation dÃ©sactivÃ©', 'info');
            }
          });
        }

        // 2. Annuler (Undo)
        const btnUndoQuick = document.getElementById('btnUndoQuick');
        const btnUndo = document.getElementById('btnUndo'); // Ancien bouton dans ParamÃ¨tres

        if (btnUndoQuick) {
          // L'Ã©vÃ©nement click est dÃ©jÃ  dÃ©fini dans le HTML (onclick="window.undo()")
          // Mais on peut sÃ©curiser l'Ã©tat disabled ici

          // Synchroniser l'Ã©tat disabled avec l'ancien bouton OU directement avec STATE
          if (btnUndo) {
            const observer = new MutationObserver(() => {
              btnUndoQuick.disabled = btnUndo.disabled;
            });
            observer.observe(btnUndo, { attributes: true, attributeFilter: ['disabled'] });
          } else {
            // Mise Ã  jour directe si l'ancien bouton n'existe pas
            setInterval(() => {
              if (STATE && STATE.history) {
                btnUndoQuick.disabled = STATE.history.length === 0;
              }
            }, 500);
          }
        }

        // 3. RÃ©tablir (Redo)
        const btnRedoQuick = document.getElementById('btnRedoQuick');
        const btnRedo = document.getElementById('btnRedo'); // Ancien bouton dans ParamÃ¨tres

        if (btnRedoQuick) {
          // Synchroniser l'Ã©tat disabled avec l'ancien bouton OU directement avec STATE
          if (btnRedo) {
            const observer = new MutationObserver(() => {
              btnRedoQuick.disabled = btnRedo.disabled;
            });
            observer.observe(btnRedo, { attributes: true, attributeFilter: ['disabled'] });
          } else {
            // Mise Ã  jour directe si l'ancien bouton n'existe pas
            setInterval(() => {
              if (STATE && STATE.future) {
                btnRedoQuick.disabled = STATE.future.length === 0;
              }
            }, 500);
          }
        }

        // 4. Historique
        const btnHistoryMenu = document.getElementById('btnHistoryMenu');

        if (btnHistoryMenu) {
          btnHistoryMenu.addEventListener('click', () => {
            if (window.toggleHistoryPanel) {
              window.toggleHistoryPanel();
            } else {
              toast('ğŸ“œ Panneau Historique ouvert', 'info');
            }
            dropdown.classList.add('hidden'); // Fermer le menu
          });
        }

        // 5. Sources (ouvre le modal de dÃ©marrage)
        const btnSourcesMenu = document.getElementById('btnSourcesMenu');

        if (btnSourcesMenu) {
          btnSourcesMenu.addEventListener('click', () => {
            if (window.openStartupModal) {
              window.openStartupModal({ force: true });
            } else {
              toast('âš ï¸ Modal Sources non disponible', 'warning');
            }
            dropdown.classList.add('hidden'); // Fermer le menu
          });
        }

        // === CÃ‚BLAGE DES RÃ‰GLAGES DE LISIBILITÃ‰ ===

        // Fonction pour appliquer les rÃ©glages
        function applyReglerSettings() {
          const fontSize = dropdown.querySelector('input[name="fontSize"]:checked')?.value || 'medium';
          const fontStyle = dropdown.querySelector('input[name="fontStyle"]:checked')?.value || 'normal';
          const contrast = dropdown.querySelector('input[name="contrast"]:checked')?.value || 'normal';
          const genderDisplay = dropdown.querySelector('input[name="genderDisplay"]:checked')?.value || 'colors';
          const showPrenoms = document.getElementById('showPrenoms')?.checked ?? true;
          const showClasse = document.getElementById('showClasseOrigine')?.checked ?? true;
          const showScores = document.getElementById('showScores')?.checked ?? true;

          const lisibiliteState = {
            size: fontSize,
            style: fontStyle,
            contrast: contrast,
            symbols: genderDisplay,
            showPrenoms: showPrenoms,
            showClasse: showClasse,
            showScores: showScores
          };
          localStorage.setItem('lisibilite-preferences', JSON.stringify(lisibiliteState));

          if (window.applyLisibilitePreferences) {
            window.applyLisibilitePreferences();
          }
        }

        // Connecter les checkboxes
        ['showPrenoms', 'showClasseOrigine', 'showScores'].forEach(id => {
          const checkbox = document.getElementById(id);
          if (checkbox) {
            checkbox.addEventListener('change', applyReglerSettings);
          }
        });

        // Connecter les radios pour appliquer en temps rÃ©el
        dropdown.querySelectorAll('input[type="radio"]').forEach(radio => {
          radio.addEventListener('change', () => {
            applyReglerSettings();
          });
        });

        // PrÃ©rÃ©glages
        document.getElementById('presetProjection')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'medium');
          setRadioValue('fontStyle', 'bold');
          setRadioValue('genderDisplay', 'symbols');
          const whiteBackground = document.getElementById('whiteBackground');
          if (whiteBackground) {
            whiteBackground.checked = true;
            whiteBackground.dispatchEvent(new Event('change'));
          }
          applyReglerSettings();
          toast('ğŸ“½ï¸ Mode Projection activÃ©', 'success');
        });

        document.getElementById('presetImpression')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'small');
          setRadioValue('fontStyle', 'normal');
          setRadioValue('contrast', 'normal');
          setRadioValue('genderDisplay', 'colors');
          const whiteBackground = document.getElementById('whiteBackground');
          if (whiteBackground) {
            whiteBackground.checked = false;
            whiteBackground.dispatchEvent(new Event('change'));
          }
          applyReglerSettings();
          toast('ğŸ–¨ï¸ Mode Impression activÃ©', 'success');
        });

        document.getElementById('presetAccessibilite')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'xlarge');
          setRadioValue('fontStyle', 'bold');
          setRadioValue('contrast', 'max');
          setRadioValue('genderDisplay', 'both');
          applyReglerSettings();
          toast('â™¿ Mode AccessibilitÃ© activÃ©', 'success');
        });

        // RÃ©initialiser
        document.getElementById('btnResetReglages')?.addEventListener('click', () => {
          setRadioValue('fontSize', 'medium');
          setRadioValue('fontStyle', 'normal');
          setRadioValue('contrast', 'normal');
          setRadioValue('genderDisplay', 'colors');

          const showGenderBadges = document.getElementById('showGenderBadges');
          if (showGenderBadges) {
            showGenderBadges.checked = false;
            showGenderBadges.dispatchEvent(new Event('change'));
          }

          const whiteBackground = document.getElementById('whiteBackground');
          if (whiteBackground) {
            whiteBackground.checked = false;
            whiteBackground.dispatchEvent(new Event('change'));
          }

          document.getElementById('showPrenoms').checked = true;
          document.getElementById('showClasseOrigine').checked = true;
          document.getElementById('showScores').checked = true;

          applyReglerSettings();
          toast('ğŸ”„ RÃ©glages rÃ©initialisÃ©s', 'info');
        });

        // Plein Ã©cran
        document.getElementById('btnPleinEcran')?.addEventListener('click', () => {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
            toast('â›¶ Mode plein Ã©cran activÃ©', 'info');
          } else {
            document.exitFullscreen();
            toast('â›¶ Mode plein Ã©cran dÃ©sactivÃ©', 'info');
          }
        });

        // Mode sombre
        document.getElementById('btnModeSombre')?.addEventListener('click', (e) => {
          e.stopPropagation();
          document.body.classList.toggle('dark-mode');
          const isDark = document.body.classList.contains('dark-mode');
          localStorage.setItem('darkMode', isDark);
          toast(isDark ? 'ğŸŒ™ Mode sombre activÃ©' : 'â˜€ï¸ Mode clair activÃ©', 'info');
        });

        // Zoom cartes
        document.getElementById('btnZoomCartes')?.addEventListener('click', () => {
          const cards = document.querySelectorAll('.student-card');
          const isZoomed = cards[0]?.style.transform === 'scale(1.1)';
          cards.forEach(card => {
            card.style.transform = isZoomed ? '' : 'scale(1.1)';
            card.style.transition = 'transform 0.2s';
          });
          toast(isZoomed ? 'ğŸ” Zoom dÃ©sactivÃ©' : 'ğŸ” Zoom activÃ©', 'info');
        });

        // Helper pour dÃ©finir un radio
        function setRadioValue(name, value) {
          const radio = dropdown.querySelector(`input[name="${name}"][value="${value}"]`);
          if (radio) {
            radio.checked = true;
            const label = radio.closest('label');
            if (label) {
              dropdown.querySelectorAll(`input[name="${name}"]`).forEach(r => {
                const l = r.closest('label');
                if (l) {
                  l.classList.remove('bg-blue-50', 'border-blue-500', 'dark:bg-blue-900/30');
                  const s = l.querySelector('span');
                  if (s) s.classList.remove('text-blue-700');
                }
              });
              label.classList.add('bg-blue-50', 'border-blue-500', 'dark:bg-blue-900/30');
              const span = label.querySelector('span');
              if (span) span.classList.add('text-blue-700');
            }
          }
        }

        // Charger les prÃ©fÃ©rences au dÃ©marrage
        const saved = localStorage.getItem('lisibilite-preferences');
        if (saved) {
          const prefs = JSON.parse(saved);
          setRadioValue('fontSize', prefs.size || 'medium');
          setRadioValue('fontStyle', prefs.style || 'normal');
          setRadioValue('contrast', prefs.contrast || 'normal');
          setRadioValue('genderDisplay', prefs.symbols || 'colors');
        }

      })();
      // =======================================================
      // FONCTION GLOBALE POUR APPLIQUER LES PRÃ‰FÃ‰RENCES DE LISIBILITÃ‰
      // =======================================================
      window.applyLisibilitePreferences = function () {
        const saved = localStorage.getItem('lisibilite-preferences');
        if (!saved) return;

        const prefs = JSON.parse(saved);

        // Appliquer la taille des noms
        const studentCards = document.querySelectorAll('.student-card');
        studentCards.forEach(card => {
          // Supprimer toutes les classes de taille
          card.classList.remove('font-size-small', 'font-size-medium', 'font-size-large', 'font-size-xlarge');
          // Ajouter la nouvelle classe
          if (prefs.size) {
            card.classList.add(`font-size-${prefs.size}`);
          }
        });

        // Appliquer le style des noms
        studentCards.forEach(card => {
          // Supprimer toutes les classes de style
          card.classList.remove('font-style-normal', 'font-style-bold', 'font-style-highlight', 'font-style-outline');
          // Ajouter la nouvelle classe
          if (prefs.style) {
            card.classList.add(`font-style-${prefs.style}`);
          }
        });

        // Appliquer le contraste au body
        document.body.classList.remove('contrast-normal', 'contrast-high', 'contrast-max');
        if (prefs.contrast) {
          document.body.classList.add(`contrast-${prefs.contrast}`);
        }

        // Appliquer l'affichage des genres
        studentCards.forEach(card => {
          card.classList.remove('gender-colors', 'gender-symbols', 'gender-both');
          if (prefs.symbols) {
            card.classList.add(`gender-${prefs.symbols}`);
          }

        });
        // Appliquer l'affichage/masquage des prÃ©noms
        if (prefs.showPrenoms !== undefined) {
          const allNames = document.querySelectorAll('.student-fullname, .student-simple-name');
          allNames.forEach(nameEl => {
            const card = nameEl.closest('.student-card');
            if (!card || !card.dataset.id) return;

            const eleve = STATE && STATE.students ? STATE.students[card.dataset.id] : null;
            if (!eleve) return;

            if (prefs.showPrenoms) {
              // Afficher nom + prÃ©nom
              if (typeof simplifierNomComplet === 'function') {
                nameEl.textContent = simplifierNomComplet(eleve.nom, eleve.prenom);
              } else {
                nameEl.textContent = eleve.prenom ? eleve.nom + ' ' + eleve.prenom : eleve.nom;
              }
            } else {
              // Afficher nom uniquement
              nameEl.textContent = eleve.nom;
            }
          });
        }

        // Appliquer l'affichage/masquage de la classe d'origine
        if (prefs.showClasse !== undefined) {
          const sourceElements = document.querySelectorAll('.source-class');
          sourceElements.forEach(el => {
            el.style.display = prefs.showClasse ? '' : 'none';
          });
        }

        // Appliquer l'affichage/masquage des scores
        if (prefs.showScores !== undefined) {
          const scoresElements = document.querySelectorAll('.scores');
          scoresElements.forEach(el => {
            el.style.display = prefs.showScores ? '' : 'none';
          });
        }
      };

      // Appliquer les prÃ©fÃ©rences sauvegardÃ©es au dÃ©marrage
      if (typeof window.applyLisibilitePreferences === 'function') {
        setTimeout(() => window.applyLisibilitePreferences(), 200);
      }


      // =======================================================
      // 1.6.5 FONCTIONS CENTRALISÃ‰ES POUR LE PANNEAU STATS
      // =======================================================
      window.openStatsPanel = function () {
        const statsPanel = document.getElementById('statsPanel');
        const floatClose = document.getElementById('statsFloatingClose');

        if (!statsPanel) return;

        // Animation synchronisÃ©e
        requestAnimationFrame(() => {
          // 1. DÃ©finir la largeur du panneau AVANT de l'afficher
          const panelWidth = 600; // Largeur par dÃ©faut
          document.documentElement.style.setProperty('--stats-width', panelWidth + 'px');

          // 2. Ajouter la classe pour prÃ©parer la grille
          document.body.classList.add('stats-open');

          // 3. Afficher le panneau avec animation
          setTimeout(() => {
            statsPanel.classList.remove('translate-x-full');

            // Afficher le bouton flottant
            if (floatClose) {
              floatClose.classList.remove('hidden');
            }

            // Initialiser les graphiques si pas encore fait
            if (typeof chartCommunication === 'undefined' || !chartCommunication) {
              if (typeof initCharts === 'function') {
                initCharts();
              }
            }

            if (typeof updateCharts === 'function') {
              updateCharts();
            }

          }, 50);
        });
      };

      window.closeStatsPanel = function () {
        const statsPanel = document.getElementById('statsPanel');
        const floatClose = document.getElementById('statsFloatingClose');

        if (!statsPanel) return;

        // Slide out
        statsPanel.classList.add('translate-x-full');
        document.body.classList.remove('stats-open');

        // Masquer le bouton flottant
        if (floatClose) {
          floatClose.classList.add('hidden');
        }

      };

      // =======================================================
      // 1.6 GESTION DU MENU Ã‰DITER (DROPDOWN)
      // =======================================================
      (function () {
        const btnEditer = document.getElementById('btnEditer');
        const dropdown = document.getElementById('dropdownEditer');

        if (!btnEditer || !dropdown) {
          console.warn('Menu Ã‰diter non trouvÃ©');
          return;
        }

        // Toggle dropdown avec positionnement dynamique et animation
        btnEditer.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();

          // Fermer tous les autres dropdowns (sauf celui-ci)
          document.querySelectorAll('.dropdown-menu').forEach(dd => {
            if (dd !== dropdown && !dd.classList.contains('hidden')) {
              dd.classList.remove('show');
              setTimeout(() => dd.classList.add('hidden'), 150);
            }
          });

          // Positionner le dropdown sous le bouton
          const rect = btnEditer.getBoundingClientRect();
          dropdown.style.top = `${rect.bottom + 8}px`;
          dropdown.style.left = `${rect.left}px`;

          // Toggle avec animation
          if (window.toggleDropdown) {
            toggleDropdown(dropdown, btnEditer);
          } else {
            dropdown.classList.toggle('hidden');
          }
        });

        // EmpÃªcher la fermeture au clic interne
        dropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Fermer au clic extÃ©rieur
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && e.target !== btnEditer) {
            dropdown.classList.remove('show');
            setTimeout(() => dropdown.classList.add('hidden'), 150);
          }
        });

      })();

      // =======================================================
      // 1.7 GESTION DU MENU COMPARER (DROPDOWN)
      // =======================================================
      (function () {
        const btnComparer = document.getElementById('btnComparer');
        const dropdown = document.getElementById('dropdownComparer');

        if (!btnComparer || !dropdown) {
          console.warn('Menu Comparer non trouvÃ©');
          return;
        }

        // Toggle dropdown avec positionnement dynamique
        btnComparer.addEventListener('click', (e) => {
          e.stopPropagation();

          const statsPanel = document.getElementById('statsPanel');
          const rect = btnComparer.getBoundingClientRect();

          // 1. Si les stats sont OUVERTES â†’ on les FERME (panic button)
          if (statsPanel && !statsPanel.classList.contains('translate-x-full')) {
            closeStatsPanel();

            // Refermer le petit dropdown si besoin
            dropdown.classList.add('hidden');

            // AccessibilitÃ© propre
            btnComparer.setAttribute('aria-expanded', 'false');

            return;
          }

          // 2. Sinon : comportement normal â†’ toggle du menu Comparer
          dropdown.style.top = `${rect.bottom + 8}px`;
          dropdown.style.left = `${rect.left}px`;
          dropdown.classList.toggle('hidden');

          btnComparer.setAttribute(
            'aria-expanded',
            dropdown.classList.contains('hidden') ? 'false' : 'true'
          );
        });

        // EmpÃªcher la fermeture au clic interne
        dropdown.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Fermer au clic extÃ©rieur
        document.addEventListener('click', (e) => {
          if (!dropdown.contains(e.target) && e.target !== btnComparer) {
            dropdown.classList.add('hidden');
          }
        });

        // === CÃ‚BLAGE DES BOUTONS ===

        // 1. Statistiques (ouvre le panneau stats en accordÃ©on)
        const btnStatsMenu = document.getElementById('btnStatsMenu');

        if (btnStatsMenu) {
          btnStatsMenu.addEventListener('click', () => {
            const panel = document.getElementById('statsPanel');

            if (!panel) {
              toast('âš ï¸ Panneau statistiques non disponible', 'warning');
              return;
            }

            // Fermer le menu
            dropdown.classList.add('hidden');

            // Utiliser la fonction centralisÃ©e
            openStatsPanel();

            // Mettre Ã  jour aria-expanded
            btnComparer.setAttribute('aria-expanded', 'true');

            toast('ğŸ“Š Panneau statistiques ouvert', 'info');
          });
        }

        // 2. Tableaux de bord analytiques
        const btnAnalyticsMenu = document.getElementById('btnAnalyticsMenu');

        if (btnAnalyticsMenu) {
          btnAnalyticsMenu.addEventListener('click', () => {
            if (window.openAnalyticsDashboard) {
              window.openAnalyticsDashboard();
            } else {
              toast('âš ï¸ Tableaux de bord analytiques non disponibles', 'warning');
            }
            dropdown.classList.add('hidden'); // Fermer le menu
          });
        }

      })();

      // =======================================================
      // 1.7.5 BRANCHEMENT DU BOUTON FLOTTANT STATS + GESTION Ã‰CHAP
      // =======================================================
      (function () {
        // Brancher le bouton flottant "Fermer âœ•"
        const statsFloatingClose = document.getElementById('statsFloatingClose');
        if (statsFloatingClose) {
          statsFloatingClose.addEventListener('click', () => {
            closeStatsPanel();
          });
        }

        // Fonction globale pour toggle la densitÃ© du header
        window.toggleHeaderDensity = function () {
          document.body.classList.toggle('header-xl');

          // Sauvegarder la prÃ©fÃ©rence
          if (document.body.classList.contains('header-xl')) {
            localStorage.setItem('headerDensity', 'xl');
            console.log('ğŸ–¥ï¸ Mode confort activÃ© (header XL)');
          } else {
            localStorage.setItem('headerDensity', 'compact');
            console.log('ğŸ“½ï¸ Mode compact activÃ© (rÃ©union/vidÃ©oprojecteur)');
          }
        };

        // Charger la prÃ©fÃ©rence sauvegardÃ©e au dÃ©marrage
        const savedDensity = localStorage.getItem('headerDensity');
        if (savedDensity === 'xl') {
          document.body.classList.add('header-xl');
        }

        // Raccourci clavier Alt+D pour toggle la densitÃ©
        document.addEventListener('keydown', (e) => {
          if (e.altKey && (e.key === 'd' || e.key === 'D')) {
            e.preventDefault();
            toggleHeaderDensity();
          }
        });

        // Gestion globale de la touche Ã‰chap
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            const reglerMenu = document.getElementById('dropdownRegler');
            const comparerMenu = document.getElementById('dropdownComparer');
            const editerMenu = document.getElementById('dropdownEditer');
            const statsPanel = document.getElementById('statsPanel');

            // Fermer le menu RÃ©gler
            if (reglerMenu && !reglerMenu.classList.contains('hidden')) {
              reglerMenu.classList.add('hidden');
              const btnRegler = document.getElementById('btnRegler');
              if (btnRegler) {
                btnRegler.setAttribute('aria-expanded', 'false');
              }
            }

            // Fermer le menu Comparer (le petit dropdown Comparer)
            if (comparerMenu && !comparerMenu.classList.contains('hidden')) {
              comparerMenu.classList.add('hidden');
              const btnComparer = document.getElementById('btnComparer');
              if (btnComparer) {
                btnComparer.setAttribute('aria-expanded', 'false');
              }
            }

            // Fermer le menu Ã‰diter
            if (editerMenu && !editerMenu.classList.contains('hidden')) {
              editerMenu.classList.add('hidden');
              const btnEditer = document.getElementById('btnEditer');
              if (btnEditer) {
                btnEditer.setAttribute('aria-expanded', 'false');
              }
            }

            // Fermer le panneau stats
            if (statsPanel && !statsPanel.classList.contains('translate-x-full')) {
              closeStatsPanel();
            }
          }
        });
      })();

      // =======================================================
      // 1.8 GESTION DU MENU ADMIN
      // =======================================================
      function initAdminMenu() {
        const adminRoot = document.getElementById('dropdownAdmin');
        const btnAdmin = document.getElementById('btnAdmin');
        if (!adminRoot || !btnAdmin) return;

        // Supprimer les doublons Ã©ventuels de #dropdownAdmin
        document.querySelectorAll('#dropdownAdmin').forEach((n, i) => { if (i > 0) n.remove(); });
        adminRoot.setAttribute('data-menu-root', '');

        const q = sel => adminRoot.querySelector(sel);
        const lockMsg = q('#adminLockMessage');
        const content = q('#adminContent');
        const btnUnlock = q('#btnUnlockAdmin');
        let btnLock = q('#btnLockAdmin');
        const status = document.getElementById('adminStatusIndicator');

        // Ã‰tat initial : toujours verrouillÃ© au dÃ©marrage (sÃ©curitÃ©)
        let isAdminUnlocked = false;
        localStorage.removeItem('adminUnlocked');
        localStorage.removeItem('adminForceMode');
        if (window.STATE) window.STATE.adminMode = false;

        function paintUI() {
          if (isAdminUnlocked) {
            lockMsg && lockMsg.classList.add('hidden');
            content && content.classList.remove('hidden');
            status && (status.textContent = 'ON', status.classList.add('text-white', 'font-bold'));
            btnAdmin.classList.remove('bg-red-600', 'hover:bg-red-700');
            btnAdmin.classList.add('bg-green-700', 'text-white', 'hover:bg-green-800');
          } else {
            lockMsg && lockMsg.classList.remove('hidden');
            content && content.classList.add('hidden');
            status && (status.textContent = 'OFF', status.classList.remove('text-white', 'font-bold'));
            btnAdmin.classList.remove('bg-green-700', 'hover:bg-green-800');
            btnAdmin.classList.add('bg-red-600', 'text-white', 'hover:bg-red-700');
          }
        }
        paintUI();

        // Menu fermÃ© au dÃ©marrage
        adminRoot.classList.add('hidden', 'opacity-0', 'scale-95');

        function openMenu() {
          adminRoot.classList.remove('hidden');
          void adminRoot.offsetWidth;
          requestAnimationFrame(() => {
            adminRoot.classList.remove('opacity-0', 'scale-95');
            adminRoot.classList.add('opacity-100', 'scale-100');
          });
        }

        function closeMenu() {
          adminRoot.classList.remove('opacity-100', 'scale-100');
          adminRoot.classList.add('opacity-0', 'scale-95');
          setTimeout(() => adminRoot.classList.add('hidden'), 200);
        }

        // Toggle du dropdown
        btnAdmin.addEventListener('click', (e) => {
          e.stopPropagation();
          const rect = btnAdmin.getBoundingClientRect();
          adminRoot.style.top = `${rect.bottom + 8}px`;
          adminRoot.style.left = `${rect.right - 320}px`;
          adminRoot.style.right = 'auto';
          adminRoot.classList.contains('hidden') ? openMenu() : closeMenu();
        });

        document.addEventListener('click', (e) => {
          if (!adminRoot.contains(e.target) && e.target !== btnAdmin && !adminRoot.classList.contains('hidden')) {
            closeMenu();
          }
        });
        adminRoot.addEventListener('click', e => e.stopPropagation());

        // Mot de passe
        const passwordInput = q('#adminPasswordInput');
        const passwordError = q('#adminPasswordError');
        const btnToggleVisibility = q('#btnTogglePasswordVisibility');

        if (btnToggleVisibility && passwordInput) {
          btnToggleVisibility.addEventListener('click', () => {
            const isPassword = passwordInput.type === 'password';
            passwordInput.type = isPassword ? 'text' : 'password';
            btnToggleVisibility.querySelector('i').className = isPassword ? 'fas fa-eye-slash' : 'fas fa-eye';
          });
        }

        async function checkPassword(pwd) {
          if (typeof google !== 'undefined' && google.script?.run?.getAdminPasswordFromConfig) {
            return new Promise((resolve) => {
              google.script.run
                .withSuccessHandler(configPwd => resolve(pwd === configPwd || (CONFIG && pwd === CONFIG.adminPassword)))
                .withFailureHandler(() => resolve(CONFIG && pwd === CONFIG.adminPassword))
                .getAdminPasswordFromConfig();
            });
          }
          return CONFIG && pwd === CONFIG.adminPassword;
        }

        async function unlockFlow() {
          const pwd = passwordInput ? passwordInput.value.trim() : '';
          if (!pwd) {
            passwordError && (passwordError.textContent = 'Veuillez entrer un mot de passe');
            passwordError && passwordError.classList.remove('hidden');
            passwordInput && passwordInput.classList.add('border-red-500');
            return;
          }

          if (await checkPassword(pwd)) {
            isAdminUnlocked = true;
            localStorage.setItem('adminUnlocked', 'true');
            paintUI();
            closeMenu();
            toast('Mode Admin activÃ©', 'success');
            passwordInput && (passwordInput.value = '');
            passwordError && passwordError.classList.add('hidden');
            passwordInput && passwordInput.classList.remove('border-red-500');
          } else {
            passwordError && (passwordError.textContent = 'Mot de passe incorrect');
            passwordError && passwordError.classList.remove('hidden');
            passwordInput && passwordInput.classList.add('border-red-500');
            passwordInput && passwordInput.select();
          }
        }

        btnUnlock && btnUnlock.addEventListener('click', (e) => { e.preventDefault(); unlockFlow(); });
        passwordInput && passwordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); unlockFlow(); } });
        passwordInput && passwordInput.addEventListener('input', () => {
          passwordError && passwordError.classList.add('hidden');
          passwordInput.classList.remove('border-red-500');
        });

        // Bouton Verrouiller (crÃ©Ã© si absent)
        if (!btnLock) {
          btnLock = document.createElement('button');
          btnLock.id = 'btnLockAdmin';
          btnLock.className = 'w-full px-4 py-2 my-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors';
          btnLock.innerHTML = '<i class="fas fa-lock mr-2"></i> Verrouiller le menu Admin';
          content && content.appendChild(btnLock);
        }
        btnLock.addEventListener('click', () => {
          localStorage.removeItem('adminUnlocked');
          localStorage.removeItem('adminForceMode');
          if (window.STATE) window.STATE.adminMode = false;
          isAdminUnlocked = false;
          paintUI();
          adminRoot.classList.add('hidden');
          toast('Mode Admin verrouillÃ©', 'info');
        });

        // AccordÃ©on scopÃ©
        window.toggleSection = window.toggleSection || function (key, el) {
          const root = el?.closest('[data-menu-root]') || document;
          const section = root.querySelector(`[data-section-id="${key}"]`);
          const body = section?.querySelector('.section-body') || section;
          const icon = section?.querySelector('.section-icon') || el?.querySelector('.fa-chevron-down');
          if (!body) return;
          body.classList.toggle('hidden');
          icon && icon.classList.toggle('rotate-180');
        };

        // CÃ¢blage des boutons Admin
        const wireButton = (id, handler) => {
          const btn = q(`#${id}`);
          btn && btn.addEventListener('click', () => { handler(); adminRoot.classList.add('hidden'); });
        };

        wireButton('btnSourcesAdmin', () => window.openStartupModal && openStartupModal({ force: true }));
        wireButton('btnOptimizationAdmin', () => {
          if (typeof OptimizationPanel !== 'undefined' && OptimizationPanel.open) OptimizationPanel.open();
          else if (window.openOptimizationPanel) window.openOptimizationPanel();
          else toast('Module d\'optimisation non chargÃ©', 'warning');
        });
        wireButton('menuDarkModeAdmin', () => window.toggleDarkMode && toggleDarkMode());
        wireButton('menuZoomAdmin', () => {
          const cards = document.querySelectorAll('.student-card');
          const isZoomed = cards[0]?.style.transform === 'scale(1.1)';
          cards.forEach(card => card.style.transform = isZoomed ? 'scale(1)' : 'scale(1.1)');
          toast(isZoomed ? 'Zoom dÃ©sactivÃ©' : 'Zoom activÃ©', 'info');
        });
        wireButton('menuFullscreenAdmin', () => {
          document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen();
        });
        wireButton('menuImportScoresAdmin', () => window.openImportScoresModal && openImportScoresModal());
        wireButton('btnExportAdmin', () => window.exportData && exportData());
        wireButton('menuRulesModal', () => window.openRulesModal && openRulesModal());

        // Mode Force Admin
        const toggleForce = q('#toggleAdminForceMode');
        if (toggleForce) {
          toggleForce.checked = false;

          toggleForce.addEventListener('change', () => {
            const isOn = toggleForce.checked;
            if (window.STATE) window.STATE.adminMode = isOn;
            localStorage.setItem('adminForceMode', isOn);

            toast(isOn
              ? 'Mode Force activÃ© - Contraintes ignorÃ©es'
              : 'Mode Force dÃ©sactivÃ© - Contraintes respectÃ©es',
              isOn ? 'warning' : 'success'
            );

            if (typeof renderColumns === 'function') renderColumns();
          });
        }
      }

      // Initialisation diffÃ©rÃ©e pour garantir le rendu DOM
      setTimeout(initAdminMenu, 0);

      // =======================================================
      // 2. LOGIQUE PRINCIPALE DE L'APPLICATION
      // =======================================================

      // TOUT votre code principal va ici, de "const CONFIG = ..." jusqu'Ã  la fin
      const CONFIG = {
        adminPassword: 'admin123',
        animation: {
          duration: 150
        }
      };

      // ========== GESTIONNAIRE D'ERREURS ==========
      window.addEventListener('error', (e) => {
        console.error('Erreur capturÃ©e:', e.message);
        e.preventDefault();
      });

      /* ---------- helper : Ã©lÃ¨ve vraiment valide --------- */
      function isValidStudent(e) {
        return e                     // objet prÃ©sent
          && e.id && e.id.trim()   // id non-vide
          && e.nom && e.nom.trim();/* au moins un NOM non-vide  */
      }




      // ========== MISE Ã€ JOUR DES STATISTIQUES ==========
      // Fonctions dÃ©jÃ  dÃ©finies plus haut



      // Fonction pour dÃ©placer automatiquement un groupe A
      function moveGroupA(eleveId, srcClasse, dstClasse) {
        const eleve = STATE.students[eleveId];
        if (!eleve.asso) return;

        const group = STATE.aGroups[`A${eleve.asso}`] || [];
        const movedMembers = [];

        // DÃ©placer tous les membres du groupe qui sont dans srcClasse
        group.forEach(memberId => {
          const memberCard = document.querySelector(`.student-card[data-id="${memberId}"]`);
          if (!memberCard) return;

          const memberClasse = memberCard.closest('.droppable-zone').dataset.classe;
          if (memberClasse === srcClasse) {
            const dstZone = document.querySelector(`.droppable-zone[data-classe="${dstClasse}"]`);
            if (dstZone) {
              dstZone.appendChild(memberCard);
              movedMembers.push(STATE.students[memberId].nom);
            }
          }
        });

        if (movedMembers.length > 1) {
          toast(`Groupe A${eleve.asso} dÃ©placÃ© : ${movedMembers.join(', ')}`, 'info');
        }
      }

      // ========== GESTION DES SWAPS - REMPLACEMENT COMPLET ==========
      // Remplacez TOUTE la section de gestion des swaps par ce code

      // Fonction pour vÃ©rifier si un swap est possible



      // Fonction pour gÃ©rer le clic sur une carte


      // Fonction pour activer/dÃ©sactiver le mode swap
      function toggleSwapMode() {
        STATE.swapMode = !STATE.swapMode;
        STATE.swapFirst = null;

        const btnSwapMain = document.getElementById('btnSwapMain');
        const sortables = document.querySelectorAll('.droppable-zone');

        if (STATE.swapMode) {
          if (btnSwapMain) {
            btnSwapMain.classList.add('active', 'btn-primary');
            btnSwapMain.classList.remove('btn-secondary');
            btnSwapMain.setAttribute('aria-pressed', 'true');
          }
          toast('ğŸ”„ Mode SWAP activÃ© - Cliquez sur deux Ã©lÃ¨ves pour les Ã©changer', 'info');

          // DÃ©sactiver le drag & drop
          sortables.forEach(zone => {
            const sortable = Sortable.get(zone);
            if (sortable) sortable.option('disabled', true);
          });
        } else {
          if (btnSwapMain) {
            btnSwapMain.classList.remove('active', 'btn-primary');
            btnSwapMain.classList.add('btn-secondary');
            btnSwapMain.setAttribute('aria-pressed', 'false');
          }

          // RÃ©activer le drag & drop
          sortables.forEach(zone => {
            const sortable = Sortable.get(zone);
            if (sortable) sortable.option('disabled', false);
          });

          // Nettoyer les sÃ©lections
          document.querySelectorAll('.student-card').forEach(card => {
            card.classList.remove('swap-mode');
          });
          document.querySelectorAll('.droppable-zone').forEach(zone => {
            zone.classList.remove('swap-target');
          });

          toast('Mode normal rÃ©tabli', 'info');
        }
      }
      // Exposer sur window pour les modules externes (bouton header, raccourcis)
      window.toggleSwapMode = toggleSwapMode;

      // S'assurer que performSwapAndClose est bien dÃ©fini pour la modal
      window.performSwapAndClose = function (id1, id2) {
        performSwap(id1, id2);

      }

      // ========== SUGGESTIONS DE SWAPS ==========
      function findSwapSuggestions() {
        const suggestions = [];
        const classes = Object.keys(STATE.rules);

        // Analyser chaque paire de classes
        for (let i = 0; i < classes.length; i++) {
          for (let j = i + 1; j < classes.length; j++) {
            const classe1 = classes[i];
            const classe2 = classes[j];

            const students1 = getCurrentClassContent(classe1).map(id => STATE.students[id]);
            const students2 = getCurrentClassContent(classe2).map(id => STATE.students[id]);

            // Chercher des swaps Ã©quilibrants
            students1.forEach(s1 => {
              students2.forEach(s2 => {
                // VÃ©rifier si le swap est possible
                const check = canSwap(s1.id, s2.id);
                if (!check.ok) return;

                // Calculer l'amÃ©lioration (Ã©quilibrage des sexes)
                const counts1 = countBySex(students1);
                const counts2 = countBySex(students2);

                const diffBefore = Math.abs(counts1.F - counts1.M) + Math.abs(counts2.F - counts2.M);

                const newCountF1 = counts1.F + (s2.sexe === 'F' ? 1 : 0) - (s1.sexe === 'F' ? 1 : 0);
                const newCountM1 = counts1.M + (s2.sexe === 'M' ? 1 : 0) - (s1.sexe === 'M' ? 1 : 0);
                const newCountF2 = counts2.F + (s1.sexe === 'F' ? 1 : 0) - (s2.sexe === 'F' ? 1 : 0);
                const newCountM2 = counts2.M + (s1.sexe === 'M' ? 1 : 0) - (s2.sexe === 'M' ? 1 : 0);

                const diffAfter = Math.abs(newCountF1 - newCountM1) + Math.abs(newCountF2 - newCountM2);

                if (diffAfter < diffBefore) {
                  suggestions.push({
                    student1: s1,
                    student2: s2,
                    classe1,
                    classe2,
                    improvement: diffBefore - diffAfter,
                    reason: 'Ã‰quilibrage des sexes'
                  });
                }
              });
            });
          }
        }

        // Trier par amÃ©lioration dÃ©croissante
        suggestions.sort((a, b) => b.improvement - a.improvement);

        return suggestions.slice(0, 10); // Top 10
      }




      // ========== GESTION UNDO/REDO ==========
      // Fonctions dÃ©jÃ  dÃ©finies plus haut

      // Le menu Admin est gÃ©rÃ© UNIQUEMENT par AdminMenuFix (ligne 3070)
      // Toute tentative d'appeler toggleAdminMode() sera bloquÃ©e par AdminMenuFix

      // ========== RECHERCHE ==========
      function setupSearch() {
        const searchInput = document.getElementById('search');

        if (!searchInput) return;

        searchInput.addEventListener('input', (e) => {
          const term = e.target.value.toLowerCase();
          STATE.searchTerm = term;

          document.querySelectorAll('.student-card').forEach(card => {
            const nameEl = card.querySelector('.student-fullname, .student-simple-name');
            if (!nameEl) return;

            const fullName = nameEl.textContent.toLowerCase();
            const match = !term || fullName.includes(term);

            card.style.display = match ? '' : 'none';
            card.classList.toggle('search-highlight', match && term);
          });
        });
      }



      // ========== FONCTIONS DE GESTION DES MODES ==========
      function openStartupModal(opts = {}) {
        const modal = document.getElementById('startupModal');
        const modalContent = document.getElementById('startupModalContent');
        if (!modal) return;

        // Si le tableau de rÃ©partition est dÃ©jÃ  affichÃ©, ne rien faire
        const board = document.getElementById('board');
        if (board && board.innerHTML.trim() !== '' && !(opts && opts.force)) {
          return;
        }

        // Afficher le modal avec animation fluide
        modal.classList.remove('hidden');

        // Animation d'entrÃ©e
        requestAnimationFrame(() => {
          modal.classList.remove('opacity-0');
          modal.classList.add('opacity-100');

          if (modalContent) {
            modalContent.classList.remove('scale-95', 'opacity-0');
            modalContent.classList.add('scale-100', 'opacity-100');
          }
        });

        checkCache(); // VÃ©rifier et afficher la derniÃ¨re sauvegarde automatique
      }



      // ========== FONCTIONS DE GESTION DES VUES ==========
      function toggleViewMode() {
        // Cycle: complete â†’ essential â†’ simple â†’ complete
        const modes = ['complete', 'essential', 'simple'];
        const currentIndex = modes.indexOf(STATE.viewMode);
        const nextIndex = (currentIndex + 1) % modes.length;
        STATE.viewMode = modes[nextIndex];

        localStorage.setItem('viewMode', STATE.viewMode);

        // Mettre Ã  jour les classes body
        document.body.classList.remove('simple-view', 'essential-view');
        if (STATE.viewMode === 'simple') {
          document.body.classList.add('simple-view');
        } else if (STATE.viewMode === 'essential') {
          document.body.classList.add('essential-view');
        }

        // Mettre Ã  jour le texte du bouton et aria-pressed
        const btn = document.getElementById('btnSimpleView');
        const textSpan = document.getElementById('viewModeText');
        if (btn && textSpan) {
          const modeLabels = {
            'complete': 'Essentielle',
            'essential': 'Simple',
            'simple': 'ComplÃ¨te'
          };
          textSpan.textContent = modeLabels[STATE.viewMode];
          // Mettre Ã  jour aria-pressed (true si mode diffÃ©rent de complete)
          btn.setAttribute('aria-pressed', STATE.viewMode !== 'complete');
        }

        // RecrÃ©er toutes les cartes pour appliquer la nouvelle vue
        document.querySelectorAll('.droppable-zone').forEach(zone => {
          const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
          zone.innerHTML = '';
          ids.forEach(id => {
            if (STATE.students && STATE.students[id]) {
              const card = createStudentCard(STATE.students[id]);
              if (card) zone.appendChild(card);
            }
          });
          setTimeout(() => adjustSimpleNamesFontSize(zone), 0);
        });
        if (window.applyLisibilitePreferences) {
          window.applyLisibilitePreferences();
        }
      }

      // Fonction adjustSimpleNamesFontSize dÃ©jÃ  dÃ©finie plus haut

      // ========== EXPORT DE LA DISPOSITION ==========
      // Fonction dÃ©jÃ  dÃ©finie plus haut

      // ========== EXPORT EXCEL ==========
      window.exportExcel = function () {
        const wb = XLSX.utils.book_new();

        // Feuille de rÃ©partition
        const data = [];
        document.querySelectorAll('.class-column').forEach(column => {
          const classe = column.querySelector('.classe-name').textContent;
          const cards = Array.from(column.querySelectorAll('.student-card'));

          cards.forEach(card => {
            const eleve = STATE.students[card.dataset.id];
            data.push({
              Classe: classe,
              Nom: eleve.nom,
              PrÃ©nom: eleve.prenom,
              Sexe: eleve.sexe,
              LV2: eleve.lv2,
              Option: eleve.opt,
              Dissociation: eleve.disso ? `D${eleve.disso}` : '',
              Association: eleve.asso ? `A${eleve.asso}` : '',
              'Score COM': eleve.scores.COM,
              'Score TRA': eleve.scores.TRA,
              'Score PART': eleve.scores.PART,
              'Score ABS': eleve.scores.ABS,
              'Classe origine': eleve.source,
              MobilitÃ©: eleve.mobilite
            });
          });
        });

        const ws = XLSX.utils.json_to_sheet(data);
        XLSX.utils.book_append_sheet(wb, ws, "RÃ©partition");

        // Feuille de statistiques
        const stats = [];
        document.querySelectorAll('.class-column').forEach(column => {
          const classe = column.querySelector('.classe-name').textContent;
          const count = column.querySelector('.count').textContent;
          const countF = column.querySelector('.count-f').textContent;
          const countM = column.querySelector('.count-m').textContent;

          stats.push({
            Classe: classe,
            'Total Ã©lÃ¨ves': count,
            Filles: countF,
            GarÃ§ons: countM,
            'Ratio F/M': `${Math.round(countF / count * 100)}% / ${Math.round(countM / count * 100)}%`
          });
        });

        const wsStats = XLSX.utils.json_to_sheet(stats);
        XLSX.utils.book_append_sheet(wb, wsStats, "Statistiques");

        // TÃ©lÃ©charger
        const niveau = STATE.niveau.replace('Â°', 'e') || 'classes';
        XLSX.writeFile(wb, `repartition_${niveau}_${new Date().toISOString().split('T')[0]}.xlsx`);

        toast('Export Excel gÃ©nÃ©rÃ© avec succÃ¨s', 'success');
        closeExportModal();
      }

      // ========== EXPORT PDF ==========
      window.exportPDF = async function () {
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');

        // Titre
        pdf.setFontSize(20);
        pdf.text(`RÃ©partition des Classes - ${STATE.niveau}`, 105, 20, { align: 'center' });

        // Date
        pdf.setFontSize(12);
        pdf.text(new Date().toLocaleDateString('fr-FR'), 105, 30, { align: 'center' });

        let yPos = 50;

        // Pour chaque classe
        document.querySelectorAll('.class-column').forEach((column, index) => {
          if (yPos > 250) {
            pdf.addPage();
            yPos = 20;
          }

          const classe = column.querySelector('.classe-name').textContent;
          const count = column.querySelector('.count').textContent;
          const countF = column.querySelector('.count-f').textContent;
          const countM = column.querySelector('.count-m').textContent;

          // Titre de la classe
          pdf.setFontSize(16);
          pdf.setTextColor(91, 33, 182); // Primary color
          pdf.text(classe, 20, yPos);

          // Stats
          pdf.setFontSize(10);
          pdf.setTextColor(0, 0, 0);
          pdf.text(`Total: ${count} Ã©lÃ¨ves (${countF} filles, ${countM} garÃ§ons)`, 60, yPos);

          yPos += 10;

          // Liste des Ã©lÃ¨ves
          const cards = Array.from(column.querySelectorAll('.student-card'));
          cards.forEach((card, i) => {
            if (yPos > 270) {
              pdf.addPage();
              yPos = 20;
            }

            const eleve = STATE.students[card.dataset.id];
            const text = `${i + 1}. ${eleve.nom} ${eleve.prenom} - ${eleve.lv2}${eleve.opt ? '/' + eleve.opt : ''}`;
            pdf.text(text, 25, yPos);
            yPos += 5;
          });

          yPos += 10;
        }); // â† Fin de la boucle sur les colonnes

        // Ajouter les graphiques si le panel stats est ouvert
        if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
          pdf.addPage();
          pdf.setFontSize(16);
          pdf.text('Statistiques', 105, 20, { align: 'center' });

          // Capturer les graphiques
          const canvas1 = document.getElementById('chartStacked');
          if (canvas1) {
            const imgData1 = canvas1.toDataURL('image/png');
            pdf.addImage(imgData1, 'PNG', 20, 40, 170, 80);
          }

          const canvas2 = document.getElementById('chartDetailed');
          if (canvas2) {
            const imgData2 = canvas2.toDataURL('image/png');
            pdf.addImage(imgData2, 'PNG', 20, 130, 170, 80);
          }
        }

        const niveau = STATE.niveau.replace('Â°', 'e') || 'classes';
        pdf.save(`repartition_${niveau}_${new Date().toISOString().split('T')[0]}.pdf`);

        toast('Export PDF gÃ©nÃ©rÃ© avec succÃ¨s', 'success');
        closeExportModal();
      } // â† Fin correcte de la fonction exportPDF

      // ========== COMPARAISON AVANT/APRÃˆS ==========
      window.showComparison = function () {
        if (!STATE.originalData) {
          toast('Aucune donnÃ©e de comparaison disponible', 'warning');
          return; a
        }

        // CrÃ©er une modal de comparaison
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
      <div class="modal-content" style="max-width: 1200px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">Comparaison avant/aprÃ¨s rÃ©partition</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="comparison-container">
            <div class="comparison-side">
              <h3>Ã‰tat initial</h3>
              <div id="comparisonBefore"></div>
            </div>
            <div class="comparison-side">
              <h3>Ã‰tat actuel</h3>
              <div id="comparisonAfter"></div>
            </div>
          </div>
        </div>
      </div>
    `;

        document.body.appendChild(modal);

        // Remplir les donnÃ©es
        const beforeContainer = modal.querySelector('#comparisonBefore');
        const afterContainer = modal.querySelector('#comparisonAfter');

        // Ã‰tat initial
        STATE.originalData.forEach(group => {
          const div = document.createElement('div');
          div.className = 'mb-4';
          div.innerHTML = `
        <h4 class="font-bold">${group.classe}</h4>
        <p>Total: ${group.eleves.length} Ã©lÃ¨ves</p>
        <p>F/M: ${group.eleves.filter(e => e.sexe === 'F').length}/${group.eleves.filter(e => e.sexe === 'M').length}</p>
      `;
          beforeContainer.appendChild(div);
        });

        // Ã‰tat actuel
        document.querySelectorAll('.class-column').forEach(column => {
          const classe = column.querySelector('.classe-name').textContent;
          const count = column.querySelector('.count').textContent;
          const countF = column.querySelector('.count-f').textContent;
          const countM = column.querySelector('.count-m').textContent;

          const div = document.createElement('div');
          div.className = 'mb-4';
          div.innerHTML = `
        <h4 class="font-bold">${classe}</h4>
        <p>Total: ${count} Ã©lÃ¨ves</p>
        <p>F/M: ${countF}/${countM}</p>
      `;
          afterContainer.appendChild(div);
        });

        closeExportModal();
      }

      // ========== MODAL EXPORT ==========
      window.closeExportModal = function () {
        document.getElementById('exportModal').classList.add('hidden');
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('overlay').classList.remove('active');
      }

      // ========== Ã‰DITION DES RÃˆGLES ==========
      function openRulesModal() {
        const container = document.getElementById('rulesContainer');
        container.innerHTML = '';

        // Pour chaque classe
        Object.keys(STATE.rules).forEach(classe => {
          const rule = STATE.rules[classe];

          const div = document.createElement('div');
          div.className = 'mb-6 p-4 border rounded-lg';
          div.innerHTML = `
        <h3 class="font-bold text-lg mb-3">${classe}</h3>
        <div class="grid grid-cols-2 gap-4">
          <div class="form-group">
            <label class="form-label">CapacitÃ© maximale</label>
            <input type="number" class="form-control" 
              data-classe="${classe}" 
              data-field="capacity" 
              value="${rule.capacity || 28}" 
              min="1" max="35">
          </div>
          <div class="form-group">
            <label class="form-label">Quotas (format: OPT=nombre)</label>
            <textarea class="form-control" 
              data-classe="${classe}" 
              data-field="quotas" 
              rows="3">${Object.entries(rule.quotas || {}).map(([k, v]) => `${k}=${v}`).join(', ')}</textarea>
          </div>
        </div>
      `;

          container.appendChild(div);
        });

        document.getElementById('rulesModal').classList.remove('hidden');
        document.getElementById('overlay').classList.remove('hidden');
        document.getElementById('overlay').classList.add('active');
      }

      window.closeRulesModal = function () {
        document.getElementById('rulesModal').classList.add('hidden');
        document.getElementById('overlay').classList.add('hidden');
        document.getElementById('overlay').classList.remove('active');
      }

      window.saveRules = async function () {
        const newRules = {};

        // Collecter les nouvelles rÃ¨gles
        document.querySelectorAll('#rulesContainer input, #rulesContainer textarea').forEach(input => {
          const classe = input.dataset.classe;
          const field = input.dataset.field;

          if (!newRules[classe]) {
            newRules[classe] = { capacity: 28, quotas: {} };
          }

          if (field === 'capacity') {
            newRules[classe].capacity = parseInt(input.value) || 28;
          } else if (field === 'quotas') {
            // Parser les quotas
            const quotasStr = input.value;
            quotasStr.split(',').forEach(pair => {
              const [opt, val] = pair.split('=').map(s => s.trim());
              if (opt && val) {
                newRules[classe].quotas[opt.toUpperCase()] = parseInt(val) || 0;
              }
            });
          }
        });

        // Mettre Ã  jour l'Ã©tat
        STATE.rules = newRules;

        // Sauvegarder en backend
        try {
          const result = await gsRun('updateStructureRules', newRules);
          if (result.success) {
            toast('RÃ¨gles mises Ã  jour avec succÃ¨s', 'success');
            closeRulesModal();
          } else {
            toast('Erreur lors de la mise Ã  jour des rÃ¨gles', 'error');
          }
        } catch (error) {
          console.error('Erreur:', error);
          toast('Erreur lors de la mise Ã  jour des rÃ¨gles', 'error');
        }
      }

      // ========== MISE Ã€ JOUR INTELLIGENTE DU PANEAU DES STATISTIQUES ==========

      // ========== GRAPHIQUES ==========
      function initCharts() {
        console.log('ğŸ¨ Initialisation des graphiques...');
        const statsContent = document.getElementById('statsContent');

        // HTML COMPLET avec tous les graphiques existants + nouveaux
        statsContent.innerHTML = `
      <div class="mb-2">
        <div class="flex gap-2 mb-2">
          <button onclick="switchChart('COM')" class="px-3 py-1 text-xs rounded font-semibold bg-green-500 text-white" id="btnCOM">COM</button>
          <button onclick="switchChart('TRA')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnTRA">TRA</button>
          <button onclick="switchChart('PART')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnPART">PART</button>
          <button onclick="switchChart('ABS')" class="px-3 py-1 text-xs rounded font-semibold bg-gray-300" id="btnABS">ABS</button>
        </div>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Distribution - <span id="scoreType">Comportement</span></h3>
        <canvas id="chartStacked" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">Moyennes par classe</h3>
        <canvas id="chartDetailed" style="max-height: 150px;"></canvas>
      </div>
      
      <div class="grid grid-cols-2 gap-2">
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">RÃ©partition LV2</h3>
          <canvas id="chartLV2" style="max-height: 120px;"></canvas>
        </div>
        
        <div class="chart-container" style="padding: 10px;">
          <h3 class="chart-title text-sm">Options</h3>
          <canvas id="chartOptions" style="max-height: 120px;"></canvas>
        </div>
      </div>
      
      <div class="chart-container" style="padding: 10px; margin-top: 10px;">
        <h3 class="chart-title text-sm">Statistiques globales</h3>
        <div id="globalStats" class="text-xs"></div>
      </div>
      
      <!-- ========== NOUVEAUX AJOUTS EN BAS ========== -->
      
      <!-- MÃ©triques globales -->
  <div class="grid grid-cols-4 gap-3 mb-4 mt-4">
    <div class="stats-metric">
      <div class="metric-value" id="totalStudentsMetric">0</div>
      <div class="metric-label">Ã‰lÃ¨ves</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="genderBalanceMetric">50% F</div>
      <div class="metric-label">Ratio Filles</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="avgClassSizeMetric">0</div>
      <div class="metric-label">Moy/Classe</div>
    </div>
    <div class="stats-metric">
      <div class="metric-value" id="conformityScoreMetric">âœ… OK</div>
      <div class="metric-label">ProblÃ¨mes</div>
    </div>
  </div>
      
      <!-- Nouveau graphique LV2 dÃ©taillÃ© -->
      <div class="chart-container" style="padding: 10px; margin-bottom: 10px;">
        <h3 class="chart-title text-sm">
          <i class="fas fa-language text-purple-500"></i>
          RÃ©partition LV2 par Classe
        </h3>
        <canvas id="chartLV2Details" style="max-height: 180px;"></canvas>
      </div>
    `;

        // Chart 1 : Distribution empilÃ©e par classe
        const ctx1 = document.getElementById('chartStacked').getContext('2d');
        chartCommunication = new Chart(ctx1, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              { label: '1', data: [], backgroundColor: '#dc2626', stack: 'Stack 0' },
              { label: '2', data: [], backgroundColor: '#fbbf24', stack: 'Stack 0' },
              { label: '3', data: [], backgroundColor: '#22c55e', stack: 'Stack 0' },
              { label: '4', data: [], backgroundColor: '#15803d', stack: 'Stack 0' }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true,
                ticks: { font: { size: 10 } }
              },
              y: {
                stacked: true,
                beginAtZero: true,
                ticks: { font: { size: 10 } }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'right',
                labels: {
                  boxWidth: 12,
                  font: { size: 10 }
                }
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    return `Score ${context.datasetIndex + 1}: ${context.parsed.y}`;
                  }
                }
              }
            }
          }
        });

        // Chart 2 : Distribution par critÃ¨res
        const ctx2 = document.getElementById('chartDetailed').getContext('2d');
        chartDistribution = new Chart(ctx2, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [
              { label: 'COM', data: [], backgroundColor: '#10b981' },
              { label: 'TRA', data: [], backgroundColor: '#3b82f6' },
              { label: 'PART', data: [], backgroundColor: '#f59e0b' },
              { label: 'ABS', data: [], backgroundColor: '#ef4444' }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { ticks: { font: { size: 10 } } },
              y: {
                beginAtZero: true,
                max: 4,
                ticks: { font: { size: 10 } }
              }
            },
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  boxWidth: 10,
                  font: { size: 10 }
                }
              }
            }
          }
        });

        // Chart 3 : Distribution LV2
        const ctx3 = document.getElementById('chartLV2').getContext('2d');
        chartLV2 = new Chart(ctx3, {
          type: 'doughnut',
          data: {
            labels: [],
            datasets: [{
              data: [],
              backgroundColor: ['#dc2626', '#059669', '#2563eb', '#7c3aed', '#d97706']
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  boxWidth: 10,
                  font: { size: 10 }
                }
              }
            }
          }
        });

        // Chart 4 : Distribution Options
        const ctx4 = document.getElementById('chartOptions').getContext('2d');
        chartOptions = new Chart(ctx4, {
          type: 'bar',
          data: {
            labels: [],
            datasets: [{
              label: 'Ã‰lÃ¨ves',
              data: [],
              backgroundColor: '#8b5cf6'
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            scales: {
              x: {
                beginAtZero: true,
                ticks: { font: { size: 10 } }
              },
              y: { ticks: { font: { size: 10 } } }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });

        // ========== NOUVEAU GRAPHIQUE LV2 DÃ‰TAILLÃ‰ ==========
        window.chartLV2Details = null;
        const ctx5 = document.getElementById('chartLV2Details');
        if (ctx5) {
          window.chartLV2Details = new Chart(ctx5.getContext('2d'), {
            type: 'bar',
            data: {
              labels: [],
              datasets: []
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  stacked: true,
                  ticks: { font: { size: 10 } }
                },
                y: {
                  stacked: true,
                  beginAtZero: true,
                  ticks: { font: { size: 10 } }
                }
              },
              plugins: {
                legend: {
                  position: 'bottom',
                  labels: {
                    boxWidth: 12,
                    font: { size: 10 }
                  }
                }
              }
            }
          });
        }

        // Initialiser avec COM
        updateCharts('COM');
      }

      // Variable locale pour le type de score actuel (comme dans la version qui fonctionne)
      let currentScoreType = 'COM';



      // Fonction pour changer de graphique
      window.switchChart = function (type) {
        currentScoreType = type;

        // Mettre Ã  jour les boutons
        ['COM', 'TRA', 'PART', 'ABS'].forEach(t => {
          const btn = document.getElementById(`btn${t}`);
          if (t === type) {
            btn.classList.remove('bg-gray-300');
            btn.classList.add('bg-green-500', 'text-white');
          } else {
            btn.classList.remove('bg-green-500', 'text-white');
            btn.classList.add('bg-gray-300');
          }
        });

        // Mettre Ã  jour le titre
        const titles = {
          'COM': 'Comportement',
          'TRA': 'Travail',
          'PART': 'Participation',
          'ABS': 'AbsentÃ©isme'
        };
        document.getElementById('scoreType').textContent = titles[type];

        // Mettre Ã  jour les graphiques
        updateCharts(type);
      }

      function updateCharts(scoreType = null) {
        try {
          if (!scoreType) scoreType = currentScoreType;

          // Collecter les donnÃ©es par classe
          const dataByClass = {};
          const classes = [];
          const lv2Count = {};
          const optionCount = {};

          // âš¡ OPTIMISATION Phase 11: Utiliser cache DOM au lieu de querySelector rÃ©pÃ©tÃ©s
          const classColumns = window.DOM ? window.DOM.getAll('.class-column', true) : document.querySelectorAll('.class-column');
          classColumns.forEach(column => {
            const classe = column.querySelector('.classe-name').textContent;
            classes.push(classe);

            // IMPORTANT: RÃ©cupÃ©rer les cartes ACTUELLES de cette colonne
            const cards = Array.from(column.querySelectorAll('.student-card'));

            dataByClass[classe] = {
              total: cards.length,
              scores: {
                COM: [0, 0, 0, 0],
                TRA: [0, 0, 0, 0],
                PART: [0, 0, 0, 0],
                ABS: [0, 0, 0, 0]
              },
              averages: { COM: 0, TRA: 0, PART: 0, ABS: 0 }
            };

            // Calculer les scores pour chaque Ã©lÃ¨ve ACTUELLEMENT dans cette classe
            cards.forEach(card => {
              const eleve = STATE.students[card.dataset.id];
              if (!eleve) return;

              // Compter les scores pour le graphique empilÃ©
              const scoreMap = {
                'COM': eleve.scores.COM,
                'TRA': eleve.scores.TRA,
                'PART': eleve.scores.PART,
                'ABS': eleve.scores.ABS
              };

              const score = scoreMap[scoreType];
              if (score > 0) {
                dataByClass[classe].scores[scoreType][score - 1]++;
              }

              // Calculer les moyennes pour tous les critÃ¨res
              if (eleve.scores.COM > 0) dataByClass[classe].averages.COM += eleve.scores.COM;
              if (eleve.scores.TRA > 0) dataByClass[classe].averages.TRA += eleve.scores.TRA;
              if (eleve.scores.PART > 0) dataByClass[classe].averages.PART += eleve.scores.PART;
              if (eleve.scores.ABS > 0) dataByClass[classe].averages.ABS += eleve.scores.ABS;

              // Compter LV2 et options
              if (eleve.lv2) {
                lv2Count[eleve.lv2] = (lv2Count[eleve.lv2] || 0) + 1;
              }
              if (eleve.opt) {
                optionCount[eleve.opt] = (optionCount[eleve.opt] || 0) + 1;
              }
            });

            // Calculer les moyennes
            const total = cards.length || 1;
            dataByClass[classe].averages.COM /= total;
            dataByClass[classe].averages.TRA /= total;
            dataByClass[classe].averages.PART /= total;
            dataByClass[classe].averages.ABS /= total;
          });

          // VÃ©rifier que les graphiques existent
          if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
            console.warn('Graphiques non initialisÃ©s');
            return;
          }

          // Mettre Ã  jour Chart 1 (Distribution empilÃ©e)
          const sortedClasses = classes.sort();
          chartCommunication.data.labels = sortedClasses;

          // Mettre Ã  jour Chart 1 (Distribution empilÃ©e)
          chartCommunication.data.labels = sortedClasses;

          // Mettre Ã  jour les datasets pour le score sÃ©lectionnÃ©
          for (let i = 0; i < 4; i++) {
            chartCommunication.data.datasets[i].data = sortedClasses.map(c =>
              dataByClass[c].scores[scoreType][i]
            );
          }

          // VÃ©rification de cohÃ©rence des longueurs
          console.assert(
            sortedClasses.length === chartCommunication.data.datasets[0].data.length,
            'ğŸ’¥ IncohÃ©rence longueurs', sortedClasses.length, chartCommunication.data.datasets[0].data.length
          );

          // Mettre Ã  jour Chart 2 (Moyennes par critÃ¨re)
          chartDistribution.data.labels = sortedClasses;
          chartDistribution.data.datasets[0].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.COM * 100) / 100
          );
          chartDistribution.data.datasets[1].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.TRA * 100) / 100
          );
          chartDistribution.data.datasets[2].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.PART * 100) / 100
          );
          chartDistribution.data.datasets[3].data = sortedClasses.map(c =>
            Math.round(dataByClass[c].averages.ABS * 100) / 100
          );

          // Mettre Ã  jour Chart 3 (LV2)
          chartLV2.data.labels = Object.keys(lv2Count);
          chartLV2.data.datasets[0].data = Object.values(lv2Count);

          // Mettre Ã  jour Chart 4 (Options)
          chartOptions.data.labels = Object.keys(optionCount);
          chartOptions.data.datasets[0].data = Object.values(optionCount);

          // Statistiques globales
          let globalTotals = { eleves: 0, filles: 0, garcons: 0 };
          let globalScores = { COM: 0, TRA: 0, PART: 0, ABS: 0 };
          let scoreCounts = { COM: 0, TRA: 0, PART: 0, ABS: 0 };

          // Parcourir TOUTES les cartes actuellement affichÃ©es
          document.querySelectorAll('.student-card').forEach(card => {
            const eleve = STATE.students[card.dataset.id];
            if (eleve) {
              globalTotals.eleves++;
              if (eleve.sexe === 'F') globalTotals.filles++;
              else globalTotals.garcons++;

              if (eleve.scores.COM > 0) { globalScores.COM += eleve.scores.COM; scoreCounts.COM++; }
              if (eleve.scores.TRA > 0) { globalScores.TRA += eleve.scores.TRA; scoreCounts.TRA++; }
              if (eleve.scores.PART > 0) { globalScores.PART += eleve.scores.PART; scoreCounts.PART++; }
              if (eleve.scores.ABS > 0) { globalScores.ABS += eleve.scores.ABS; scoreCounts.ABS++; }
            }
          });

          const globalStatsHtml = `
      <p><strong>Total Ã©lÃ¨ves :</strong> ${globalTotals.eleves}</p>
      <p><strong>RÃ©partition :</strong> ${globalTotals.filles} filles (${Math.round(globalTotals.filles / globalTotals.eleves * 100)}%) / ${globalTotals.garcons} garÃ§ons (${Math.round(globalTotals.garcons / globalTotals.eleves * 100)}%)</p>
      <p class="mt-2"><strong>Moyennes globales :</strong></p>
      <ul>
        <li>Comportement : ${scoreCounts.COM > 0 ? (globalScores.COM / scoreCounts.COM).toFixed(2) : 'N/A'}</li>
        <li>Travail : ${scoreCounts.TRA > 0 ? (globalScores.TRA / scoreCounts.TRA).toFixed(2) : 'N/A'}</li>
        <li>Participation : ${scoreCounts.PART > 0 ? (globalScores.PART / scoreCounts.PART).toFixed(2) : 'N/A'}</li>
        <li>Absences : ${scoreCounts.ABS > 0 ? (globalScores.ABS / scoreCounts.ABS).toFixed(2) : 'N/A'}</li>
      </ul>
    `;

          // âš¡ OPTIMISATION Phase 11: Utiliser cache DOM
          const globalStatsElement = window.DOM ? window.DOM.get('#globalStats') : document.getElementById('globalStats');
          if (globalStatsElement) {
            globalStatsElement.innerHTML = globalStatsHtml;
          }

          chartCommunication.update();
          chartDistribution.update();
          chartLV2.update();
          chartOptions.update();

          // Mettre Ã  jour les autres mÃ©triques
          updateNewMetrics();
          updateLV2Details();

        } catch (error) {
          console.error('Erreur dans updateCharts:', error);
        }
      }

      window.updateCharts = updateCharts;

      // ========== MODE SOMBRE ==========
      function toggleDarkMode() {
        STATE.darkMode = !STATE.darkMode;
        document.body.classList.toggle('dark-mode');

        // Mettre Ã  jour l'icÃ´ne du bouton si prÃ©sent
        const btnDarkMode = document.getElementById('btnDarkMode');
        if (btnDarkMode) {
          const icon = btnDarkMode.querySelector('i');
          if (icon) {
            icon.className = STATE.darkMode ? 'fas fa-sun' : 'fas fa-moon';
          }
        }

        // Mettre Ã  jour le bouton flottant si prÃ©sent
        const darkModeToggle = document.getElementById('darkModeToggle');
        if (darkModeToggle) {
          const icon = darkModeToggle.querySelector('i');
          if (icon) {
            if (STATE.darkMode) {
              icon.className = 'fas fa-sun text-xl';
              darkModeToggle.className = 'fixed bottom-4 right-4 w-14 h-14 rounded-full bg-gradient-to-br from-yellow-400 to-orange-500 text-white shadow-2xl hover:scale-110 transition-all duration-300 flex items-center justify-center z-[99999]';
            } else {
              icon.className = 'fas fa-moon text-xl';
              darkModeToggle.className = 'fixed bottom-4 right-4 w-14 h-14 rounded-full bg-gradient-to-br from-purple-600 to-indigo-600 text-white shadow-2xl hover:scale-110 transition-all duration-300 flex items-center justify-center z-[99999]';
            }
          }
        }

        // Sauvegarder la prÃ©fÃ©rence
        try {
          localStorage.setItem('darkMode', STATE.darkMode);
        } catch (e) {
          console.log('localStorage non disponible');
        }

        // Message avec raccourci clavier
        const message = STATE.darkMode
          ? 'ğŸŒ™ Mode sombre activÃ© (Touche D ou clic sur le bouton flottant)'
          : 'â˜€ï¸ Mode clair activÃ© (Touche D ou clic sur le bouton flottant)';
        toast(message, 'info');
      }

      // Exposer globalement
      window.toggleDarkMode = toggleDarkMode;
      window.setDarkMode = setDarkMode;

      // ========== MODE ZOOM ==========
      function toggleZoom() {
        STATE.zoomMode = !STATE.zoomMode;
        document.body.classList.toggle('zoom-cards');

        const btnZoom = document.getElementById('btnZoom');
        if (STATE.zoomMode) {
          btnZoom.innerHTML = '<i class="fas fa-search-minus"></i>';
          toast('Mode zoom activÃ©', 'info');
        } else {
          btnZoom.innerHTML = '<i class="fas fa-search-plus"></i>';
          toast('Mode zoom dÃ©sactivÃ©', 'info');
        }
      }

      // ========== PLEIN Ã‰CRAN STATS ==========
      window.toggleFullscreenStats = function () {
        STATE.fullscreenStats = !STATE.fullscreenStats;
        const statsPanel = document.getElementById('statsPanel');

        if (STATE.fullscreenStats) {
          document.body.classList.add('fullscreen-stats');
          statsPanel.classList.remove('translate-x-full');

          // Optionnel : demander le plein Ã©cran natif
          if (statsPanel.requestFullscreen) {
            statsPanel.requestFullscreen();
          }

          const btnFullscreen = document.getElementById('btnFullscreen');
          if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-compress"></i>';
        } else {
          document.body.classList.remove('fullscreen-stats');

          // Optionnel : sortir du plein Ã©cran natif
          if (document.fullscreenElement) {
            document.exitFullscreen();
          }

          const btnFullscreen = document.getElementById('btnFullscreen');
          if (btnFullscreen) btnFullscreen.innerHTML = '<i class="fas fa-expand"></i>';
        }

        // Forcer la mise Ã  jour des graphiques
        setTimeout(() => {
          if (chartCommunication) chartCommunication.resize();
          if (chartDistribution) chartDistribution.resize();
          if (chartLV2) chartLV2.resize();
          if (chartOptions) chartOptions.resize();
        }, 300);
      }

      // ========== MODE ANCRÃ‰ ==========
      function toggleAnchoredStats() {
        STATE.anchoredStats = !STATE.anchoredStats;
        const statsPanel = document.getElementById('statsPanel');

        if (STATE.anchoredStats) {
          statsPanel.classList.add('anchored');
          document.getElementById('btnAnchor').classList.add('active');
          toast('Panel statistiques ancrÃ©', 'info');
        } else {
          statsPanel.classList.remove('anchored');
          document.getElementById('btnAnchor').classList.remove('active');
          toast('Panel statistiques flottant', 'info');
        }
      }

      // ========== RACCOURCIS CLAVIER ==========
      function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          // Ignorer si on est dans un input
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          // Ctrl+Z : Annuler
          if (e.ctrlKey && e.key === 'z') {
            e.preventDefault();
            undo();
          }

          // Ctrl+Y : Refaire
          if (e.ctrlKey && e.key === 'y') {
            e.preventDefault();
            redo();
          }

          // S : Mode swap
          if (e.key === 's' && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            toggleSwapMode();
          }

          // T : Statistiques
          if (e.key === 't' && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            document.getElementById('btnStats').click();
          }

          // D : Mode sombre (RACCOURCI PRIORITAIRE)
          if (e.key === 'd' || e.key === 'D') {
            if (!e.ctrlKey && !e.altKey) {
              e.preventDefault();
              toggleDarkMode();
              console.log('ğŸŒ“ Raccourci clavier D : Mode sombre basculÃ©');
            }
          }

          // F : Plein Ã©cran stats (si panel ouvert)
          if (e.key === 'f' && !e.ctrlKey && !e.altKey) {
            if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
              e.preventDefault();
              toggleFullscreenStats();
            }
          }

          // Ctrl+F : Recherche
          if (e.ctrlKey && e.key === 'f') {
            e.preventDefault();
            document.getElementById('search').focus();
          }

          // ? : Aide
          if (e.key === '?' || (e.shiftKey && e.key === '/')) {
            e.preventDefault();
            toggleKeyboardHelp();
          }

          // M : Ouvrir le modal de sÃ©lection de mode
          if (e.key === 'm' && !e.ctrlKey && !e.altKey) {
            e.preventDefault();
            openStartupModal();
          }

          // Ã‰chap : Fermer les modals
          if (e.key === 'Escape') {
            // Fermer stats si ouvert
            if (!document.getElementById('statsPanel').classList.contains('translate-x-full')) {
              const panel = document.getElementById('statsPanel');
              panel.classList.add('translate-x-full');

              setTimeout(() => {
                document.body.classList.remove('stats-open');
              }, 300);
            }

            // Fermer autres modals
            document.querySelectorAll('.modal:not(.hidden)').forEach(modal => {
              modal.classList.add('hidden');
            });

            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('overlay').classList.remove('active');
          }
        });
      }

      // ========== AIDE RACCOURCIS CLAVIER ==========
      function toggleKeyboardHelp() {
        const help = document.getElementById('keyboardShortcuts');
        help.classList.toggle('hidden');

        if (!help.classList.contains('hidden')) {
          toast('Raccourcis clavier affichÃ©s', 'info');
        }
      }

      // ========== FONCTION DE SAUVEGARDE AVEC PROGRESSION ==========
      // Extracted from setupEventListeners for better code organization (Phase 2 refactoring)
      async function lancerSauvegardeAvecProgression(saveFunctionName, buttonElement, options = {}) {
        const { title = 'SAUVEGARDE EN COURS...', successMessage = 'Sauvegarde rÃ©ussie', progressive = true, forcedMode = null } = options;

        if (!window.saveProgressManager) {
          console.error('SaveProgressManager non trouvÃ© !');
          toast('Erreur : composant de progression manquant.', 'error');
          return;
        }

        // DÃ©sactiver le bouton
        if (buttonElement) buttonElement.disabled = true;

        // DÃ©marrer la barre de progression
        window.saveProgressManager.start();
        const header = document.querySelector('#saveProgressBar .save-progress-header span');
        if (header) header.textContent = title;

        try {
          // Ã‰tape 1: PrÃ©paration (10%)
          window.saveProgressManager.updateProgress(10, 'step1');
          const disposition = exportDisposition();

          if (!disposition || Object.keys(disposition).length === 0) {
            throw new Error('Aucune classe Ã  sauvegarder');
          }

          window.saveProgressManager.updateProgress(20, 'step2');
          await new Promise(resolve => setTimeout(resolve, 200));

          // âœ… SAUVEGARDE PROGRESSIVE CLASSE PAR CLASSE (Ã©vite les timeouts)
          if (progressive && saveFunctionName === 'saveCacheData') {
            const classes = Object.keys(disposition);
            const totalClasses = classes.length;
            let successCount = 0;
            const errors = [];


            for (let i = 0; i < totalClasses; i++) {
              const classe = classes[i];
              const classMap = { [classe]: disposition[classe] };

              // Mettre Ã  jour la progression (20% Ã  90%)
              const progress = 20 + ((i / totalClasses) * 70);
              window.saveProgressManager.updateProgress(progress, 'step3');

              // Mise Ã  jour du titre avec le nom de la classe en cours
              if (header) header.innerHTML = `<i class="fas fa-save mr-2"></i>${escapeHtml(title)} - ${escapeHtml(classe)} (${i + 1}/${totalClasses})`;

              try {
                // âœ… Sauvegarder UNE classe Ã  la fois
                const result = await gsRun(saveFunctionName, classMap, STATE.currentMode);

                if (!result || !result.success) {
                  errors.push(`âŒ ${classe}: ${result?.message || 'Erreur inconnue'}`);
                  console.error(`âŒ Ã‰chec sauvegarde ${classe}:`, result);
                } else {
                  successCount++;
                }
              } catch (err) {
                errors.push(`âŒ ${classe}: ${err.message}`);
                console.error(`âŒ Exception sauvegarde ${classe}:`, err);
              }

              // Petit dÃ©lai pour Ã©viter les timeouts consÃ©cutifs
              await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Finalisation (100%)
            window.saveProgressManager.updateProgress(100, 'step4');

            if (successCount === totalClasses) {
              window.saveProgressManager.complete(true);
              toast(`âœ… ${successCount} classe(s) sauvegardÃ©e(s) avec succÃ¨s !`, 'success');
            } else if (successCount > 0) {
              window.saveProgressManager.complete(true);
              toast(`âš ï¸ ${successCount}/${totalClasses} classe(s) sauvegardÃ©e(s). Erreurs: ${errors.join(', ')}`, 'warning');
              console.warn('Erreurs de sauvegarde:', errors);
            } else {
              throw new Error('Aucune classe sauvegardÃ©e: ' + errors.join(', '));
            }

          } else {
            // âœ… SAUVEGARDE CLASSIQUE (pour finalizeClasses et autres)
            window.saveProgressManager.updateProgress(50, 'step2');
            await new Promise(resolve => setTimeout(resolve, 300));

            window.saveProgressManager.updateProgress(75, 'step3');

            // Utiliser le mode forcÃ© si fourni, sinon STATE.currentMode
            const modeToUse = forcedMode || STATE.currentMode;

            const result = await gsRun(saveFunctionName, disposition, modeToUse);

            if (!result || !result.success) {
              throw new Error(result?.message || 'Une erreur est survenue sur le serveur.');
            }

            window.saveProgressManager.updateProgress(100, 'step4');
            window.saveProgressManager.complete(true);
            toast(result.message || successMessage, 'success');
          }

        } catch (error) {
          console.error('Erreur lors de la sauvegarde avec progression:', error);
          toast(error.message, 'error');
          window.saveProgressManager.complete(false);
        } finally {
          // RÃ©activer le bouton
          if (buttonElement) buttonElement.disabled = false;
        }
      }

      // Expose globally for use elsewhere
      window.lancerSauvegardeAvecProgression = lancerSauvegardeAvecProgression;

      // ========== PHASE 2: EVENT LISTENERS - SPLIT INTO 6 FOCUSED FUNCTIONS ==========

      // 1. NAVIGATION CONTROLS (refresh, undo, redo, swap)
      function setupNavigationControls() {
        const btnRefresh = document.getElementById('btnRefresh');
        const btnUndo = document.getElementById('btnUndo');
        const btnRedo = document.getElementById('btnRedo');
        const btnSwapMain = document.getElementById('btnSwapMain');

        if (btnRefresh) btnRefresh.addEventListener('click', attemptRefresh);
        if (btnUndo) btnUndo.addEventListener('click', undo);
        if (btnRedo) btnRedo.addEventListener('click', redo);
        if (btnSwapMain) btnSwapMain.addEventListener('click', toggleSwapMode);
      }

      // 2. SAVE OPERATIONS (WIP, finalize)
      function setupSaveOperations() {
        const btnSaveWIP = document.getElementById('btnSaveWIP');

        if (btnSaveWIP) btnSaveWIP.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          lancerSauvegardeAvecProgression('saveCacheData', e.currentTarget, {
            title: 'Sauvegarde Brouillon (CACHE)...',
            successMessage: 'Brouillon sauvegardÃ© avec succÃ¨s !'
          });
        });
      }

      // 3. VIEW MODE CONTROLS (view selector, gender badges, white background)
      function setupViewModeControls() {
        const viewModeSelect = document.getElementById('viewModeSelect');
        const showGenderBadges = document.getElementById('showGenderBadges');
        const whiteBackground = document.getElementById('whiteBackground');

        // View mode selector
        if (viewModeSelect) {
          viewModeSelect.value = STATE.viewMode;

          viewModeSelect.addEventListener('change', (e) => {
            STATE.viewMode = e.target.value;
            localStorage.setItem('viewMode', STATE.viewMode);

            document.body.classList.remove('simple-view', 'essential-view');
            if (STATE.viewMode === 'simple') {
              document.body.classList.add('simple-view');
            } else if (STATE.viewMode === 'essential') {
              document.body.classList.add('essential-view');
            }

            // Recreate all cards for new view
            document.querySelectorAll('.droppable-zone').forEach(zone => {
              const ids = Array.from(zone.querySelectorAll('.student-card')).map(c => c.dataset.id);
              zone.innerHTML = '';
              ids.forEach(id => {
                const eleve = STATE.students[id];
                if (eleve) {
                  zone.appendChild(createStudentCard(eleve));
                }
              });
            });

            if (STATE.viewMode === 'simple') {
              setTimeout(() => {
                document.querySelectorAll('.droppable-zone').forEach(zone => {
                  adjustSimpleNamesFontSize(zone);
                });
              }, 50);
            }

            toast(`Mode ${e.target.options[e.target.selectedIndex].text}`, 'info');
          });

          // Apply initial body class
          if (STATE.viewMode === 'simple') {
            document.body.classList.add('simple-view');
          } else if (STATE.viewMode === 'essential') {
            document.body.classList.add('essential-view');
          }
        }

        // Micro Charts toggle (Nouveau Phase 6)
        const showMicroCharts = document.getElementById('showMicroCharts');
        if (showMicroCharts) {
          const microChartsEnabled = localStorage.getItem('showMicroCharts') === 'true';
          showMicroCharts.checked = microChartsEnabled;
          if (microChartsEnabled) {
            document.body.classList.add('show-micro-charts');
          }

          showMicroCharts.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            localStorage.setItem('showMicroCharts', isChecked);

            if (isChecked) {
              document.body.classList.add('show-micro-charts');
              if (window.showToast) window.showToast('Jauges visuelles activÃ©es', 'success');
            } else {
              document.body.classList.remove('show-micro-charts');
              if (window.showToast) window.showToast('Jauges visuelles dÃ©sactivÃ©es', 'info');
            }

            // Re-render UI to apply card changes
            if (window.STATE && window.STATE.classes) {
              App.UI.renderAllClasses(window.STATE.classes);
            }
          });
        }

        // Gender badges toggle
        if (showGenderBadges) {
          const genderBadgesEnabled = localStorage.getItem('showGenderBadges') === 'true';
          showGenderBadges.checked = genderBadgesEnabled;
          if (genderBadgesEnabled) {
            document.body.classList.add('gender-badges');
          }

          showGenderBadges.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            localStorage.setItem('showGenderBadges', isChecked);

            if (isChecked) {
              document.body.classList.add('gender-badges');
              if (window.showToast) window.showToast('Badges sexe activÃ©s', 'success');
            } else {
              document.body.classList.remove('gender-badges');
              if (window.showToast) window.showToast('Badges sexe dÃ©sactivÃ©s', 'info');
            }
          });
        }

        // White background toggle
        if (whiteBackground) {
          const whiteBgEnabled = localStorage.getItem('whiteBackground') === 'true';
          whiteBackground.checked = whiteBgEnabled;
          if (whiteBgEnabled) {
            document.body.classList.add('white-bg');
          }

          whiteBackground.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            localStorage.setItem('whiteBackground', isChecked);

            if (isChecked) {
              document.body.classList.add('white-bg');
              toast('Fond blanc activÃ©', 'success');
            } else {
              document.body.classList.remove('white-bg');
              toast('Fond blanc dÃ©sactivÃ©', 'info');
            }
          });
        }
      }

      // 4. ACTION BUTTONS (stats, export, rules, dark mode, zoom, help)
      function setupActionButtons() {
        const btnStats = document.getElementById('btnStats');
        const btnExport = document.getElementById('btnExport');
        const btnEditRules = document.getElementById('btnEditRules');
        const btnDarkMode = document.getElementById('btnDarkMode');
        const btnZoom = document.getElementById('btnZoom');
        const btnHelp = document.getElementById('btnHelp');

        if (btnStats) btnStats.addEventListener('click', () => {
          const panel = document.getElementById('statsPanel');

          requestAnimationFrame(() => {
            const panelWidth = 600;
            document.documentElement.style.setProperty('--stats-width', panelWidth + 'px');

            document.body.classList.add('stats-open');

            setTimeout(() => {
              panel.classList.remove('translate-x-full');
              btnStats.setAttribute('aria-expanded', 'true');

              if (!chartCommunication || !chartDistribution || !chartLV2 || !chartOptions) {
                if (typeof initCharts === 'function') {
                  initCharts();
                }
              }

              updateCharts();
            }, 50);
          });
        });

        if (btnExport) btnExport.addEventListener('click', () => {
          document.getElementById('exportModal').classList.remove('hidden');
          document.getElementById('overlay').classList.remove('hidden');
          document.getElementById('overlay').classList.add('active');
        });

        if (btnEditRules) btnEditRules.addEventListener('click', openRulesModal);
        if (btnDarkMode) btnDarkMode.addEventListener('click', toggleDarkMode);
        if (btnZoom) btnZoom.addEventListener('click', toggleZoom);
        if (btnHelp) btnHelp.addEventListener('click', toggleKeyboardHelp);
      }

      // 5. PANEL CONTROLS (close, fullscreen, anchor, resize)
      function setupPanelControls() {
        const closeStats = document.getElementById('closeStats');
        const btnFullscreen = document.getElementById('btnFullscreen');
        const btnAnchor = document.getElementById('btnAnchor');
        const statsPanel = document.getElementById('statsPanel');

        if (closeStats) closeStats.addEventListener('click', () => {
          closeStatsPanel();
          const btnStats = document.getElementById('btnStats');
          if (btnStats) btnStats.setAttribute('aria-expanded', 'false');
        });

        if (btnFullscreen) btnFullscreen.addEventListener('click', toggleFullscreenStats);
        if (btnAnchor) btnAnchor.addEventListener('click', toggleAnchoredStats);
        if (statsPanel) makeResizable(statsPanel);
      }

      // 6. SEARCH FEATURE
      function setupSearchFeature() {
        setupSearch();
      }

      // ========== MAIN EVENT LISTENERS SETUP (calls all 6 functions) ==========
      function setupEventListeners() {
        setupNavigationControls();
        setupSaveOperations();
        setupViewModeControls();
        setupActionButtons();
        setupPanelControls();
        setupSearchFeature();
      }

      // ========== PANEL REDIMENSIONNABLE ==========
      function makeResizable(element) {
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        const handle = document.createElement('div');
        handle.style.cssText = `
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: ew-resize;
      background: transparent;
    `;

        element.appendChild(handle);

        handle.addEventListener('mousedown', (e) => {
          isResizing = true;
          startX = e.clientX;
          startWidth = element.offsetWidth;
          document.body.style.cursor = 'ew-resize';
        });

        document.addEventListener('mousemove', (e) => {
          if (!isResizing) return;

          const diff = startX - e.clientX;
          const newWidth = Math.min(Math.max(400, startWidth + diff), window.innerWidth * 0.8);
          element.style.width = newWidth + 'px';

          // Mettre Ã  jour la variable CSS pour adapter la grille
          if (document.body.classList.contains('stats-open')) {
            document.documentElement.style.setProperty('--stats-width', newWidth + 'px');
          }
        });

        document.addEventListener('mouseup', () => {
          isResizing = false;
          document.body.style.cursor = '';
        });
      }


      // ========== FONCTION D'INITIALISATION UNIVERSELLE ==========
      async function initRepartitionApp() {
        let mode = localStorage.getItem('mode-selection');

        if (!mode) {
          openStartupModal();
          return;
        }

        STATE.currentMode = mode;
        showModeBadge(mode);

        // ArrÃªter les anciennes sauvegardes automatiques pour Ãªtre propre
        if (typeof stopAutoSave === 'function') stopAutoSave();
        if (typeof stopCacheAutoSave === 'function') stopCacheAutoSave();

        const ok = await loadDataForMode(mode);
        if (!ok) {
          showErrorState('Aucune donnÃ©e trouvÃ©e pour le mode ' + mode);
          return;
        }

        // DÃ©marrer la sauvegarde automatique dans le navigateur (uniquement si chargement rÃ©ussi)
        if (typeof startAutoSave === 'function') {
          startAutoSave();
        }
      }

      // Fonction pour ouvrir l'optimisation avec mot de passe
      function openOptimizationWithPassword() {
        const password = prompt('ğŸ” Entrez le mot de passe pour accÃ©der Ã  l\'optimisation automatique :');

        if (password === null) {
          // Utilisateur a annulÃ©
          return;
        }

        if (password === CONFIG.adminPassword) {
          // Mot de passe correct
          if (typeof OptimizationPanel !== 'undefined') {
            OptimizationPanel.open();
          } else {
            console.error('OptimizationPanel non disponible');
            toast('âŒ Module d\'optimisation non chargÃ©', 'error');
          }
        } else {
          // Mot de passe incorrect
          toast('âŒ Mot de passe incorrect', 'error');
        }
      }

      // Attacher les fonctions globales Ã  window
      window.initRepartitionApp = initRepartitionApp;
      window.openStartupModal = openStartupModal;
      window.openOptimizationWithPassword = openOptimizationWithPassword;
      window.restoreCache = restoreCache;
      window.checkCache = checkCache;
      window.showModeBadge = showModeBadge;
      window.stopAutoSave = stopAutoSave;
      window.startAutoSave = startAutoSave;
      window.showErrorState = showErrorState;
      window.setupEventListeners = setupEventListeners;
      window.setupKeyboardShortcuts = setupKeyboardShortcuts;
      window.updateAllColumnStats = updateAllColumnStats;
      window.updateAdvancedStats = updateAdvancedStats;
      window.toast = toast;
      window.showToast = toast; // Alias utilisÃ© par HeaderControls et toggles RÃ©gler
      window.undo = undo;
      window.redo = redo;
      window.gsRun = gsRun;

      // =======================================================
      // 3. DÃ‰MARRAGE FINAL
      // =======================================================

      // --- Event listeners pour le modal de dÃ©marrage ---
      const modal = document.getElementById('startupModal');
      const badge = document.getElementById('modeBadge');
      const closeBtn = document.getElementById('closeStartupModal');
      const btnRestore = document.getElementById('btnRestoreCache');

      if (closeBtn) {
        closeBtn.addEventListener('click', () => modal.classList.add('hidden'));
      }

      if (badge) {
        badge.addEventListener('dblclick', () => openStartupModal({ force: true }));
      }

      if (modal) {
        modal.querySelectorAll('button[data-mode]').forEach((btn) => {
          btn.addEventListener('click', async e => {
            const mode = e.currentTarget.dataset.mode;

            if (mode === 'SOURCES') {
              alert('Base Pronote non implÃ©mentÃ©e. Cette fonctionnalitÃ© sera disponible prochainement.');
              return;
            }

            // ProtÃ©ger PREVIOUS et FIN avec mot de passe admin
            if ((mode === 'PREVIOUS' || mode === 'FIN') && !STATE.adminMode) {
              const password = prompt('Veuillez entrer le mot de passe administrateur :', '');
              if (password === null) return;

              try {
                const result = await gsRun('verifierMotDePasseAdmin', password);
                if (!result || !result.success) {
                  alert('Mot de passe incorrect.');
                  return;
                }
                STATE.adminMode = true;
              } catch (err) {
                console.error('Erreur vÃ©rification mot de passe:', err);
                alert('Erreur lors de la vÃ©rification du mot de passe.');
                return;
              }
            }

            localStorage.setItem('mode-selection', mode);
            modal.classList.add('hidden');
            initRepartitionApp();
          });
        });
      }

      if (btnRestore) {
        btnRestore.addEventListener('click', () => {
          restoreCache();
          modal.classList.add('hidden');
        });
      }

      // Branche les Ã©couteurs d'Ã©vÃ©nements principaux
      setupEventListeners();
      setupKeyboardShortcuts();

      // ========== NOUVELLES FONCTIONNALITÃ‰S ==========

      let focusedColumn = null;

      // Fonction d'export image
      window.exportAsImage = async function () {
        toast('GÃ©nÃ©ration de l\'image en cours...', 'info');

        try {
          const board = document.getElementById('board');
          const originalStyle = board.style.cssText;

          board.style.width = '1920px';
          board.style.padding = '20px';
          board.style.background = '#ffffff';

          await new Promise(resolve => setTimeout(resolve, 500));

          const canvas = await html2canvas(board, {
            backgroundColor: '#ffffff',
            scale: 2,
            logging: false,
            useCORS: true,
            width: 1920,
            height: board.scrollHeight
          });

          board.style.cssText = originalStyle;

          const link = document.createElement('a');
          const niveau = STATE.niveau?.replace('Â°', 'e') || 'classes';
          link.download = `repartition_${niveau}_${new Date().toISOString().split('T')[0]}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();

          toast('Image exportÃ©e avec succÃ¨s', 'success');
        } catch (error) {
          console.error('Erreur export image:', error);
          toast('Erreur lors de l\'export de l\'image', 'error');
        }
      };

      function addToHistory(action) {
        action.timestamp = new Date().toISOString();
        if (action.eleveId) {
          const eleve = STATE.students[action.eleveId];
          action.eleveName = eleve ? `${eleve.nom} ${eleve.prenom || ''}` : 'Inconnu';
        }
        if (!STATE.historyTimeline) STATE.historyTimeline = [];
        STATE.historyTimeline.push(action);
        updateHistoryPanel();
      }

      window.toggleHistoryPanel = function () {
        const panel = document.getElementById('historyPanel');
        panel.classList.toggle('open');
      };

      function revertToPoint(index) {
        if (confirm(`Revenir Ã  cet Ã©tat ? (${STATE.history.length - index - 1} actions seront annulÃ©es)`)) {
          while (STATE.history.length > index + 1) {
            undo();
          }
          updateHistoryPanel();
        }
      }

      // Mode focus
      function enableFocusMode() {
        document.querySelectorAll('.class-column').forEach(column => {
          column.addEventListener('dblclick', () => {
            focusOnClass(column);
          });
        });
      }

      function focusOnClass(column) {
        if (focusedColumn) return;

        focusedColumn = column;

        const overlay = document.createElement('div');
        overlay.className = 'focus-overlay';
        document.body.appendChild(overlay);

        const hint = document.createElement('div');
        hint.className = 'exit-focus-hint';
        hint.innerHTML = 'Appuyez sur ESC pour sortir';
        document.body.appendChild(hint);

        column.classList.add('focused-column');
        document.body.style.overflow = 'hidden';

        function exitFocus(e) {
          if (e.key === 'Escape') {
            column.classList.remove('focused-column');
            overlay.remove();
            hint.remove();
            document.body.style.overflow = '';
            focusedColumn = null;
            document.removeEventListener('keydown', exitFocus);
          }
        }

        document.addEventListener('keydown', exitFocus);

        overlay.onclick = () => {
          const event = new KeyboardEvent('keydown', { key: 'Escape' });
          document.dispatchEvent(event);
        };
      }

      // SystÃ¨me de bookmarks
      window.toggleBookmarksMenu = function () {
        const menu = document.getElementById('bookmarksMenu');
        menu.classList.toggle('open');
        updateBookmarksMenu();
      };

      window.saveAsBookmark = function () {
        const name = prompt('Nom du favori :');
        if (!name) return;

        const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
        bookmarks[name] = {
          date: new Date().toISOString(),
          disposition: exportDisposition(),
          mode: STATE.currentMode,
          stats: {
            total: Object.keys(STATE.students).length,
            classes: document.querySelectorAll('.class-column').length,
            niveau: STATE.niveau
          }
        };

        localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));
        updateBookmarksMenu();
        toast(`Favori "${name}" sauvegardÃ©`, 'success');
      };

      window.loadBookmark = function (name) {
        const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
        const bookmark = bookmarks[name];

        if (!bookmark) return;

        if (!confirm(`Charger le favori "${name}" ? Cela remplacera la disposition actuelle.`)) {
          return;
        }

        Object.entries(bookmark.disposition).forEach(([classe, ids]) => {
          const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
          if (!zone) return;

          zone.innerHTML = '';

          ids.forEach(id => {
            const card = document.querySelector(`.student-card[data-id="${id}"]`);
            if (card) zone.appendChild(card);
          });
        });

        updateAllColumnStats();
        toast(`Favori "${name}" chargÃ©`, 'success');
      };

      window.deleteBookmark = function (name) {
        if (!confirm(`Supprimer le favori "${name}" ?`)) return;

        const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
        delete bookmarks[name];
        localStorage.setItem('repartition-bookmarks', JSON.stringify(bookmarks));

        updateBookmarksMenu();
        toast(`Favori "${name}" supprimÃ©`, 'info');
      };

      function updateBookmarksMenu() {
        const container = document.getElementById('bookmarksList');
        if (!container) return;

        const bookmarks = JSON.parse(localStorage.getItem('repartition-bookmarks') || '{}');
        container.innerHTML = '';

        if (Object.keys(bookmarks).length === 0) {
          container.innerHTML = '<div class="p-4 text-center text-gray-500">Aucun favori enregistrÃ©</div>';
          return;
        }

        Object.entries(bookmarks).forEach(([name, data]) => {
          const item = document.createElement('div');
          item.className = 'bookmark-item';
          item.innerHTML = `
        <div class="bookmark-name">${name}</div>
        <div class="bookmark-meta">
          SauvegardÃ© le ${new Date(data.date).toLocaleDateString('fr-FR')}
          - ${data.stats.total} Ã©lÃ¨ves
        </div>
        <div class="bookmark-actions">
          <button class="btn btn-sm btn-primary" onclick="loadBookmark('${name}')">
            <i class="fas fa-download"></i> Charger
          </button>
          <button class="btn btn-sm btn-secondary" onclick="deleteBookmark('${name}')">
            <i class="fas fa-trash"></i>
          </button>
        </div>
      `;
          container.appendChild(item);
        });
      }

      // Initialiser les nouvelles fonctionnalitÃ©s
      enableFocusMode();
      updateHistoryPanel();

      // Fermer les menus au clic externe
      document.addEventListener('click', (e) => {
        if (!e.target.closest('#btnBookmarks') && !e.target.closest('#bookmarksMenu')) {
          document.getElementById('bookmarksMenu')?.classList.remove('open');
        }
      });

      // Ajouter les event listeners pour les nouveaux boutons
      const btnHistory = document.getElementById('btnHistory');
      const btnBookmarks = document.getElementById('btnBookmarks');

      if (btnHistory) btnHistory.addEventListener('click', toggleHistoryPanel);
      if (btnBookmarks) btnBookmarks.addEventListener('click', toggleBookmarksMenu);

      // Initialiser les filtres
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => applyQuickFilter(btn.dataset.filter));
      });

      // CORRECTION : TOUJOURS afficher le modal au dÃ©marrage
      // L'utilisateur doit pouvoir choisir Ã  chaque fois
      initializeBridge();

      // Gestion des menus dÃ©roulants fixes au clic
      (function () {
        function setupDropdown(wrapperId, btnId, dropdownId) {
          const wrapper = document.getElementById(wrapperId);
          const btn = document.getElementById(btnId);
          const dropdown = document.getElementById(dropdownId);
          if (!wrapper || !btn || !dropdown) return;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            // Fermer tous les autres dropdowns
            document.querySelectorAll('.app-header .absolute').forEach(d => {
              if (d !== dropdown) {
                d.classList.add('hidden');
                d.setAttribute('aria-hidden', 'true');
                // Trouver le bouton associÃ© et mettre Ã  jour aria-expanded
                const otherBtns = document.querySelectorAll('[aria-haspopup="menu"]');
                otherBtns.forEach(otherBtn => {
                  if (otherBtn.nextElementSibling === d || (otherBtn.parentElement && otherBtn.parentElement.contains(d))) {
                    otherBtn.setAttribute('aria-expanded', 'false');
                  }
                });
              }
            });
            const isHidden = dropdown.classList.toggle('hidden');
            // Mettre Ã  jour les attributs ARIA
            btn.setAttribute('aria-expanded', !isHidden);
            dropdown.setAttribute('aria-hidden', isHidden);
          });
          // EmpÃªcher la fermeture si on clique dans le menu
          dropdown.addEventListener('click', e => e.stopPropagation());
        }
        setupDropdown('settingsMenuWrapper', 'btnSettings', 'settingsDropdown');

        // Mapper les nouveaux boutons du menu ParamÃ¨tres aux fonctions existantes
        const settingsDropdown = document.getElementById('settingsDropdown');
        if (settingsDropdown) {
          // Section Affichage
          const menuDarkMode = document.getElementById('menuDarkMode');
          if (menuDarkMode) {
            menuDarkMode.addEventListener('click', () => {
              toggleDarkMode();
              settingsDropdown.classList.add('hidden');
            });
          }

          const menuZoom = document.getElementById('menuZoom');
          if (menuZoom) {
            menuZoom.addEventListener('click', () => {
              toggleZoom();
              settingsDropdown.classList.add('hidden');
            });
          }

          const menuFullscreen = document.getElementById('menuFullscreen');
          if (menuFullscreen) {
            menuFullscreen.addEventListener('click', () => {
              if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
              } else {
                document.exitFullscreen();
              }
              settingsDropdown.classList.add('hidden');
            });
          }

          // Section Actions - Annuler/Refaire dÃ©jÃ  gÃ©rÃ©s par leurs ID existants (btnUndo, btnRedo)
          // Boutons Favoris, Optimiser, Contraintes, Filtres supprimÃ©s (non fonctionnels)

          // Section DonnÃ©es
          const menuImportScores = document.getElementById('menuImportScores');
          const btnImportScores = document.getElementById('btnImportScores');
          if (menuImportScores && btnImportScores) {
            menuImportScores.addEventListener('click', () => {
              btnImportScores.click();
              settingsDropdown.classList.add('hidden');
            });
          }

          const menuRules = document.getElementById('menuRules');
          const btnEditRules = document.getElementById('btnEditRules');
          if (menuRules && btnEditRules) {
            menuRules.addEventListener('click', () => {
              btnEditRules.click();
              settingsDropdown.classList.add('hidden');
            });
          }

          // Section Filtres
          const filterBtnsCompact = settingsDropdown.querySelectorAll('.filter-btn-compact');
          filterBtnsCompact.forEach(btn => {
            btn.addEventListener('click', () => {
              const filter = btn.dataset.filter;
              // Retirer la classe active de tous les boutons
              filterBtnsCompact.forEach(b => b.classList.remove('active'));
              // Ajouter la classe active au bouton cliquÃ©
              btn.classList.add('active');
              // Appliquer le filtre en utilisant la fonction existante
              applyQuickFilter(filter);
              // Fermer le menu
              settingsDropdown.classList.add('hidden');
            });
          });

          // Section Aide - btnHelp et btnTutorial dÃ©jÃ  gÃ©rÃ©s par leurs ID existants
        }

        // Fermer tous les menus au clic extÃ©rieur
        document.addEventListener('click', () => {
          document.querySelectorAll('.app-header .absolute').forEach(d => {
            d.classList.add('hidden');
            d.setAttribute('aria-hidden', 'true');
          });
          // Mettre Ã  jour aria-expanded pour tous les boutons de menu
          document.querySelectorAll('[aria-haspopup="menu"]').forEach(btn => {
            btn.setAttribute('aria-expanded', 'false');
          });
        });
      })();

    }); // Fin du DOMContentLoaded

    // =======================================================
    // FONCTIONS GLOBALES SUPPLEMENTAIRES
    // =======================================================

    // ========== FONCTIONS POUR LES NOUVELLES MÃ‰TRIQUES ==========
    function updateNewMetrics() {
      // VÃ©rifier que les mÃ©triques sont prÃªtes dans le DOM
      const metricsReady = document.getElementById('totalStudentsMetric');
      if (!metricsReady) return; // panneau pas encore injectÃ©


      // Total Ã©lÃ¨ves (uniquement dans les vraies classes)
      let totalStudents = 0;
      let filles = 0;
      let totalClasses = 0;

      document.querySelectorAll('.class-column').forEach(column => {
        const className = column.querySelector('.classe-name').textContent;
        if (!isRealClass(className)) return;

        totalClasses++;
        column.querySelectorAll('.student-card').forEach(card => {
          const student = STATE.students[card.dataset.id];
          if (student) {
            totalStudents++;
            if (student.sexe === 'F') filles++;
          }
        });
      });


      const totalElement = document.getElementById('totalStudentsMetric');
      if (totalElement) {
        totalElement.textContent = totalStudents;
      } else {
        console.warn('â“ mÃ©trique manquante dans le DOM : totalStudentsMetric');
      }

      // Ratio filles
      const ratio = totalStudents > 0 ? Math.round((filles / totalStudents) * 100) : 0;
      const ratioElement = document.getElementById('genderBalanceMetric');
      if (ratioElement) {
        ratioElement.textContent = `${ratio}% F`;
      } else {
        console.warn('â“ mÃ©trique manquante dans le DOM : genderBalanceMetric');
      }

      // Moyenne par classe
      const avgClass = totalClasses > 0 ? Math.round(totalStudents / totalClasses) : 0;
      const avgElement = document.getElementById('avgClassSizeMetric');
      if (avgElement) {
        avgElement.textContent = avgClass;
      } else {
        console.warn('â“ mÃ©trique manquante dans le DOM : avgClassSizeMetric');
      }

      // Score de conformitÃ©
      const conformityElement = document.getElementById('conformityScoreMetric');
      if (conformityElement) {
        conformityElement.textContent = 'âœ… OK';
      } else {
        console.warn('â“ mÃ©trique manquante dans le DOM : conformityScoreMetric');
      }

    }

    function updateLV2Details() {
      if (!window.chartLV2Details) return;

      const classes = Array.from(document.querySelectorAll('.class-column')).map(col =>
        col.querySelector('.classe-name').textContent
      ).sort();

      const lv2Types = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
      const colors = ['#dc2626', '#059669', '#2563eb', '#7c3aed', '#d97706'];

      window.chartLV2Details.data.labels = classes;
      window.chartLV2Details.data.datasets = lv2Types.map((lv2, index) => ({
        label: lv2,
        data: classes.map(classe => {
          const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
          if (!zone) return 0;
          return Array.from(zone.querySelectorAll('.student-card')).filter(card => {
            const eleve = STATE.students[card.dataset.id];
            return eleve && eleve.lv2 && eleve.lv2.toUpperCase() === lv2;
          }).length;
        }),
        backgroundColor: colors[index],
        stack: 'Stack 0'
      }));

      window.chartLV2Details.update();
    }

    function updateConformityGrid() {
      const grid = document.getElementById('conformityGrid');
      if (!grid) return;

      const classes = Array.from(document.querySelectorAll('.class-column')).map(col =>
        col.querySelector('.classe-name').textContent
      ).sort();

      let html = '';
      classes.forEach(classe => {
        const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
        if (!zone) return;

        const cards = Array.from(zone.querySelectorAll('.student-card'));
        const total = cards.length;
        const filles = cards.filter(card => {
          const eleve = STATE.students[card.dataset.id];
          return eleve && eleve.sexe === 'F';
        }).length;

        const ratio = total > 0 ? Math.round((filles / total) * 100) : 0;
        let status = 'conformity-undefined';
        let text = '?';

        if (ratio >= 40 && ratio <= 60) {
          status = 'conformity-ok';
          text = 'OK';
        } else if (ratio >= 30 && ratio <= 70) {
          status = 'conformity-warning';
          text = '!';
        } else {
          status = 'conformity-error';
          text = 'âœ—';
        }

        html += `<div class="conformity-cell ${status}" title="${classe}: ${ratio}% filles">${text}</div>`;
      });

      grid.innerHTML = html;
    }

    function updateBalanceIndicators() {
      const container = document.getElementById('balanceIndicators');
      if (!container) return;

      const suggestions = [];

      // Analyser l'Ã©quilibre des sexes
      document.querySelectorAll('.class-column').forEach(column => {
        const classe = column.querySelector('.classe-name').textContent;
        const cards = Array.from(column.querySelectorAll('.student-card'));
        const total = cards.length;
        const filles = cards.filter(card => {
          const eleve = STATE.students[card.dataset.id];
          return eleve && eleve.sexe === 'F';
        }).length;

        const ratio = total > 0 ? Math.round((filles / total) * 100) : 0;

        if (ratio < 30) {
          suggestions.push({
            type: 'warning',
            message: `${classe}: Trop peu de filles (${ratio}%)`,
            icon: 'fa-exclamation-triangle'
          });
        } else if (ratio > 70) {
          suggestions.push({
            type: 'warning',
            message: `${classe}: Trop peu de garÃ§ons (${100 - ratio}%)`,
            icon: 'fa-exclamation-triangle'
          });
        }
      });

      if (suggestions.length === 0) {
        suggestions.push({
          type: 'success',
          message: 'Ã‰quilibre des sexes satisfaisant',
          icon: 'fa-check-circle'
        });
      }

      const html = suggestions.map(s => `
    <div class="indicator-card indicator-${s.type === 'success' ? 'good' : 'warning'}">
      <i class="fas ${s.icon} mr-2"></i>
      ${s.message}
    </div>
  `).join('');

      container.innerHTML = html;
    }

    // --- Responsive : recalculer Ã  chaque resize de la fenÃªtre (avec debounce) ---
    let resizeTimeout = null;
    window.addEventListener('resize', () => {
      if (STATE.viewMode !== 'simple') return;
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        document.querySelectorAll('.droppable-zone').forEach(zone => adjustSimpleNamesFontSize(zone));
      }, 100);
    });


    // FONCTIONS MANQUANTES - Ã€ ajouter dans le script principal

    // 1. Gestion du mode sombre depuis localStorage
    function initDarkMode() {
      try {
        const saved = (typeof localStorage !== 'undefined')
          ? localStorage.getItem('darkMode')
          : null;
        const isDark = saved === 'true';
        STATE.darkMode = !!isDark;
        document.body.classList.toggle('dark-mode', STATE.darkMode);
      } catch (e) {
        console.warn('Could not access localStorage for dark mode.', e);
      }
    }

    // API dÃ©terministe pour activer/dÃ©sactiver le mode sombre
    function setDarkMode(on) {
      if (!!on === !!STATE.darkMode) return; // dÃ©jÃ  dans le bon Ã©tat
      toggleDarkMode();
    }

    // 2. Tutoriel interactif AMÃ‰LIORÃ‰
    function showTutorial() {
      if (window.OnboardingTour && typeof window.OnboardingTour.start === 'function') {
        window.OnboardingTour.start();
      } else {
        console.error('Tutoriel indisponible (Shepherd non charge)');
        if (typeof window.toast === 'function') {
          toast("Le tutoriel n'a pas pu se lancer.", 'error');
        } else {
          alert("Le tutoriel n'a pas pu se lancer.");
        }
      }
    }


    // 3. Actualisation intelligente (dÃ©jÃ  prÃ©sente mais toast amÃ©liorÃ©)
    window.attemptRefresh = async function () {
      showSpinner();
      try {
        const currentMode = localStorage.getItem('mode-selection') || 'TEST';
        const success = await loadDataForMode(currentMode);
        if (success) {
          toast('DonnÃ©es actualisÃ©es avec succÃ¨s', 'success');
        } else {
          toast('Ã‰chec de l\'actualisation', 'error');
        }
      } catch (error) {
        console.error('Erreur actualisation:', error);
        toast('Erreur lors de l\'actualisation', 'error');
      } finally {
        hideSpinner();
      }
    }

    // 4. AmÃ©lioration de la fonction de recherche
    function enhanceSearch() {
      const searchInput = document.getElementById('search');
      let searchTimeout;
      if (!searchInput) return;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const term = e.target.value.toLowerCase().trim();
          STATE.searchTerm = term;
          let matchCount = 0;
          document.querySelectorAll('.student-card').forEach(card => {
            const nameEl = card.querySelector('.student-fullname, .student-simple-name');
            if (!nameEl) return;
            const fullName = nameEl.textContent.toLowerCase();
            const eleve = STATE.students[card.dataset.id];
            const searchText = [fullName, eleve?.lv2?.toLowerCase() || '', eleve?.opt?.toLowerCase() || '', eleve?.mobilite?.toLowerCase() || ''].join(' ');
            const match = !term || searchText.includes(term);
            card.style.display = match ? '' : 'none';
            card.classList.toggle('search-highlight', match && term);
            if (match) matchCount++;
          });
          if (term) {
            toast(`${matchCount} Ã©lÃ¨ve(s) trouvÃ©(s)`, 'info');
          }
        }, 300);
      });
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'f') {
          e.preventDefault();
          searchInput.focus();
          searchInput.select();
        }
      });
    }

    // 5. SystÃ¨me de notifications persistantes
    function createNotificationSystem() {
      if (!document.getElementById('notificationContainer')) {
        const container = document.createElement('div');
        container.id = 'notificationContainer';
        container.className = 'fixed top-20 right-4 z-50 space-y-2 max-w-sm';
        document.body.appendChild(container);
      }
    }
    function showPersistentNotification(message, type = 'info', duration = 5000) {
      createNotificationSystem();
      const container = document.getElementById('notificationContainer');
      const notification = document.createElement('div');
      const bgColors = { success: 'bg-green-500', error: 'bg-red-500', warning: 'bg-yellow-500', info: 'bg-blue-500' };
      const icons = { success: 'fa-check-circle', error: 'fa-exclamation-circle', warning: 'fa-exclamation-triangle', info: 'fa-info-circle' };
      notification.className = `${bgColors[type]} text-white p-3 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 flex items-center gap-2`;
      notification.innerHTML = `<i class="fas ${icons[type]}"></i><span class="flex-1">${message}</span><button onclick="this.parentElement.remove()" class="text-white hover:text-gray-200"><i class="fas fa-times"></i></button>`;
      container.appendChild(notification);
      setTimeout(() => { notification.classList.remove('translate-x-full'); }, 100);
      if (duration > 0) {
        setTimeout(() => { notification.classList.add('translate-x-full'); setTimeout(() => notification.remove(), 300); }, duration);
      }
    }

    // 6. AmÃ©lioration du systÃ¨me d'aide
    function createContextualHelp() {
      const helpButton = document.getElementById('btnTutorial');
      if (helpButton) {
        helpButton.addEventListener('click', () => {
          // Ne plus marquer comme vu au clic, seulement Ã  la fin du tutoriel
          showTutorial();
        });
      }
    }

    // 7. Gestion des prÃ©fÃ©rences utilisateur
    function saveUserPreferences() {
      const preferences = {
        viewMode: STATE.viewMode,
        darkMode: STATE.darkMode,
        lastFilter: activeFilter || 'all'
      };
      localStorage.setItem('userPreferences', JSON.stringify(preferences));
    }
    function loadUserPreferences() {
      try {
        const saved = localStorage.getItem('userPreferences');
        if (saved) {
          const prefs = JSON.parse(saved);
          // GÃ©rer l'ancienne propriÃ©tÃ© simpleView pour la compatibilitÃ©
          if (prefs.simpleView !== undefined && prefs.viewMode === undefined) {
            STATE.viewMode = prefs.simpleView ? 'simple' : 'complete';
            localStorage.setItem('viewMode', STATE.viewMode);
          }
          // Mode sombre dÃ©sactivÃ© par dÃ©faut Ã  chaque session
          delete prefs.darkMode;

          if (prefs.lastFilter && prefs.lastFilter !== 'all') { setTimeout(() => applyQuickFilter(prefs.lastFilter), 1000); }
        }
      } catch (e) { console.warn('Erreur chargement prÃ©fÃ©rences:', e); }
    }

    // 8. Fonction d'initialisation globale amÃ©liorÃ©e
    function initializeEnhancements() {
      loadUserPreferences();
      enhanceSearch();
      createContextualHelp();
      createNotificationSystem();
      window.addEventListener('beforeunload', saveUserPreferences);

    }
    // ... existing code ...
    // Ã€ la fin du DOMContentLoaded, aprÃ¨s setupEventListeners() et openStartupModal();
    initializeEnhancements();
    // ... existing code ...

    // ========== PANNEAU HISTORIQUE (TIMELINE) ==========

    if (!STATE.historyTimeline) STATE.historyTimeline = [];

    function updateHistoryPanel() {
      const container = document.getElementById('historyTimeline');
      if (!container) return;

      container.innerHTML = '';
      const timeline = STATE.historyTimeline || [];

      timeline.slice().reverse().forEach((action) => {
        const item = document.createElement('div');
        item.className = 'timeline-item';

        let actionText = '';
        let details = '';
        let icon = 'fa-question';
        let color = '#6b7280';

        switch (action.type) {
          case 'move':
            actionText = `DÃ©placement: ${action.eleveName || 'Ã‰lÃ¨ve'}`;
            details = `${action.oldClasse} â†’ ${action.newClasse}`;
            icon = 'fa-arrow-right';
            color = '#3b82f6';
            break;
          case 'swap':
            actionText = 'Ã‰change effectuÃ©';
            details = `${STATE.students[action.id1]?.nom || 'Ã‰lÃ¨ve 1'} â†” ${STATE.students[action.id2]?.nom || 'Ã‰lÃ¨ve 2'}`;
            icon = 'fa-exchange-alt';
            color = '#f59e0b';
            break;
        }

        item.innerHTML = `
      <div class="timeline-dot" style="background: ${color};"><i class="fas ${icon} text-xs"></i></div>
      <div class="timeline-content">
        <div class="timeline-time">${new Date(action.timestamp).toLocaleTimeString('fr-FR')}</div>
        <div class="timeline-action">${actionText}</div>
        <div class="timeline-details">${details}</div>
      </div>
    `;
        container.appendChild(item);
      });

      if (timeline.length === 0) {
        container.innerHTML = '<div class="text-center text-gray-500 p-4">Aucune action enregistrÃ©e</div>';
      }
    }

    window.updateHistoryPanel = updateHistoryPanel;



    // ========== STYLES INJECTÃ‰S (TIMELINE + ANIMATIONS) ==========
    const injectedStyles = document.createElement('style');
    injectedStyles.id = 'corescript-injected-styles';
    injectedStyles.textContent = `
  .timeline-item { position: relative; padding-left: 2.5rem; cursor: pointer; transition: all 0.2s; }
  .timeline-item:hover { background: #f8fafc; }
  .timeline-item::before { content: ''; position: absolute; left: 1.25rem; top: 2rem; bottom: -1rem; width: 2px; background: #e5e7eb; }
  .timeline-item:last-child::before { display: none; }
  .timeline-dot { position: absolute; left: 0.75rem; top: 0.75rem; width: 2rem; height: 2rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  .timeline-content { padding: 0.5rem 0; }
  .timeline-time { font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem; }
  .timeline-action { font-weight: 600; color: #1e293b; margin-bottom: 0.25rem; }
  .timeline-details { font-size: 0.875rem; color: #4b5563; }
  #statsPanel { transition: transform 0.3s cubic-bezier(0.4,0,0.2,1), opacity 0.3s ease; }
  #statsPanel.updating { opacity: 0.95; }
  .chart-container { transition: opacity 0.2s ease; }
  .stats-panel.updating .chart-container { opacity: 0.8; }
  .metric-value { transition: color 0.2s ease, transform 0.2s ease; }
  .metric-value.changed { transform: scale(1.05); }
  .student-card { transition: all 0.2s ease; will-change: transform; }
  .sortable-ghost { opacity: 0.5; transform: rotate(5deg); }
  .sortable-chosen { transform: scale(1.05); box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
  @keyframes gentlePulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.9; } }
  .stats-panel.updating, .stats-updating { animation: gentlePulse 0.6s ease-in-out; }
`;
    document.head.appendChild(injectedStyles);

    // ========== FILTRE RAPIDE ==========
    window.activeFilter = 'all';

    window.applyQuickFilter = function (filter) {
      window.activeFilter = filter;

      document.querySelectorAll('.filter-btn, .filter-btn-compact').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });

      let visibleCount = 0;
      document.querySelectorAll('.student-card').forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        if (!eleve) return;

        let match = false;
        switch (filter) {
          case 'all': match = true; break;
          case 'PERMUT': case 'FIXE': match = eleve.mobilite === filter; break;
          case 'ESP': case 'ITA': case 'ALL': match = eleve.lv2 === filter; break;
          case 'D': match = !!eleve.disso; break;
          case 'A': match = !!eleve.asso; break;
        }

        card.classList.toggle('filtered-out', !match);
        if (match) visibleCount++;
      });

      if (filter !== 'all') {
        toast(`${visibleCount} Ã©lÃ¨ve(s) avec filtre "${filter}"`, 'info');
      }
    };

    // ========== TOOLTIPS PERSONNALISÃ‰S ==========
    document.addEventListener('DOMContentLoaded', () => {
      // Ajouter des tooltips riches sur les badges
      document.addEventListener('mouseover', (e) => {
        if (e.target.classList.contains('mini-badge')) {
          const title = e.target.getAttribute('title');
          if (!title) return;

          // CrÃ©er un tooltip personnalisÃ© si nÃ©cessaire
          const existingTooltip = document.querySelector('.custom-tooltip');
          if (existingTooltip) existingTooltip.remove();

          const tooltip = document.createElement('div');
          tooltip.className = 'custom-tooltip';
          tooltip.textContent = title;
          tooltip.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.75rem;
        z-index: 9999;
        pointer-events: none;
        white-space: nowrap;
      `;

          const rect = e.target.getBoundingClientRect();
          tooltip.style.left = rect.left + 'px';
          tooltip.style.top = (rect.bottom + 5) + 'px';

          document.body.appendChild(tooltip);
        }
      });

      document.addEventListener('mouseout', (e) => {
        if (e.target.classList.contains('mini-badge')) {
          document.querySelector('.custom-tooltip')?.remove();
        }
      });
    });

    // ========== SAUVEGARDE IMMÃ‰DIATE CACHE ==========
    window.saveImmediateCache = async function () {
      try {
        // 1. Ne rien faire si l'utilisateur n'a rien bougÃ©
        if (!STATE.has_user_action) {
          console.debug('â­ï¸ Auto-save sautÃ© (aucune action)');
          return;
        }

        const disposition = exportDisposition();
        const cacheData = {
          date: new Date().toISOString(),
          disposition: disposition,
          mode: STATE.currentMode,
          filters: window.activeFilter,
          stats: {
            total: Object.keys(STATE.students).length,
            classes: document.querySelectorAll('.class-column').length
          }
        };

        // Sauvegarde locale avec compression
        localStorage.setItem('cache-data', JSON.stringify(cacheData));
        localStorage.setItem('cache-timestamp', new Date().toISOString());

        // Sauvegarde distante si disponible
        if (typeof gsRun === 'function') {
          try {
            const result = await gsRun('saveCacheData', cacheData);

            if (result && result.success) {

              // 2. AprÃ¨s succÃ¨s â†’ reset flag + horodatage + badge
              STATE.has_user_action = false;
              STATE.last_save_ts = Date.now();

              if (typeof updateSaveBadge === 'function') {
                updateSaveBadge(true);
              }

              // Indicateur visuel de sauvegarde
              const saveIndicator = document.createElement('div');
              saveIndicator.className = 'fixed top-20 right-4 bg-green-500 text-white px-3 py-1 rounded-full text-sm';
              saveIndicator.innerHTML = '<i class="fas fa-check mr-1"></i> SauvegardÃ©';
              document.body.appendChild(saveIndicator);

              setTimeout(() => saveIndicator.remove(), 2000);
            } else {
              console.warn('âš ï¸ Sauvegarde CACHE Ã©chouÃ©e');
              if (typeof updateSaveBadge === 'function') {
                updateSaveBadge(false);
              }
            }
          } catch (error) {
            console.error('âŒ Erreur sauvegarde CACHE:', error);
            if (typeof updateSaveBadge === 'function') {
              updateSaveBadge(false);
            }
          }
        }
      } catch (error) {
        console.error('Erreur sauvegarde cache:', error);
      }
    };

    // ========== INDICATEUR DE CONNEXION ==========
    function checkGoogleAppsConnection() {
      const indicator = document.createElement('div');
      indicator.className = 'fixed bottom-4 right-4 text-xs';

      if (typeof google !== 'undefined' && google.script) {
        indicator.innerHTML = '<i class="fas fa-cloud text-green-500"></i> ConnectÃ© Ã  Google';
      } else {
        indicator.innerHTML = '<i class="fas fa-cloud-slash text-gray-400"></i> Mode local';
      }

      document.body.appendChild(indicator);
      setTimeout(() => indicator.remove(), 3000);
    }

    // Appeler au chargement
    setTimeout(checkGoogleAppsConnection, 1000);

    // ========== TRI DES COLONNES ==========
    window.sortColumn = function (classe, sortType, direction = 'asc') {
      const dropZone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!dropZone) return;

      const cards = Array.from(dropZone.querySelectorAll('.student-card'));
      const students = cards.map(card => ({
        card,
        data: STATE.students[card.dataset.id]
      })).filter(item => item.data); // Filtrer les Ã©lÃ©ments invalides

      const f = direction === 'asc' ? 1 : -1;

      switch (sortType) {
        case 'name':
          students.sort((a, b) => {
            const nameA = `${a.data.nom} ${a.data.prenom || ''}`.trim();
            const nameB = `${b.data.nom} ${b.data.prenom || ''}`.trim();
            return f * nameA.localeCompare(nameB, 'fr');
          });
          break;

        case 'lv2':
          students.sort((a, b) => {
            const ordre = ['ESP', 'ITA', 'ALL', 'LATIN', 'GRECO'];
            const lv2A = (a.data.lv2 || '').toUpperCase();
            const lv2B = (b.data.lv2 || '').toUpperCase();
            const iA = ordre.indexOf(lv2A);
            const iB = ordre.indexOf(lv2B);
            return f * ((iA === -1 ? 999 : iA) - (iB === -1 ? 999 : iB));
          });
          break;

        case 'option':
          students.sort((a, b) => {
            const optA = a.data.opt || 'ZZZZ';
            const optB = b.data.opt || 'ZZZZ';
            return f * optA.localeCompare(optB);
          });
          break;

        case 'score':
          students.sort((a, b) => {
            const scoreA = a.data.scores?.COM || 0;
            const scoreB = b.data.scores?.COM || 0;
            // Pour les scores, inverser la logique (meilleurs en haut)
            return -f * (scoreB - scoreA);
          });
          break;
      }

      // RÃ©injecter dans le DOM avec animation
      dropZone.style.opacity = '0.5';
      dropZone.innerHTML = '';
      students.forEach(({ card }, index) => {
        setTimeout(() => {
          dropZone.appendChild(card);
          if (index === students.length - 1) {
            dropZone.style.opacity = '1';
          }
        }, index * 10);
      });

      STATE.sortOrder[classe] = { type: sortType, dir: direction };

      // Notification
      toast(`Classe ${classe} triÃ©e par ${sortType}`, 'info');
    };


    // ========== MODULE DE GROUPES V2 - INTERFACE CLARIFIÃ‰E ==========

    function addGroupsButton() {

      const nav = document.querySelector('.app-header nav');
      if (!nav || document.getElementById('btnGroups')) return;

      // CrÃ©er un wrapper pour le bouton et son menu
      const groupsWrapper = document.createElement('div');
      groupsWrapper.className = 'relative';
      groupsWrapper.id = 'groupsMenuWrapper';

      // Bouton principal avec flÃ¨che
      const btnGroups = document.createElement('button');
      btnGroups.id = 'btnGroups';
      btnGroups.className = 'btn btn-primary flex items-center gap-1';
      btnGroups.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';

      // Menu dÃ©roulant
      const dropdown = document.createElement('div');
      dropdown.id = 'groupsDropdown';
      dropdown.className = 'absolute right-0 mt-2 w-64 bg-white rounded shadow-lg z-50 hidden p-2';
      dropdown.innerHTML = `
    <div class="px-2 py-2 border-b border-gray-200 mb-2">
      <div class="text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">ParamÃ¨tres Groupes</div>
      <label class="flex items-center gap-2 text-sm cursor-pointer">
        <input type="checkbox" id="toggleHeaderGroups" onchange="toggleHeaderGroups(this.checked)">
        <span>Afficher le bouton Groupes dans le header</span>
      </label>
    </div>
    <button onclick="openGroupsInterface()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-plus-circle text-green-600"></i> CrÃ©er des groupes
    </button>
    <button onclick="openGroupsInterface('manager')" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-cog text-blue-600"></i> GÃ©rer les groupes
    </button>
    <button onclick="openGroupsInterface('templates')" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-layer-group text-purple-600"></i> ModÃ¨les de groupes
    </button>
    <hr class="my-2 border-gray-200">
    <button onclick="exportGroupsData()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2">
      <i class="fas fa-download text-purple-600"></i> Exporter tous les groupes
    </button>
    <button onclick="confirmDeleteAllGroups()" class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2 text-red-600">
      <i class="fas fa-trash"></i> Supprimer tous les groupes
    </button>
  `;

      groupsWrapper.appendChild(btnGroups);
      groupsWrapper.appendChild(dropdown);

      // GÃ©rer l'ouverture/fermeture du menu
      btnGroups.addEventListener('click', (e) => {
        e.stopPropagation();
        // Fermer tous les autres dropdowns
        document.querySelectorAll('.app-header .absolute').forEach(d => {
          if (d !== dropdown) d.classList.add('hidden');
        });
        dropdown.classList.toggle('hidden');
      });

      // Fermer le menu si on clique ailleurs
      document.addEventListener('click', () => {
        dropdown.classList.add('hidden');
      });

      dropdown.addEventListener('click', e => e.stopPropagation());

      // Placement idÃ©al: entre Brouillon (#btnSaveWIP) et Ã‰dition (#btnEdition)
      const btnBrouillon = document.getElementById('btnSaveWIP');
      const btnEdition = document.getElementById('btnEdition');
      if (btnBrouillon && btnBrouillon.parentElement) {
        btnBrouillon.insertAdjacentElement('afterend', groupsWrapper);
      } else if (btnEdition && btnEdition.parentElement) {
        btnEdition.parentElement.insertBefore(groupsWrapper, btnEdition);
      } else {
        nav.appendChild(groupsWrapper);
      }

      // Initialiser l'Ã©tat du toggle Ã  partir du serveur
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(function (settings) {
            const cb = document.getElementById('toggleHeaderGroups');
            if (cb && settings) cb.checked = !!settings.SHOW_GROUPS_BUTTON;
          })
          .withFailureHandler(function (err) { console.error('Erreur getUiSettings:', err); })
          .getUiSettings();
      }
    }

    // Retirer le bouton Groupes du header si prÃ©sent
    function removeGroupsButton() {
      const wrapper = document.getElementById('groupsMenuWrapper') || document.getElementById('btnGroups')?.parentElement;
      if (wrapper && wrapper.parentElement) {
        wrapper.parentElement.removeChild(wrapper);
      }
    }

    // Handler pour le toggle dans le menu Groupes
    function toggleHeaderGroups(checked) {
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(function () {
            if (checked) { addGroupsButton(); } else { removeGroupsButton(); }
            if (typeof toast === 'function') toast(checked ? 'Bouton Groupes activÃ©' : 'Bouton Groupes dÃ©sactivÃ©', 'success');
          })
          .withFailureHandler(function (err) {
            console.error('Erreur setUiSettings:', err);
            if (typeof toast === 'function') toast('Erreur: ' + err.message, 'error');
          })
          .setUiSettings({ SHOW_GROUPS_BUTTON: !!checked });
      }
    }

    // Mettre Ã  jour le bouton pour afficher le nombre de groupes - Version modulaire
    function updateGroupsButton() {
      const btn = document.getElementById('btnGroups');
      if (btn) {
        // RÃ©cupÃ©rer le nombre de groupes depuis le serveur
        google.script.run
          .withSuccessHandler(function (count) {
            if (count > 0) {
              btn.innerHTML = `<i class="fas fa-layer-group"></i> Groupes <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs ml-1">${count}</span> <i class="fas fa-caret-down"></i>`;
            } else {
              btn.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
            }
          })
          .getGroupsCount();
      }
    }

    // Fonction pour notifier les changements de groupes
    function notifyGroupsChanged() {
      updateGroupsButton();
      // Autres actions Ã  effectuer quand les groupes changent
    }

    // ========== CODE Ã€ AJOUTER/MODIFIER DANS INTERFACEV2.HTML ==========

    // 1. Fonction unifiÃ©e openGroupsInterface - utilise le nouveau GroupsModuleComplete (modal intÃ©grÃ©e)
    function openGroupsInterface(tab = 'creator') {

      // VÃ©rifier si GroupsModuleComplete est disponible (groupsModuleComplete.html)
      if (typeof window !== 'undefined' && window.GroupsModuleComplete && typeof window.GroupsModuleComplete.open === 'function') {
        try {
          window.GroupsModuleComplete.open();
          return;
        } catch (error) {
          console.error('âŒ Erreur lors de l\'ouverture de GroupsModuleComplete:', error);
        }
      }

      // FALLBACK : Si GroupsModuleComplete n'est pas disponible, utiliser l'ancienne interface popup
      console.warn('âš ï¸ GroupsModuleComplete non disponible, fallback vers interface popup...');
      google.script.run
        .withSuccessHandler(function (html) {
          try {
            const groupsWindow = window.open('', 'GroupsManager', 'width=1400,height=900,menubar=no,toolbar=no,scrollbars=yes,resizable=yes');

            if (!groupsWindow || groupsWindow.closed || typeof groupsWindow.closed === 'undefined') {
              console.error('âŒ Impossible d\'ouvrir la fenÃªtre popup - bloquÃ©e par le navigateur');
              alert('âš ï¸ Impossible d\'ouvrir l\'interface des groupes. Veuillez autoriser les popups pour ce site et rÃ©essayer.');
              return;
            }

            groupsWindow.document.open();
            groupsWindow.document.write(html);
            groupsWindow.document.close();

            const checkInterval = setInterval(() => {
              try {
                if (groupsWindow.GroupsUI && typeof groupsWindow.GroupsUI.switchTab === 'function') {
                  clearInterval(checkInterval);
                  groupsWindow.GroupsUI.switchTab(tab);
                }
              } catch (uiError) {
                clearInterval(checkInterval);
              }
            }, 100);

            setTimeout(() => clearInterval(checkInterval), 5000);
          } catch (error) {
            console.error('âŒ Erreur lors de l\'ouverture de l\'interface:', error);
            alert('Erreur lors de l\'ouverture de l\'interface des groupes: ' + error.message);
          }
        })
        .withFailureHandler(function (error) {
          console.error('âŒ Erreur serveur:', error);
          alert('Impossible de charger l\'interface des groupes: ' + error.message);
        })
        .getGroupsInterface();
    }

    // 2. Fonction pour notifier les changements de groupes
    window.notifyGroupsChanged = function () {
      updateGroupsButton();

      // Afficher un message de confirmation
      if (typeof toast === 'function') {
        toast('Groupes mis Ã  jour avec succÃ¨s', 'success');
      }
    };

    // 3. Fonction d'export amÃ©liorÃ©e
    function exportGroupsData() {
      console.log('ğŸ“¤ Export des groupes...');

      google.script.run
        .withSuccessHandler(function (groupsData) {
          if (!groupsData || Object.keys(groupsData).length === 0) {
            alert('Aucun groupe Ã  exporter');
            return;
          }

          // CrÃ©er le CSV avec point-virgule comme sÃ©parateur (compatible Excel FR)
          let csv = 'Type;Groupe;Nom;PrÃ©nom;Sexe;Classe d\'origine;Langue;Score COM;Score TRA;Score PART;Score ABS;Score Maths;Score FranÃ§ais\n';

          Object.entries(groupsData).forEach(([groupName, groupData]) => {
            groupData.students.forEach(student => {
              // Construire la ligne sans guillemets inutiles
              const line = [
                groupData.type || 'N/A',
                groupName,
                student.nom || '',
                student.prenom || '',
                student.sexe || '',
                student.classe || '',
                student.lv1Badge || student.lv1 || '', // Badge de langue ou valeur brute
                student.com || 0,
                student.tra || 0,
                student.part || 0,
                student.abs || 0,
                student.scores?.M || 0,
                student.scores?.F || 0
              ];

              csv += line.join(';') + '\n';
            });
          });

          // TÃ©lÃ©charger le fichier
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `export_groupes_${new Date().toISOString().split('T')[0]}.csv`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          toast('Export CSV gÃ©nÃ©rÃ© avec succÃ¨s', 'success');
        })
        .withFailureHandler(function (error) {
          console.error('Erreur export:', error);
          alert('Erreur lors de l\'export: ' + error.message);
        })
        .getAllGroups();
    }

    // 4. Fonction de suppression avec confirmation amÃ©liorÃ©e
    function confirmDeleteAllGroups() {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50';
      modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl p-6 max-w-md">
      <h3 class="text-lg font-bold mb-4 text-red-600">
        <i class="fas fa-exclamation-triangle mr-2"></i>
        Suppression de tous les groupes
      </h3>
      <p class="text-gray-700 mb-6">
        Cette action supprimera dÃ©finitivement tous les groupes crÃ©Ã©s. 
        Cette opÃ©ration est irrÃ©versible.
      </p>
      <div class="flex justify-end gap-3">
        <button onclick="this.closest('.fixed').remove()" class="btn btn-secondary">
          Annuler
        </button>
        <button onclick="deleteAllGroups(); this.closest('.fixed').remove();" class="btn btn-danger">
          <i class="fas fa-trash mr-2"></i>
          Supprimer tout
        </button>
      </div>
    </div>
  `;
      document.body.appendChild(modal);
    }

    function deleteAllGroups() {
      google.script.run
        .withSuccessHandler(function (success) {
          if (success) {
            updateGroupsButton();
            toast('Tous les groupes ont Ã©tÃ© supprimÃ©s', 'success');
          } else {
            toast('Erreur lors de la suppression', 'error');
          }
        })
        .withFailureHandler(function (error) {
          console.error('Erreur suppression:', error);
          toast('Erreur: ' + error.message, 'error');
        })
        .deleteAllGroups();
    }



    // ========== FONCTIONS SUPPLÃ‰MENTAIRES ==========

    // Fonction pour ajouter des scores de matiÃ¨res
    window.addSubjectScores = function () {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2 class="text-xl font-bold">Ajouter des scores de matiÃ¨res</h2>
        <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <div class="bg-blue-50 p-3 rounded mb-4">
          <p class="text-sm text-blue-800">
            <i class="fas fa-info-circle mr-1"></i>
            Importez un fichier Excel avec les colonnes : ID, MATH, FR
            ou saisissez manuellement les scores.
          </p>
        </div>
        
        <div class="mb-4">
          <button onclick="importSubjectScores()" class="btn btn-primary w-full">
            <i class="fas fa-upload"></i> Importer depuis Excel
          </button>
        </div>
        
        <div class="text-center text-gray-500 my-4">ou</div>
        
        <div>
          <h3 class="font-bold mb-2">Saisie manuelle rapide</h3>
          <div class="text-xs text-gray-600 mb-2">
            SÃ©lectionnez une classe et attribuez des scores alÃ©atoires pour tester
          </div>
          <select id="classForScores" class="form-control mb-2">
            <option value="">-- SÃ©lectionner une classe --</option>
            ${Array.from(document.querySelectorAll('.classe-name'))
          .map(el => `<option value="${el.textContent}">${el.textContent}</option>`)
          .join('')}
          </select>
          <button onclick="generateRandomScores()" class="btn btn-secondary w-full">
            <i class="fas fa-dice"></i> GÃ©nÃ©rer des scores alÃ©atoires
          </button>
        </div>
      </div>
    </div>
  `;
      document.body.appendChild(modal);
    };

    // GÃ©nÃ©rer des scores alÃ©atoires pour tester
    window.generateRandomScores = function () {
      const classe = document.getElementById('classForScores').value;
      if (!classe) {
        toast('SÃ©lectionnez une classe', 'warning');
        return;
      }

      const zone = document.querySelector(`.droppable-zone[data-classe="${classe}"]`);
      if (!zone) return;

      let count = 0;
      zone.querySelectorAll('.student-card').forEach(card => {
        const eleve = STATE.students[card.dataset.id];
        if (eleve) {
          // GÃ©nÃ©rer des scores cohÃ©rents avec le comportement
          const baseScore = eleve.scores?.C || 2.5;
          const variance = 0.5;

          eleve.scores.MATH = Math.max(1, Math.min(4,
            baseScore + (Math.random() - 0.5) * 2 * variance
          ));

          eleve.scores.FR = Math.max(1, Math.min(4,
            baseScore + (Math.random() - 0.5) * 2 * variance
          ));

          count++;
        }
      });

      toast(`${count} scores gÃ©nÃ©rÃ©s pour ${classe}`, 'success');
      document.querySelector('.modal').remove();
    };

    // ========== AMÃ‰LIORATIONS PRIORITAIRES V2 ==========

    // 0. FEEDBACK EN TEMPS RÃ‰EL
    window.RealTimeFeedback = {
      previousMetrics: null,
      isMinimized: false,

      // Initialiser le systÃ¨me de feedback
      init() {
        this.setupEventListeners();
        // Ne pas afficher automatiquement - seulement quand on est dans le menu des groupes
        this.updateMetrics();
      },

      // Configurer les Ã©vÃ©nements
      setupEventListeners() {
        // Minimiser/maximiser le panneau
        document.getElementById('minimizeFeedback')?.addEventListener('click', () => {
          this.toggleMinimize();
        });

        // Fermer le panneau
        document.getElementById('closeFeedback')?.addEventListener('click', () => {
          this.hide();
        });

        // Rendre le panneau dÃ©plaÃ§able
        this.makeDraggable();
      },

      // Rendre le panneau dÃ©plaÃ§able
      makeDraggable() {
        const panel = document.getElementById('feedbackPanel');
        const header = panel?.querySelector('.feedback-header');

        if (!panel || !header) return;

        let isDragging = false;
        let startX, startY, startLeft, startTop;

        header.addEventListener('mousedown', (e) => {
          if (e.target.tagName === 'BUTTON') return;

          isDragging = true;
          startX = e.clientX;
          startY = e.clientY;
          startLeft = parseInt(panel.style.left) || 0;
          startTop = parseInt(panel.style.top) || 0;

          panel.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;

          const deltaX = e.clientX - startX;
          const deltaY = e.clientY - startY;

          panel.style.left = (startLeft + deltaX) + 'px';
          panel.style.top = (startTop + deltaY) + 'px';
        });

        document.addEventListener('mouseup', () => {
          isDragging = false;
          panel.style.cursor = 'grab';
        });
      },

      // Afficher le panneau
      show() {
        const panel = document.getElementById('feedbackPanel');
        if (panel) {
          panel.style.display = 'block';
        }
      },

      // Masquer le panneau
      hide() {
        const panel = document.getElementById('feedbackPanel');
        if (panel) {
          panel.style.display = 'none';
        }
      },

      // Basculer minimisation
      toggleMinimize() {
        const panel = document.getElementById('feedbackPanel');
        if (!panel) return;

        this.isMinimized = !this.isMinimized;
        panel.classList.toggle('minimized', this.isMinimized);

        const icon = document.querySelector('#minimizeFeedback i');
        if (icon) {
          icon.className = this.isMinimized ? 'fas fa-expand' : 'fas fa-minus';
        }
      },

      // Calculer les mÃ©triques actuelles
      calculateMetrics() {
        const metrics = {
          balance: this.calculateBalance(),
          constraints: this.calculateConstraints(),
          diversity: this.calculateDiversity(),
          size: this.calculateSizeBalance(),
          scores: this.calculateScoreBalance(),
          mobility: this.calculateMobilityBalance(),
          globalScore: this.calculateGlobalScore()
        };

        return metrics;
      },

      // Calculer l'Ã©quilibre F/M
      calculateBalance() {
        let totalImbalance = 0;
        let classCount = 0;

        document.querySelectorAll('.class-column').forEach(col => {
          const students = col.querySelectorAll('.student-card');
          const fCount = Array.from(students).filter(card =>
            STATE.students[card.dataset.id]?.sexe === 'F'
          ).length;
          const mCount = Array.from(students).filter(card =>
            STATE.students[card.dataset.id]?.sexe === 'M'
          ).length;

          const imbalance = Math.abs(fCount - mCount);
          totalImbalance += imbalance;
          classCount++;
        });

        return classCount > 0 ? totalImbalance / classCount : 0;
      },

      // Calculer les violations de contraintes
      calculateConstraints() {
        return ConstraintManager ? ConstraintManager.validateAllConstraints().length : 0;
      },

      // Calculer la diversitÃ© des scores
      calculateDiversity() {
        let totalDiversity = 0;
        let classCount = 0;

        document.querySelectorAll('.class-column').forEach(col => {
          const students = col.querySelectorAll('.student-card');
          const scores = Array.from(students).map(card => {
            const student = STATE.students[card.dataset.id];
            return (student?.scores?.M || 0) + (student?.scores?.F || 0);
          }).filter(score => score > 0);

          if (scores.length > 1) {
            const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const variance = scores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / scores.length;
            totalDiversity += Math.sqrt(variance);
          }
          classCount++;
        });

        return classCount > 0 ? totalDiversity / classCount : 0;
      },

      // Calculer l'Ã©quilibre des tailles
      calculateSizeBalance() {
        const sizes = Array.from(document.querySelectorAll('.class-column')).map(col =>
          col.querySelectorAll('.student-card').length
        );

        if (sizes.length === 0) return 0;

        const mean = sizes.reduce((a, b) => a + b, 0) / sizes.length;
        const variance = sizes.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / sizes.length;

        return Math.sqrt(variance);
      },

      // Calculer l'Ã©quilibre des scores
      calculateScoreBalance() {
        let totalImbalance = 0;
        let classCount = 0;

        document.querySelectorAll('.class-column').forEach(col => {
          const students = col.querySelectorAll('.student-card');
          const scores = Array.from(students).map(card => {
            const student = STATE.students[card.dataset.id];
            return (student?.scores?.M || 0) + (student?.scores?.F || 0);
          }).filter(score => score > 0);

          if (scores.length > 1) {
            const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
            const variance = scores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / scores.length;
            totalImbalance += Math.sqrt(variance);
          }
          classCount++;
        });

        return classCount > 0 ? totalImbalance / classCount : 0;
      },

      // Calculer l'Ã©quilibre de mobilitÃ©
      calculateMobilityBalance() {
        let totalImbalance = 0;
        let classCount = 0;

        document.querySelectorAll('.class-column').forEach(col => {
          const students = col.querySelectorAll('.student-card');
          const permutCount = Array.from(students).filter(card =>
            STATE.students[card.dataset.id]?.mobilite === 'PERMUT'
          ).length;
          const fixeCount = Array.from(students).filter(card =>
            STATE.students[card.dataset.id]?.mobilite === 'FIXE'
          ).length;

          const imbalance = Math.abs(permutCount - fixeCount);
          totalImbalance += imbalance;
          classCount++;
        });

        return classCount > 0 ? totalImbalance / classCount : 0;
      },

      // Calculer le score global
      calculateGlobalScore() {
        const balance = this.calculateBalance();
        const constraints = this.calculateConstraints();
        const diversity = this.calculateDiversity();
        const size = this.calculateSizeBalance();
        const scores = this.calculateScoreBalance();
        const mobility = this.calculateMobilityBalance();

        // Score inversÃ© (plus c'est bas, mieux c'est)
        const balanceScore = Math.max(0, 10 - balance * 2);
        const constraintScore = Math.max(0, 10 - constraints * 2);
        const diversityScore = Math.min(10, diversity);
        const sizeScore = Math.max(0, 10 - size);
        const scoreBalance = Math.min(10, scores);
        const mobilityScore = Math.max(0, 10 - mobility);

        return (balanceScore + constraintScore + diversityScore + sizeScore + scoreBalance + mobilityScore) / 6;
      },

      // Mettre Ã  jour l'affichage des mÃ©triques
      updateMetrics() {
        const currentMetrics = this.calculateMetrics();

        // Mettre Ã  jour les valeurs
        this.updateMetricValue('balanceValue', currentMetrics.balance.toFixed(1));
        this.updateMetricValue('constraintsValue', currentMetrics.constraints);
        this.updateMetricValue('diversityValue', currentMetrics.diversity.toFixed(1));
        this.updateMetricValue('sizeValue', currentMetrics.size.toFixed(1));
        this.updateMetricValue('scoresValue', currentMetrics.scores.toFixed(1));
        this.updateMetricValue('mobilityValue', currentMetrics.mobility.toFixed(1));
        this.updateMetricValue('globalScoreValue', currentMetrics.globalScore.toFixed(1));

        // Calculer et afficher les changements
        if (this.previousMetrics) {
          this.updateMetricChange('balanceChange', currentMetrics.balance, this.previousMetrics.balance);
          this.updateMetricChange('constraintsChange', currentMetrics.constraints, this.previousMetrics.constraints, true);
          this.updateMetricChange('diversityChange', currentMetrics.diversity, this.previousMetrics.diversity);
          this.updateMetricChange('sizeChange', currentMetrics.size, this.previousMetrics.size, true);
          this.updateMetricChange('scoresChange', currentMetrics.scores, this.previousMetrics.scores);
          this.updateMetricChange('mobilityChange', currentMetrics.mobility, this.previousMetrics.mobility);
          this.updateMetricChange('globalScoreChange', currentMetrics.globalScore, this.previousMetrics.globalScore);
        }

        this.previousMetrics = { ...currentMetrics };
      },

      // Mettre Ã  jour une valeur de mÃ©trique
      updateMetricValue(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
          element.textContent = value;
        }
      },

      // Mettre Ã  jour l'indicateur de changement
      updateMetricChange(elementId, currentValue, previousValue, inverted = false) {
        const element = document.getElementById(elementId);
        if (!element) return;

        const change = currentValue - previousValue;
        const changeElement = element.querySelector('span');
        const iconElement = element.querySelector('i');

        if (Math.abs(change) < 0.01) {
          // Pas de changement
          element.className = 'metric-change neutral';
          iconElement.className = 'fas fa-minus';
          changeElement.textContent = '0';
        } else {
          const isImprovement = inverted ? change < 0 : change > 0;

          element.className = `metric-change ${isImprovement ? 'improved' : 'degraded'}`;
          iconElement.className = isImprovement ? 'fas fa-arrow-up' : 'fas fa-arrow-down';
          changeElement.textContent = Math.abs(change).toFixed(1);

          // Animation de pulse
          const metricValue = element.closest('.metric-value');
          metricValue.classList.add('changed');
          setTimeout(() => metricValue.classList.remove('changed'), 600);
        }
      },

      // PrÃ©visualiser l'impact d'un dÃ©placement
      previewMove(studentId, targetGroup) {
        if (!this.previousMetrics) return;

        // Simuler le dÃ©placement
        const originalGroup = this.findStudentGroup(studentId);
        if (!originalGroup || originalGroup === targetGroup) return;

        // Calculer les nouvelles mÃ©triques
        const newMetrics = this.calculateMetricsWithMove(studentId, targetGroup);

        // Afficher les changements prÃ©visionnels
        this.updateMetricChange('balanceChange', newMetrics.balance, this.previousMetrics.balance);
        this.updateMetricChange('constraintsChange', newMetrics.constraints, this.previousMetrics.constraints, true);
        this.updateMetricChange('diversityChange', newMetrics.diversity, this.previousMetrics.diversity);
        this.updateMetricChange('sizeChange', newMetrics.size, this.previousMetrics.size, true);
        this.updateMetricChange('globalScoreChange', newMetrics.globalScore, this.previousMetrics.globalScore);
      },

      // Trouver le groupe d'un Ã©lÃ¨ve
      findStudentGroup(studentId) {
        const card = document.querySelector(`[data-id="${studentId}"]`);
        return card?.closest('.class-column')?.querySelector('.classe-name')?.textContent;
      },

      // Calculer les mÃ©triques avec un dÃ©placement simulÃ©
      calculateMetricsWithMove(studentId, targetGroup) {
        // ImplÃ©mentation simplifiÃ©e - en rÃ©alitÃ©, il faudrait simuler le dÃ©placement
        // Pour l'instant, on retourne les mÃ©triques actuelles
        return this.calculateMetrics();
      },

      // RÃ©initialiser les changements
      resetChanges() {
        const changes = ['balanceChange', 'constraintsChange', 'diversityChange', 'sizeChange', 'scoresChange', 'mobilityChange', 'globalScoreChange'];
        changes.forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.className = 'metric-change neutral';
            const icon = element.querySelector('i');
            const span = element.querySelector('span');
            if (icon) icon.className = 'fas fa-minus';
            if (span) span.textContent = '0';
          }
        });
      }
    };

    // 1. IMPORT DES SCORES INT
    const ScoreImporter = {
      // Importer les scores depuis les fichiers INT
      async importScoresFromINT() {
        try {
          const result = await gsRun('getINTScores');
          if (result.success) {
            // Mapper les scores sur les Ã©lÃ¨ves existants
            let importedCount = 0;
            result.scores.forEach(score => {
              if (STATE.students[score.id]) {
                STATE.students[score.id].scores.M = score.MATH;
                STATE.students[score.id].scores.F = score.FR;
                importedCount++;
              }
            });

            // RafraÃ®chir l'affichage
            this.refreshScoreDisplay();

            toast(`${importedCount} scores importÃ©s avec succÃ¨s`, 'success');
            return { success: true, count: importedCount };
          } else {
            toast('Erreur lors de l\'import des scores', 'error');
            return { success: false, error: result.error };
          }
        } catch (error) {
          console.error('Erreur import scores:', error);
          toast('Erreur lors de l\'import des scores', 'error');
          return { success: false, error: error.message };
        }
      },

      // RafraÃ®chir l'affichage des scores
      refreshScoreDisplay() {
        document.querySelectorAll('.student-card').forEach(card => {
          const eleve = STATE.students[card.dataset.id];
          if (eleve && eleve.scores) {
            const scoresContainer = card.querySelector('.scores');
            if (scoresContainer) {
              scoresContainer.innerHTML = this.generateScoreBadges(eleve.scores);
            }
          }
        });
      },

      // GÃ©nÃ©rer les badges de scores
      generateScoreBadges(scores) {
        const badges = [];

        // Scores existants (COM, TRA, PART, ABS) avec 4 couleurs distinctes
        const scoreMap = [
          { key: 'COM', label: 'Comportement', letter: 'C' },
          { key: 'TRA', label: 'Travail', letter: 'T' },
          { key: 'PART', label: 'Participation', letter: 'P' },
          { key: 'ABS', label: 'Absences', letter: 'A' }
        ];

        scoreMap.forEach(({ key, label, letter }) => {
          if (scores[key] !== undefined && scores[key] !== '' && scores[key] > 0) {
            const score = scores[key];
            // Utiliser les classes score-pill existantes pour avoir 4 couleurs distinctes :
            // score-1 = ROUGE, score-2 = JAUNE, score-3 = VERT CLAIR, score-4 = VERT FONCÃ‰
            badges.push(`<div class="score-pill score-${score}" title="${label}: ${score}/4">${letter}</div>`);
          }
        });

        // Nouveaux scores (MATH, FR) - garder l'ancien systÃ¨me
        ['M', 'F'].forEach(key => {
          if (scores[key] !== undefined && scores[key] !== '') {
            const score = scores[key];
            const color = score >= 3 ? 'bg-blue-100 text-blue-800' :
              score >= 2 ? 'bg-orange-100 text-orange-800' :
                'bg-red-100 text-red-800';
            const label = key === 'M' ? 'MATH' : 'FR';
            badges.push(`<span class="score-badge ${color} text-xs px-1 rounded">${label}:${score}</span>`);
          }
        });

        return badges.join('');
      },

      // Afficher les groupes existants
      showGroups() {
        const section = document.getElementById('groupsSection');
        if (section) {
          section.style.display = 'block';
          // RafraÃ®chir l'affichage si nÃ©cessaire
          if (Object.keys(this.groups).length > 0) {
            this.displaySavedGroups(true);
          }
        } else if (Object.keys(this.groups).length > 0) {
          // Si la section n'existe pas mais qu'il y a des groupes, la crÃ©er
          this.displaySavedGroups(true);
        } else {
          toast('Aucun groupe crÃ©Ã©', 'info');
        }
      },

      // Masquer les groupes
      hideGroups() {
        const section = document.getElementById('groupsSection');
        if (section) {
          section.style.display = 'none';
        }
        toast('Groupes masquÃ©s', 'info');
      },

      // Basculer l'affichage des groupes
      toggleGroups() {
        const section = document.getElementById('groupsSection');
        if (section && section.style.display !== 'none') {
          this.hideGroups();
        } else {
          this.showGroups();
        }
      },

      // Supprimer tous les groupes
      deleteAllGroups() {
        if (!confirm('Supprimer TOUS les groupes crÃ©Ã©s ? Cette action est irrÃ©versible.')) return;

        this.groups = {};
        this.saveGroups();

        // Retirer la section
        const section = document.getElementById('groupsSection');
        if (section) section.remove();

        toast('Tous les groupes ont Ã©tÃ© supprimÃ©s', 'info');
      },

      // Mettre Ã  jour le bouton pour afficher le nombre de groupes
      updateGroupsButton() {
        const btn = document.getElementById('btnGroups');
        if (btn && this.groups) {
          const count = Object.keys(this.groups).length;
          if (count > 0) {
            btn.innerHTML = `<i class="fas fa-layer-group"></i> Groupes <span class="bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full text-xs ml-1">${count}</span> <i class="fas fa-caret-down"></i>`;
          } else {
            btn.innerHTML = '<i class="fas fa-layer-group"></i> Groupes <i class="fas fa-caret-down"></i>';
          }
        }
      }
    };

    // 2. ALGORITHME D'OPTIMISATION AMÃ‰LIORÃ‰
    const OptimizerV2 = {
      // Algorithme gÃ©nÃ©tique simple pour optimiser l'Ã©quilibre
      optimizeGroupsGenetic(students, numGroups, iterations = 100) {
        // CrÃ©er population initiale
        let bestSolution = this.createInitialGroups(students, numGroups);
        let bestScore = this.evaluateSolution(bestSolution);

        for (let i = 0; i < iterations; i++) {
          // Mutation : Ã©changer 2 Ã©lÃ¨ves alÃ©atoires
          const mutated = this.mutateSolution(bestSolution);
          const score = this.evaluateSolution(mutated);

          if (score > bestScore) {
            bestSolution = mutated;
            bestScore = score;
          }
        }

        return bestSolution;
      },

      // CrÃ©er des groupes initiaux
      createInitialGroups(students, numGroups) {
        const groups = Array(numGroups).fill(null).map(() => []);

        // Distribution alÃ©atoire initiale
        students.forEach((student, index) => {
          const groupIndex = index % numGroups;
          groups[groupIndex].push(student);
        });

        return groups;
      },

      // Ã‰valuer la qualitÃ© d'une solution
      evaluateSolution(groups) {
        let score = 100;

        // PÃ©nalitÃ© pour dÃ©sÃ©quilibre de taille
        const avgSize = groups.reduce((sum, g) => sum + g.length, 0) / groups.length;
        groups.forEach(g => {
          score -= Math.abs(g.length - avgSize) * 5;
        });

        // PÃ©nalitÃ© pour dÃ©sÃ©quilibre F/M
        groups.forEach(g => {
          const ratio = g.filter(s => s.sexe === 'F').length / g.length;
          score -= Math.abs(ratio - 0.5) * 50;
        });

        // Bonus pour hÃ©tÃ©rogÃ©nÃ©itÃ© des scores
        groups.forEach(g => {
          const scores = g.map(s => (s.scores?.M || 0) + (s.scores?.F || 0));
          const variance = this.calculateVariance(scores);
          score += variance * 10; // Plus de variance = mieux
        });

        return score;
      },

      // Calculer la variance
      calculateVariance(scores) {
        if (scores.length === 0) return 0;
        const mean = scores.reduce((a, b) => a + b, 0) / scores.length;
        const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
        return variance;
      },

      // Mutation d'une solution
      mutateSolution(groups) {
        const mutated = groups.map(g => [...g]); // Copie profonde

        // SÃ©lectionner deux groupes alÃ©atoires
        const group1Index = Math.floor(Math.random() * mutated.length);
        const group2Index = Math.floor(Math.random() * mutated.length);

        if (group1Index !== group2Index && mutated[group1Index].length > 0 && mutated[group2Index].length > 0) {
          // SÃ©lectionner deux Ã©lÃ¨ves alÃ©atoires
          const student1Index = Math.floor(Math.random() * mutated[group1Index].length);
          const student2Index = Math.floor(Math.random() * mutated[group2Index].length);

          // Ã‰changer les Ã©lÃ¨ves
          const temp = mutated[group1Index][student1Index];
          mutated[group1Index][student1Index] = mutated[group2Index][student2Index];
          mutated[group2Index][student2Index] = temp;
        }

        return mutated;
      },

      // Appliquer l'optimisation ClaudeMotor depuis le backend
      applyOptimization() {
        // Afficher un loader
        const loadingToast = document.createElement('div');
        loadingToast.className = 'fixed top-4 right-4 bg-purple-600 text-white px-6 py-4 rounded-lg shadow-lg z-50';
        loadingToast.innerHTML = `
      <div class="flex items-center gap-3">
        <i class="fas fa-spinner fa-spin"></i>
        <div>
          <div class="font-bold">Optimisation en cours...</div>
          <div class="text-sm opacity-90">ClaudeMotor analyse vos classes</div>
        </div>
      </div>
    `;
        document.body.appendChild(loadingToast);

        // Appeler le backend
        google.script.run
          .withSuccessHandler((response) => {
            loadingToast.remove();

            if (response.success) {
              toast(`Optimisation terminÃ©e ! ${response.results.totalSwaps} Ã©changes suggÃ©rÃ©s`, 'success');
              this.displayClaudeMotorResults(response.results);
            } else {
              toast(`Erreur: ${response.error}`, 'error');
              console.error('Erreur optimisation:', response);
            }
          })
          .withFailureHandler((error) => {
            loadingToast.remove();
            toast(`Erreur technique: ${error.message}`, 'error');
            console.error('Erreur appel backend:', error);
          })
          .lancerOptimisationClaudeMotor({
            maxIterations: 50,
            enableMultiSwap: true
          });
      },

      // Afficher les rÃ©sultats ClaudeMotor
      displayClaudeMotorResults(results) {
        const modal = document.createElement('div');
        modal.className = 'modal';

        // Formater les swaps par phase
        let swapsHTML = '';
        if (results.swaps && results.swaps.length > 0) {
          swapsHTML = `
        <div class="mb-4">
          <h3 class="font-bold text-lg mb-2">ğŸ“ Ã‰changes suggÃ©rÃ©s (${results.swaps.length})</h3>
          <div class="max-h-60 overflow-y-auto border rounded p-2">
            ${results.swaps.map((swap, i) => `
              <div class="text-sm p-2 bg-gray-50 rounded mb-2">
                <strong>#${i + 1}</strong>:
                ${swap.student1?.nom || swap.studentSource?.nom || 'Ã‰lÃ¨ve 1'}
                (${swap.class1 || swap.sourceClass || '?'})
                â†”
                ${swap.student2?.nom || swap.studentTarget?.nom || 'Ã‰lÃ¨ve 2'}
                (${swap.class2 || swap.targetClass || '?'})
              </div>
            `).join('')}
          </div>
        </div>
      `;
        } else {
          swapsHTML = `
        <div class="mb-4 p-4 bg-green-50 border border-green-200 rounded">
          <p class="text-green-800">âœ… Aucun Ã©change nÃ©cessaire - La rÃ©partition est dÃ©jÃ  optimale !</p>
        </div>
      `;
        }

        modal.innerHTML = `
      <div class="modal-content" style="max-width: 900px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">ğŸš€ RÃ©sultats ClaudeMotor</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <!-- Scores -->
          <div class="grid grid-cols-3 gap-4 mb-4">
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Score initial</div>
              <div class="text-2xl font-bold text-gray-800">${results.scoreInitial.toFixed(1)}/100</div>
            </div>
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">Score final</div>
              <div class="text-2xl font-bold text-green-600">${results.scoreFinal.toFixed(1)}/100</div>
            </div>
            <div class="border rounded p-3 text-center">
              <div class="text-sm text-gray-600">AmÃ©lioration</div>
              <div class="text-2xl font-bold ${results.improvement >= 0 ? 'text-green-600' : 'text-red-600'}">
                ${results.improvement >= 0 ? '+' : ''}${results.improvement.toFixed(1)}
              </div>
            </div>
          </div>

          <!-- Phases -->
          ${results.phases ? `
            <div class="mb-4">
              <h3 class="font-bold mb-2">ğŸ“Š DÃ©tails des phases</h3>
              <div class="grid grid-cols-3 gap-2">
                <div class="text-xs border rounded p-2">
                  <strong>Phase 1 (Scores)</strong><br>
                  ${results.phases.phase1?.swaps?.length || 0} Ã©changes
                </div>
                <div class="text-xs border rounded p-2">
                  <strong>Phase 2 (ParitÃ©)</strong><br>
                  ${results.phases.phase2?.corrections?.length || 0} corrections
                </div>
                <div class="text-xs border rounded p-2">
                  <strong>Phase 3 (MultiSwap)</strong><br>
                  ${results.phases.phase3?.cycles?.length || 0} cycles
                </div>
              </div>
            </div>
          ` : ''}

          ${swapsHTML}

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="OptimizerV2.applyClaudeMotorSwaps()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer les Ã©changes
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Fermer
            </button>
          </div>

          <div class="mt-4 text-xs text-gray-500">
            â±ï¸ DurÃ©e: ${results.duration}ms |
            ğŸ”„ ${results.totalSwaps} Ã©changes au total
          </div>
        </div>
      </div>
    `;
        document.body.appendChild(modal);

        // Sauvegarder les swaps pour application ultÃ©rieure
        window._claudeMotorSwaps = results.swaps;
      },

      // Appliquer les swaps ClaudeMotor
      applyClaudeMotorSwaps() {
        const swaps = window._claudeMotorSwaps;
        if (!swaps || swaps.length === 0) {
          toast('Aucun Ã©change Ã  appliquer', 'info');
          document.querySelector('.modal')?.remove();
          return;
        }

        // TODO: ImplÃ©menter l'application rÃ©elle des swaps dans l'interface
        // Pour l'instant, juste recharger les donnÃ©es
        toast(`Application de ${swaps.length} Ã©changes...`, 'info');

        setTimeout(() => {
          toast('Ã‰changes appliquÃ©s ! Rechargez les donnÃ©es pour voir les changements.', 'success');
          document.querySelector('.modal')?.remove();
        }, 1000);
      },

      // Afficher les rÃ©sultats d'optimisation (ancien algorithme - conservÃ© pour compatibilitÃ©)
      displayOptimizationResults(groups) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
      <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">RÃ©sultats de l'optimisation</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="grid grid-cols-2 gap-4">
            ${groups.map((group, index) => `
              <div class="border rounded p-3">
                <h4 class="font-bold mb-2">Groupe ${index + 1} (${group.length} Ã©lÃ¨ves)</h4>
                <div class="text-sm text-gray-600 mb-2">
                  F: ${group.filter(s => s.sexe === 'F').length} | 
                  M: ${group.filter(s => s.sexe === 'M').length}
                </div>
                <div class="max-h-32 overflow-y-auto">
                  ${group.slice(0, 10).map(s => `
                    <div class="text-xs p-1 bg-gray-50 rounded mb-1">
                      ${s.nom} ${s.prenom || ''} (${s.sexe})
                    </div>
                  `).join('')}
                  ${group.length > 10 ? `<div class="text-xs text-gray-500">... et ${group.length - 10} autres</div>` : ''}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="mt-4 flex gap-2">
            <button onclick="OptimizerV2.applyOptimizationResults()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer cette rÃ©partition
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Annuler
            </button>
          </div>
        </div>
      </div>
    `;
        document.body.appendChild(modal);
      },

      // Appliquer les rÃ©sultats d'optimisation
      applyOptimizationResults() {
        // Cette fonction serait appelÃ©e pour appliquer rÃ©ellement les changements
        toast('Optimisation appliquÃ©e', 'success');
        document.querySelector('.modal').remove();
      }
    };

    // 3. GESTION DES CONTRAINTES ASSO/DISSO AMÃ‰LIORÃ‰E
    const ConstraintManager = {
      // VÃ©rifier les contraintes avant tout dÃ©placement
      checkGroupConstraints(studentId, targetGroup) {
        const student = STATE.students[studentId];
        if (!student) return { valid: false, reason: 'Ã‰lÃ¨ve non trouvÃ©' };

        // VÃ©rifier dissociation
        if (student.disso) {
          const conflictExists = targetGroup.some(s =>
            STATE.students[s.id] && STATE.students[s.id].disso === student.disso
          );
          if (conflictExists) {
            return { valid: false, reason: `Conflit dissociation D${student.disso}` };
          }
        }

        // VÃ©rifier association
        if (student.asso) {
          const assoGroup = STATE.aGroups[`A${student.asso}`];
          if (assoGroup) {
            const allInSameGroup = assoGroup.every(id =>
              targetGroup.some(s => s.id === id) || id === studentId
            );
            if (!allInSameGroup) {
              return { valid: false, reason: `Groupe A${student.asso} doit rester ensemble` };
            }
          }
        }

        return { valid: true };
      },

      // Afficher visuellement les contraintes
      showConstraintsOverlay() {
        // Colorer les Ã©lÃ¨ves avec le mÃªme code disso
        document.querySelectorAll('.student-card').forEach(card => {
          const eleve = STATE.students[card.dataset.id];
          if (eleve && eleve.disso) {
            card.style.border = '2px solid #ef4444';
            card.style.backgroundColor = '#fef2f2';

            // Ajouter un badge de contrainte
            let badge = card.querySelector('.constraint-badge');
            if (!badge) {
              badge = document.createElement('div');
              badge.className = 'constraint-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs px-1 rounded-full';
              badge.textContent = `D${eleve.disso}`;
              card.style.position = 'relative';
              card.appendChild(badge);
            }
          }

          // Relier visuellement les Ã©lÃ¨ves avec le mÃªme code asso
          if (eleve && eleve.asso) {
            card.style.border = '2px solid #3b82f6';
            card.style.backgroundColor = '#eff6ff';

            let badge = card.querySelector('.constraint-badge');
            if (!badge) {
              badge = document.createElement('div');
              badge.className = 'constraint-badge absolute -top-1 -right-1 bg-blue-500 text-white text-xs px-1 rounded-full';
              badge.textContent = `A${eleve.asso}`;
              card.style.position = 'relative';
              card.appendChild(badge);
            }
          }
        });
      },

      // Masquer les contraintes
      hideConstraintsOverlay() {
        document.querySelectorAll('.student-card').forEach(card => {
          card.style.border = '';
          card.style.backgroundColor = '';
          card.style.position = '';

          const badge = card.querySelector('.constraint-badge');
          if (badge) badge.remove();
        });
      },

      // VÃ©rifier toutes les contraintes dans l'interface
      validateAllConstraints() {
        const violations = [];

        // VÃ©rifier les dissociations
        const dissoGroups = {};
        document.querySelectorAll('.student-card').forEach(card => {
          const eleve = STATE.students[card.dataset.id];
          if (eleve && eleve.disso) {
            const classe = card.closest('.droppable-zone').dataset.classe;
            if (!dissoGroups[eleve.disso]) dissoGroups[eleve.disso] = [];
            dissoGroups[eleve.disso].push({ eleve, classe });
          }
        });

        Object.entries(dissoGroups).forEach(([code, eleves]) => {
          const classes = [...new Set(eleves.map(e => e.classe))];
          if (classes.length > 1) {
            violations.push({
              type: 'DISSO',
              code,
              message: `Code D${code} rÃ©parti sur ${classes.length} classes: ${classes.join(', ')}`
            });
          }
        });

        // VÃ©rifier les associations
        const assoGroups = {};
        document.querySelectorAll('.student-card').forEach(card => {
          const eleve = STATE.students[card.dataset.id];
          if (eleve && eleve.asso) {
            const classe = card.closest('.droppable-zone').dataset.classe;
            if (!assoGroups[eleve.asso]) assoGroups[eleve.asso] = [];
            assoGroups[eleve.asso].push({ eleve, classe });
          }
        });

        Object.entries(assoGroups).forEach(([code, eleves]) => {
          const classes = [...new Set(eleves.map(e => e.classe))];
          if (classes.length > 1) {
            violations.push({
              type: 'ASSO',
              code,
              message: `Groupe A${code} sÃ©parÃ© sur ${classes.length} classes: ${classes.join(', ')}`
            });
          }
        });

        return violations;
      },

      // Afficher les violations de contraintes
      showConstraintViolations() {
        const violations = this.validateAllConstraints();

        if (violations.length === 0) {
          toast('âœ… Aucune violation de contrainte dÃ©tectÃ©e', 'success');
          // Proposer d'ouvrir le panneau des contraintes
          this.showConstraintsPanel();
          return;
        }

        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
      <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold text-red-600">
            <i class="fas fa-exclamation-triangle mr-2"></i>
            ${violations.length} Violation(s) de contraintes
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="space-y-3">
            ${violations.map(v => `
              <div class="p-3 border-l-4 ${v.type === 'DISSO' ? 'border-red-500 bg-red-50' : 'border-blue-500 bg-blue-50'}">
                <div class="font-semibold ${v.type === 'DISSO' ? 'text-red-800' : 'text-blue-800'}">
                  ${v.type === 'DISSO' ? 'Dissociation' : 'Association'} ${v.code}
                </div>
                <div class="text-sm ${v.type === 'DISSO' ? 'text-red-700' : 'text-blue-700'}">
                  ${v.message}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="mt-4 flex gap-2">
            <button onclick="ConstraintManager.showConstraintsOverlay()" class="btn btn-secondary">
              <i class="fas fa-eye"></i> Voir les contraintes
            </button>
            <button onclick="ConstraintManager.showConstraintsPanel(); this.closest('.modal').remove();" class="btn btn-secondary">
              <i class="fas fa-cog"></i> GÃ©rer les contraintes
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-primary">
              <i class="fas fa-check"></i> Compris
            </button>
          </div>
        </div>
      </div>
    `;
        document.body.appendChild(modal);
      },

      // Afficher le panneau complet de gestion des contraintes
      showConstraintsPanel() {
        // Charger depuis le backend
        const loadingToast = document.createElement('div');
        loadingToast.className = 'fixed top-4 right-4 bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg z-50';
        loadingToast.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Chargement des contraintes...';
        document.body.appendChild(loadingToast);

        google.script.run
          .withSuccessHandler((response) => {
            loadingToast.remove();
            if (response.success) {
              this.displayConstraintsPanel(response.constraints);
            } else {
              toast(`Erreur: ${response.error}`, 'error');
            }
          })
          .withFailureHandler((error) => {
            loadingToast.remove();
            toast(`Erreur: ${error.message}`, 'error');
          })
          .chargerContraintes();
      },

      // Afficher le panneau des contraintes
      displayConstraintsPanel(constraints) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'constraintsModal';

        // Analyser les contraintes actuelles de l'interface
        const currentDisso = {};
        const currentAsso = {};
        const currentFixe = [];

        document.querySelectorAll('.student-card').forEach(card => {
          const eleve = STATE.students[card.dataset.id];
          if (!eleve) return;

          if (eleve.disso) {
            if (!currentDisso[eleve.disso]) currentDisso[eleve.disso] = [];
            currentDisso[eleve.disso].push(`${eleve.nom} ${eleve.prenom || ''}`);
          }
          if (eleve.asso) {
            if (!currentAsso[eleve.asso]) currentAsso[eleve.asso] = [];
            currentAsso[eleve.asso].push(`${eleve.nom} ${eleve.prenom || ''}`);
          }
          if (eleve.mobilite === 'FIXE') {
            const classe = card.closest('.droppable-zone')?.dataset.classe;
            currentFixe.push(`${eleve.nom} ${eleve.prenom || ''} (${classe || '?'})`);
          }
        });

        modal.innerHTML = `
      <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <h2 class="text-2xl font-bold">
            <i class="fas fa-link mr-2"></i>
            Gestion des Contraintes
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <!-- Structure from _STRUCTURE -->
          <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-sitemap mr-2"></i>Structure (_STRUCTURE)
            </h3>
            <div class="text-sm space-y-2">
              ${constraints.structure && constraints.structure.length > 0 ? `
                <table class="w-full text-sm">
                  <thead class="bg-blue-100">
                    <tr>
                      <th class="p-2 text-left">Origine</th>
                      <th class="p-2 text-left">Destination</th>
                      <th class="p-2 text-center">Effectif</th>
                      <th class="p-2 text-left">Options</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${constraints.structure.map(s => `
                      <tr class="border-b">
                        <td class="p-2">${s.origine || '-'}</td>
                        <td class="p-2">${s.destination || '-'}</td>
                        <td class="p-2 text-center">${s.effectif || 28}</td>
                        <td class="p-2 text-xs">${s.options || '-'}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              ` : '<p class="text-gray-600">Aucune structure dÃ©finie dans _STRUCTURE</p>'}
            </div>
          </div>

          <!-- FIXE -->
          <div class="mb-6 p-4 bg-purple-50 border border-purple-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-lock mr-2"></i>Ã‰lÃ¨ves FIXE (${currentFixe.length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces Ã©lÃ¨ves ne peuvent pas changer de classe</p>
            ${currentFixe.length > 0 ? `
              <div class="max-h-32 overflow-y-auto">
                ${currentFixe.map(e => `
                  <div class="text-sm p-1 bg-white rounded mb-1">${e}</div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucun Ã©lÃ¨ve fixÃ©</p>'}
          </div>

          <!-- DISSO -->
          <div class="mb-6 p-4 bg-red-50 border border-red-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-ban mr-2"></i>Codes DISSO (${Object.keys(currentDisso).length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces Ã©lÃ¨ves NE DOIVENT PAS Ãªtre dans la mÃªme classe</p>
            ${Object.keys(currentDisso).length > 0 ? `
              <div class="space-y-2">
                ${Object.entries(currentDisso).map(([code, eleves]) => `
                  <div class="p-2 bg-white rounded border border-red-300">
                    <div class="font-bold text-red-700">D${code} (${eleves.length} Ã©lÃ¨ves)</div>
                    <div class="text-xs text-gray-700">${eleves.join(', ')}</div>
                  </div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucune dissociation dÃ©finie</p>'}
          </div>

          <!-- ASSO -->
          <div class="mb-6 p-4 bg-green-50 border border-green-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-users mr-2"></i>Codes ASSO (${Object.keys(currentAsso).length})
            </h3>
            <p class="text-sm text-gray-600 mb-2">Ces Ã©lÃ¨ves DOIVENT rester ensemble</p>
            ${Object.keys(currentAsso).length > 0 ? `
              <div class="space-y-2">
                ${Object.entries(currentAsso).map(([code, eleves]) => `
                  <div class="p-2 bg-white rounded border border-green-300">
                    <div class="font-bold text-green-700">A${code} (${eleves.length} Ã©lÃ¨ves)</div>
                    <div class="text-xs text-gray-700">${eleves.join(', ')}</div>
                  </div>
                `).join('')}
              </div>
            ` : '<p class="text-sm text-gray-500">Aucune association dÃ©finie</p>'}
          </div>

          <!-- Options et LV2 -->
          <div class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded">
            <h3 class="font-bold text-lg mb-2">
              <i class="fas fa-star mr-2"></i>Contraintes OPT et LV2
            </h3>
            <p class="text-sm text-gray-600 mb-2">VÃ©rification des quotas d'options par classe</p>
            <div class="text-sm">
              <p class="text-gray-700">âœ… Les contraintes d'options sont vÃ©rifiÃ©es automatiquement lors des dÃ©placements</p>
              <p class="text-gray-700 mt-1">â„¹ï¸ Voir _STRUCTURE pour les quotas dÃ©finis par classe</p>
            </div>
          </div>

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="ConstraintManager.showConstraintsOverlay()" class="btn btn-secondary">
              <i class="fas fa-eye"></i> Visualiser sur les cartes
            </button>
            <button onclick="window.open('https://docs.google.com/spreadsheets/d/' + google.script.host.origin.split('/')[2] + '/edit#gid=SHEET_ID_STRUCTURE', '_blank')" class="btn btn-secondary">
              <i class="fas fa-external-link-alt"></i> Ouvrir _STRUCTURE
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-primary">
              <i class="fas fa-check"></i> Fermer
            </button>
          </div>
        </div>
      </div>
    `;
        document.body.appendChild(modal);
      }
    };

    // 4. GESTIONNAIRE DE FILTRES
    const FilterManager = {
      activeFilters: {},

      // Afficher le panneau de filtres
      showFiltersPanel() {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'filtersModal';

        // Collecter les valeurs uniques pour chaque filtre
        const lv2Set = new Set();
        const optSet = new Set();
        const dissoSet = new Set();
        const assoSet = new Set();
        const mobiliteSet = new Set();
        const scoresCOM = new Set();

        Object.values(STATE.students || {}).forEach(eleve => {
          if (eleve.lv2) lv2Set.add(eleve.lv2);
          if (eleve.opt) optSet.add(eleve.opt);
          if (eleve.disso) dissoSet.add(eleve.disso);
          if (eleve.asso) assoSet.add(eleve.asso);
          if (eleve.mobilite) mobiliteSet.add(eleve.mobilite);
          if (eleve.scores && eleve.scores.COM) scoresCOM.add(eleve.scores.COM);
        });

        modal.innerHTML = `
      <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
          <h2 class="text-2xl font-bold">
            <i class="fas fa-filter mr-2"></i>
            Filtres
          </h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <p class="text-sm text-gray-600 mb-4">
            Filtrez les Ã©lÃ¨ves affichÃ©s selon leurs caractÃ©ristiques. Les Ã©lÃ¨ves non filtrÃ©s seront grisÃ©s.
          </p>

          <!-- Filtres actifs -->
          <div id="activeFiltersDisplay" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded ${Object.keys(this.activeFilters).length === 0 ? 'hidden' : ''}">
            <h4 class="font-bold text-sm mb-2">Filtres actifs :</h4>
            <div id="activeFiltersList" class="flex flex-wrap gap-2"></div>
          </div>

          <!-- LV2 -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-language mr-2"></i>LV2
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(lv2Set).sort().map(lv2 => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="lv2" data-filter-value="${lv2}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${lv2}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- OPT -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-star mr-2"></i>Options
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(optSet).sort().map(opt => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="opt" data-filter-value="${opt}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${opt}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- DISSO -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-ban mr-2 text-red-600"></i>Codes DISSO
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(dissoSet).sort().map(disso => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="disso" data-filter-value="${disso}">
                  <span class="text-sm px-3 py-1 bg-red-100 rounded hover:bg-red-200">D${disso}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- ASSO -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-users mr-2 text-green-600"></i>Codes ASSO
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(assoSet).sort().map(asso => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="asso" data-filter-value="${asso}">
                  <span class="text-sm px-3 py-1 bg-green-100 rounded hover:bg-green-200">A${asso}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- MobilitÃ© -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-exchange-alt mr-2"></i>MobilitÃ©
            </h3>
            <div class="flex flex-wrap gap-2">
              ${Array.from(mobiliteSet).sort().map(mob => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="mobilite" data-filter-value="${mob}">
                  <span class="text-sm px-3 py-1 bg-gray-100 rounded hover:bg-gray-200">${mob}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Score COM -->
          <div class="mb-4 p-4 border rounded">
            <h3 class="font-bold mb-2">
              <i class="fas fa-chart-bar mr-2"></i>Score Comportement
            </h3>
            <div class="flex gap-2">
              ${Array.from(scoresCOM).sort().map(score => `
                <label class="inline-flex items-center cursor-pointer">
                  <input type="checkbox" class="filter-checkbox mr-2" data-filter-type="scoreCOM" data-filter-value="${score}">
                  <span class="text-sm px-3 py-1 rounded ${score == 1 ? 'bg-red-500 text-white' :
            score == 2 ? 'bg-yellow-400 text-gray-800' :
              score == 3 ? 'bg-green-400 text-white' :
                'bg-green-600 text-white'
          }">${score}</span>
                </label>
              `).join('')}
            </div>
          </div>

          <!-- Boutons -->
          <div class="mt-4 flex gap-2">
            <button onclick="FilterManager.applyFilters()" class="btn btn-primary">
              <i class="fas fa-check"></i> Appliquer les filtres
            </button>
            <button onclick="FilterManager.clearAllFilters()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Effacer tous les filtres
            </button>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">
              <i class="fas fa-times"></i> Fermer
            </button>
          </div>
        </div>
      </div>
    `;

        document.body.appendChild(modal);

        // Restaurer les filtres actifs
        Object.keys(this.activeFilters).forEach(key => {
          const [type, value] = key.split(':');
          const checkbox = modal.querySelector(`[data-filter-type="${type}"][data-filter-value="${value}"]`);
          if (checkbox) checkbox.checked = true;
        });

        // GÃ©rer les changements de checkbox
        modal.querySelectorAll('.filter-checkbox').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            this.updateActiveFiltersDisplay(modal);
          });
        });

        this.updateActiveFiltersDisplay(modal);
      },

      // Mettre Ã  jour l'affichage des filtres actifs
      updateActiveFiltersDisplay(modal) {
        const checkedBoxes = modal.querySelectorAll('.filter-checkbox:checked');
        const display = modal.querySelector('#activeFiltersDisplay');
        const list = modal.querySelector('#activeFiltersList');

        if (checkedBoxes.length === 0) {
          display.classList.add('hidden');
          return;
        }

        display.classList.remove('hidden');
        list.innerHTML = Array.from(checkedBoxes).map(checkbox => {
          const type = checkbox.dataset.filterType;
          const value = checkbox.dataset.filterValue;
          return `
        <span class="px-2 py-1 bg-blue-500 text-white text-xs rounded">
          ${type}: ${value}
        </span>
      `;
        }).join('');
      },

      // Appliquer les filtres
      applyFilters() {
        const modal = document.getElementById('filtersModal');
        if (!modal) return;

        const checkedBoxes = modal.querySelectorAll('.filter-checkbox:checked');

        // Sauvegarder les filtres actifs
        this.activeFilters = {};
        checkedBoxes.forEach(checkbox => {
          const type = checkbox.dataset.filterType;
          const value = checkbox.dataset.filterValue;
          this.activeFilters[`${type}:${value}`] = { type, value };
        });

        // Appliquer le filtre sur toutes les cartes
        document.querySelectorAll('.student-card').forEach(card => {
          const eleve = STATE.students[card.dataset.id];
          if (!eleve) return;

          let match = true;

          if (checkedBoxes.length > 0) {
            match = Array.from(checkedBoxes).some(checkbox => {
              const type = checkbox.dataset.filterType;
              const value = checkbox.dataset.filterValue;

              switch (type) {
                case 'lv2': return eleve.lv2 === value;
                case 'opt': return eleve.opt === value;
                case 'disso': return eleve.disso === value;
                case 'asso': return eleve.asso === value;
                case 'mobilite': return eleve.mobilite === value;
                case 'scoreCOM': return eleve.scores && eleve.scores.COM == value;
                default: return false;
              }
            });
          }

          if (match) {
            card.style.opacity = '1';
            card.style.filter = 'none';
          } else {
            card.style.opacity = '0.3';
            card.style.filter = 'grayscale(1)';
          }
        });

        modal.remove();

        if (checkedBoxes.length > 0) {
          toast(`${checkedBoxes.length} filtre(s) appliquÃ©(s)`, 'success');
        } else {
          toast('Tous les filtres effacÃ©s', 'info');
        }
      },

      // Effacer tous les filtres
      clearAllFilters() {
        this.activeFilters = {};

        document.querySelectorAll('.student-card').forEach(card => {
          card.style.opacity = '1';
          card.style.filter = 'none';
        });

        const modal = document.getElementById('filtersModal');
        if (modal) {
          modal.querySelectorAll('.filter-checkbox').forEach(cb => cb.checked = false);
          this.updateActiveFiltersDisplay(modal);
        }

        toast('Tous les filtres effacÃ©s', 'info');
      }
    };

    // 5. TEMPLATES DE GROUPES RÃ‰UTILISABLES
    // 6. HISTORIQUE DÃ‰TAILLÃ‰ AVEC DIFF
    const HistoryManager = {
      history: [],
      maxHistory: 50,

      // Sauvegarder l'Ã©tat actuel
      saveState() {
        const state = this.captureCurrentState();
        this.history.push({
          timestamp: new Date(),
          state: state
        });

        // Limiter la taille de l'historique
        if (this.history.length > this.maxHistory) {
          this.history.shift();
        }
      },

      // Capturer l'Ã©tat actuel
      captureCurrentState() {
        const state = {};

        document.querySelectorAll('.class-column').forEach(col => {
          const classe = col.querySelector('.classe-name').textContent;
          state[classe] = [];

          col.querySelectorAll('.student-card').forEach(card => {
            const eleve = STATE.students[card.dataset.id];
            if (eleve) {
              state[classe].push(eleve.id);
            }
          });
        });

        return state;
      },

      // Comparer deux Ã©tats
      compareStates(before, after) {
        const changes = [];

        // Trouver les classes communes
        const allClasses = new Set([...Object.keys(before), ...Object.keys(after)]);

        allClasses.forEach(classe => {
          const beforeStudents = before[classe] || [];
          const afterStudents = after[classe] || [];

          // Ã‰lÃ¨ves ajoutÃ©s
          const added = afterStudents.filter(id => !beforeStudents.includes(id));

          // Ã‰lÃ¨ves retirÃ©s
          const removed = beforeStudents.filter(id => !afterStudents.includes(id));

          if (added.length || removed.length) {
            changes.push({
              classe,
              added: added.map(id => STATE.students[id]?.nom || id),
              removed: removed.map(id => STATE.students[id]?.nom || id),
              timestamp: new Date()
            });
          }
        });

        return changes;
      },

      // Afficher l'historique des changements
      showHistory() {
        if (this.history.length < 2) {
          toast('Pas assez d\'historique pour comparer', 'warning');
          return;
        }

        const recent = this.history.slice(-5); // 5 derniers Ã©tats
        const changes = [];

        for (let i = 1; i < recent.length; i++) {
          const stateChanges = this.compareStates(recent[i - 1].state, recent[i].state);
          if (stateChanges.length > 0) {
            changes.push({
              timestamp: recent[i].timestamp,
              changes: stateChanges
            });
          }
        }

        if (changes.length === 0) {
          toast('Aucun changement dÃ©tectÃ©', 'info');
          return;
        }

        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.innerHTML = `
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h2 class="text-xl font-bold">Historique des changements</h2>
          <button onclick="this.closest('.modal').remove()" class="text-gray-400 hover:text-gray-600">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="modal-body">
          <div class="space-y-4">
            ${changes.map(change => `
              <div class="border rounded p-3">
                <div class="font-semibold text-sm text-gray-600 mb-2">
                  ${change.timestamp.toLocaleString()}
                </div>
                ${change.changes.map(c => `
                  <div class="ml-4 mb-2">
                    <div class="font-medium">${c.classe}</div>
                    ${c.added.length > 0 ? `
                      <div class="text-green-600 text-sm">
                        <i class="fas fa-plus"></i> AjoutÃ©s: ${c.added.join(', ')}
                      </div>
                    ` : ''}
                    ${c.removed.length > 0 ? `
                      <div class="text-red-600 text-sm">
                        <i class="fas fa-minus"></i> RetirÃ©s: ${c.removed.join(', ')}
                      </div>
                    ` : ''}
                  </div>
                `).join('')}
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
        document.body.appendChild(modal);
      },

      // Annuler le dernier changement
      undo() {
        if (this.history.length < 2) {
          toast('Rien Ã  annuler', 'warning');
          return;
        }

        const previousState = this.history[this.history.length - 2].state;
        this.restoreState(previousState);
        this.history.pop(); // Retirer l'Ã©tat actuel

        toast('Changement annulÃ©', 'success');
      },

      // Restaurer un Ã©tat
      restoreState(state) {
        // Cette fonction restaurerait l'Ã©tat prÃ©cÃ©dent
        // ImplÃ©mentation complexe qui nÃ©cessiterait de modifier l'interface
        console.log('Restauration de l\'Ã©tat:', state);
      }
    };

    // 7. MODE SIMULATION
    // ========== INTÃ‰GRATION DES NOUVELLES FONCTIONS ==========

    // Ajouter les boutons dans l'interface
    // ========== CONFIGURATION DES BOUTONS AVANCÃ‰S DANS LE MENU ACTIONS ==========
    function configureAdvancedFeaturesButtons() {
      // Bouton Import Scores
      const importBtn = document.getElementById('btnImportScores');
      if (importBtn) {
        importBtn.onclick = () => {
          ScoreImporter.importScoresFromINT();
          // Fermer le menu aprÃ¨s clic
          document.getElementById('actionsDropdown').classList.add('hidden');
        };
      }

      // Bouton Optimisation
      const optimizeBtn = document.getElementById('btnOptimize');
      if (optimizeBtn) {
        optimizeBtn.onclick = () => {
          OptimizerV2.applyOptimization();
          document.getElementById('actionsDropdown').classList.add('hidden');
        };
      }

      // Bouton Contraintes
      const constraintsBtn = document.getElementById('btnConstraints');
      if (constraintsBtn) {
        constraintsBtn.onclick = () => {
          ConstraintManager.showConstraintViolations();
          document.getElementById('actionsDropdown').classList.add('hidden');
        };
      }

      // Bouton Feedback en temps rÃ©el (dans le menu des groupes)
      document.addEventListener('click', (e) => {
        if (e.target.closest('#btnGroupFeedback')) {
          if (RealTimeFeedback) {
            const panel = document.getElementById('feedbackPanel');
            if (panel && panel.style.display === 'none') {
              RealTimeFeedback.show();
              e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Masquer';
            } else {
              RealTimeFeedback.hide();
              e.target.closest('#btnGroupFeedback').innerHTML = '<i class="fas fa-chart-line"></i> Indicateurs';
            }
          }
        }

        // Bouton Statistiques des groupes
        if (e.target.closest('#btnGroupStats')) {
          const statsPanel = document.getElementById('statsPanel');
          if (statsPanel) {
            // Basculer l'affichage du panneau de statistiques
            if (statsPanel.classList.contains('translate-x-full')) {
              statsPanel.classList.remove('translate-x-full');

              // Initialiser le contenu seulement si pas encore fait
              const statsContent = document.getElementById('statsContent');
              if (!statsContent.innerHTML.trim()) {
                if (typeof initCharts === 'function') {
                  initCharts();
                }
              }

              // MISE Ã€ JOUR INTELLIGENTE DES STATISTIQUES
              if (typeof updateStatsPanel === 'function') {
                updateStatsPanel();
              }

              // Changer le titre pour indiquer qu'on affiche les stats des groupes
              const title = statsPanel.querySelector('h2');
              if (title) {
                title.textContent = 'Statistiques des Groupes';
              }
            } else {
              statsPanel.classList.add('translate-x-full');
            }
          }
        }
      });
    }

    // ========== INITIALISATION AU CHARGEMENT ==========

    document.addEventListener('DOMContentLoaded', () => {
      // Feedback temps rÃ©el
      setTimeout(() => { if (RealTimeFeedback) RealTimeFeedback.init(); }, 500);

      // Boutons avancÃ©s
      setTimeout(configureAdvancedFeaturesButtons, 2000);

      // Fermeture stats
      const closeStatsBtn = document.getElementById('closeStats');
      if (closeStatsBtn) {
        closeStatsBtn.addEventListener('click', () => {
          closeStatsPanel();
          const btnStats = document.getElementById('btnStats');
          if (btnStats) btnStats.setAttribute('aria-expanded', 'false');
        });
      }

      // Toggle mode sombre flottant
      const darkModeToggle = document.getElementById('darkModeToggle');
      if (darkModeToggle) darkModeToggle.addEventListener('click', toggleDarkMode);

      // Sauvegarder l'Ã©tat initial + optimiser le rendu
      setTimeout(() => { HistoryManager.saveState(); }, 3000);
      setTimeout(optimizeCardRendering, 1000);
    });

    // Fonction pour initialiser les groupes aprÃ¨s fermeture du modal
    window.initializeGroupsAfterModal = function () {
      // Respecter le paramÃ¨tre global UI (SHOW_GROUPS_BUTTON)
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        google.script.run
          .withSuccessHandler(function (settings) {
            if (settings && settings.SHOW_GROUPS_BUTTON) {
              addGroupsButton();
            } else {
              removeGroupsButton();
            }
            // Charger les groupes sauvegardÃ©s SANS les afficher
            if (window.GroupManager && GroupManager.loadGroups) {
              GroupManager.loadGroups();
              if (GroupManager.updateGroupsButton) {
                GroupManager.updateGroupsButton();
              }
            }
          })
          .withFailureHandler(function (err) {
            console.error('Erreur getUiSettings:', err);
            removeGroupsButton();
          })
          .getUiSettings();
      } else {
        // En mode local (pas de GAS), ne pas afficher par dÃ©faut
        removeGroupsButton();
      }
    };

    // ========== THROTTLE DU FEEDBACK TEMPS RÃ‰EL ==========
    if (window.RealTimeFeedback) {
      const originalUpdateMetrics = RealTimeFeedback.updateMetrics;
      let lastUpdate = 0;
      const THROTTLE_DELAY = 500; // Mise Ã  jour max toutes les 500ms

      RealTimeFeedback.updateMetrics = function () {
        const now = Date.now();
        if (now - lastUpdate < THROTTLE_DELAY) {
          return;
        }
        lastUpdate = now;

        if (originalUpdateMetrics) {
          originalUpdateMetrics.call(this);
        }
      };
    }


    // VÃ©rifier si les graphiques sont prÃªts
    window.areChartsReady = function () {
      return window.chartCommunication &&
        window.chartDistribution &&
        window.chartLV2 &&
        window.chartOptions &&
        typeof window.chartCommunication.update === 'function';
    };

    // Optimisation du rendu des cartes
    window.optimizeCardRendering = function () {
      // Utiliser requestAnimationFrame pour les mises Ã  jour visuelles
      const cards = document.querySelectorAll('.student-card');
      let index = 0;

      function processNextBatch() {
        const batchSize = 10;
        const batch = Array.from(cards).slice(index, index + batchSize);

        batch.forEach(card => {
          // Appliquer les optimisations de rendu
          card.style.willChange = 'transform';
          card.style.backfaceVisibility = 'hidden';
        });

        index += batchSize;

        if (index < cards.length) {
          requestAnimationFrame(processNextBatch);
        }
      }

      requestAnimationFrame(processNextBatch);
    };


    // ========== UTILITAIRES FINAUX ==========
    if (typeof window.chartLV2Details === 'undefined') {
      window.chartLV2Details = null;
    }

    // 2. Fonction utilitaire pour mise Ã  jour sÃ©curisÃ©e des graphiques
    window.safeUpdateChart = function (chart) {
      if (chart && typeof chart.update === 'function') {
        try {
          chart.update('none'); // Mise Ã  jour sans animation pour plus de fluiditÃ©
        } catch (error) {
          console.warn('Erreur mise Ã  jour graphique:', error);
        }
      }
    };

    // 3. SystÃ¨me de gestion des event listeners pour Ã©viter les doublons
    window.EventManager = {
      listeners: [],

      add: function (element, event, handler, options = {}) {
        // VÃ©rifier si le listener existe dÃ©jÃ 
        const existing = this.listeners.find(l =>
          l.element === element && l.event === event && l.handler === handler
        );

        if (!existing) {
          element.addEventListener(event, handler, options);
          this.listeners.push({ element, event, handler, options });
        }
      },

      remove: function (element, event, handler) {
        element.removeEventListener(event, handler);
        this.listeners = this.listeners.filter(l =>
          !(l.element === element && l.event === event && l.handler === handler)
        );
      },

      clear: function () {
        this.listeners.forEach(({ element, event, handler }) => {
          element.removeEventListener(event, handler);
        });
        this.listeners = [];
      }
    };

    // Initialisation unique de l'application
    window.addEventListener('DOMContentLoaded', () => {
      if (window._initialized) return;
      window._initialized = true;

      setTimeout(() => {
        if (typeof initRepartitionApp === 'function') initRepartitionApp();
      }, 100);
    });


  })(); // Fin du DOM Environment Guard IIFE
</script>